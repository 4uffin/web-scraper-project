jedavidsonâ€™s gists Â· GitHub
Skip to content
Search Gists
Search Gists
All gists
Back to GitHub
Sign in
Sign up
SignÂ in
SignÂ up
You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.
Dismiss alert
Instantly share code, notes, and snippets.
ðŸ†—
()
James Davidson
jedavidson
ðŸ†—
()
68
followers
Â·
41
following
VivCourt Trading
Sydney, Australia
14:59
(UTC +10:00)
View GitHub Profile
All gists
8
Starred
1
Sort
Recently created
Least recently created
Recently updated
Least recently updated
Sort
Recently created
Least recently created
Recently updated
Least recently updated
2 files
0 forks
0 comments
0 stars
jedavidson
/ README.md
Last active
January 19, 2025 06:50
Terrible experiments in implementing a monomorphised hash table in C
Include and use as follows:
// one for int -> int
#define HASHTABLE_KEY_TYPE int
#define HASHTABLE_VALUE_TYPE int
#define HASHTABLE_ADT_NAME IntHashTable
#include "hashtable.h"
// one for string -&gt; int
1 file
0 forks
3 comments
0 stars
jedavidson
/ 3141_exam_questions.md
Last active
July 26, 2025 04:20
Some concepts I had for COMP3141 exam questions.
In the exercises and assignments, you may have made use of the >> operator. If not, here is its implementation:
(>>) :: (Monad m) => m t -> m u -> m u
a >> b = a >>= (\_ -> b)
It behaves identically to >>=, except that it discards the result of the first monadic operation.
Prove by careful equational reasoning that >> is associative, i.e. (a >> b) >> c == a >> (b >> c).
Give an example to explain why >>= must be left-associative.
2 files
0 forks
1 comment
0 stars
jedavidson
/ dna.cpp
Last active
January 10, 2025 11:04
#include <cassert>
#include <string>
// A storage class for DNA sequences, which are sequences (i.e. strings)
// consisting of one of four bases: A, C, T and G.
class dna_store {
public:
// Adds a sequence to the store. You may assume that the sequence
// is a nonempty string made up only of the letters {A, C, T, G}.
void add(const std::string &seq) {
2 files
0 forks
3 comments
0 stars
jedavidson
/ price.cpp
Last active
January 28, 2024 07:42
#include <cassert>
#include <vector>
// Given some price information at discrete time intervals, returns a suitable
// value for the price at a given time interval. You may assume that times is
// sorted in ascending order, and that there are at least two datapoints (i.e.
// prices for at least two times).
auto stock_price(int time, std::vector<int> const &times,
std::vector<float> const &prices) -> float {
return 0;
3 files
0 forks
0 comments
0 stars
jedavidson
/ README.md
Last active
August 14, 2022 04:01
Attempt eval first, and then try satisfiable.
Download eval.c and satisfiable.c to your machine by copy/pasting the code into files with the same name.
Compile using dcc -o eval eval.c and dcc -o satisfiable satisfiable.c respectively.
Instructions, including the problem statement and how to run each program, are given in each file.
Good luck!
1 file
0 forks
0 comments
0 stars
jedavidson
/ unixverse.sh
Last active
March 1, 2021 00:48
A list of examples showing off the commands in CSESoc's 2021 Into the Unixverse workshop.
########################
# File system commands #
########################
# Show the current working directory
pwd
# View the contents of the working directory
ls
1 file
0 forks
0 comments
2 stars
jedavidson
/ prooftrees.tex
Last active
November 1, 2024 00:12
An example of how to use the bussproofs.sty file for setting out proof trees.
% I'm assuming you have the package imported already
\usepackage{bussproofs}
% In these examples, I like indenting the InfC part of each proof tree from the AxiomC(s) that spawned it,
% and keeping those AxiomC(s) on the same indent level, but I keep the bottom, final InfC unindented
% This is a personal choice but it makes it easier to keep track of what's happening for large trees
% A rule with no assumptions (i.e. an axiom)
\begin{prooftree}
\AxiomC{}
1 file
6 forks
1 comment
58 stars
jedavidson
/ 2521_exercises.md
Last active
September 18, 2025 02:30
A curated list of some good revision and exam preparation programming problems for UNSW's COMP2521. Personal opinion.
These exercises are some I did while studying for COMP2521, as well as some others which I've found afterwards which I think will be relevant. I've collected these problems mostly from LeetCode and HackerRank, which are excellent sites for practicing your coding abilities. Accounts on both sites will be necessary to do the problems listed.
The difficulty ranking is obviously my opinion, but generally speaking here is what they mean:
Easy: Problems that you should be able to do without too much difficulty.
Intermediate: Problems that are a bit harder, but should be doable with a little bit of thought and intuition.
Challenges: Problems that I think are difficult and/or interesting, if you're up for it. There are almost all harder than what's within the scope of 2521.
If you're able to solve the easy and intermediate problems without much difficulty, you're probably very well prepared for any programming questions you'll receive in the ex
Footer
Â© 2025 GitHub,Â Inc.
Footer navigation
Terms
Privacy
Security
Status
Docs
Contact
Manage cookies
Do not share my personal information
You canâ€™t perform that action at this time.