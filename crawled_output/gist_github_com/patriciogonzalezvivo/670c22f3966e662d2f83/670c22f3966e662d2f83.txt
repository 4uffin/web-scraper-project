GLSL Noise Algorithms
· GitHub
Skip to content
Search Gists
Search Gists
All gists
Back to GitHub
Sign in
Sign up
Sign in
Sign up
You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.
Dismiss alert
Instantly share code, notes, and snippets.
patriciogonzalezvivo/GLSL-Noise.md
Last active
September 24, 2025 00:14
Show Gist options
Download ZIP
Star
1,826
(1,826)
You must be signed in to star a gist
Fork
281
(281)
You must be signed in to fork a gist
Embed
Embed
Embed this gist in your website.
Share
Copy sharable link for this gist.
Clone via HTTPS
Clone using the web URL.
Learn more about clone URLs
Clone this repository at &lt;script src=&quot;https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83.js&quot;&gt;&lt;/script&gt;
Save patriciogonzalezvivo/670c22f3966e662d2f83 to your computer and use it in GitHub Desktop.
Code
Revisions
10
Stars
1,826
Forks
281
Embed
Embed
Embed this gist in your website.
Share
Copy sharable link for this gist.
Clone via HTTPS
Clone using the web URL.
Learn more about clone URLs
Clone this repository at &lt;script src=&quot;https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83.js&quot;&gt;&lt;/script&gt;
Save patriciogonzalezvivo/670c22f3966e662d2f83 to your computer and use it in GitHub Desktop.
Download ZIP
GLSL Noise Algorithms
Raw
GLSL-Noise.md
Please consider using http://lygia.xyz instead of copy/pasting this functions. It expand suport for voronoi, voronoise, fbm, noise, worley, noise, derivatives and much more, through simple file dependencies. Take a look to https://github.com/patriciogonzalezvivo/lygia/tree/main/generative
Generic 1,2,3 Noise
float rand(float n){return fract(sin(n) * 43758.5453123);}
float noise(float p){
float fl = floor(p);
float fc = fract(p);
return mix(rand(fl), rand(fl + 1.0), fc);
}
float noise(vec2 n) {
const vec2 d = vec2(0.0, 1.0);
vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}
float rand(vec2 n) {
return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}
float noise(vec2 p){
vec2 ip = floor(p);
vec2 u = fract(p);
u = u*u*(3.0-2.0*u);
float res = mix(
mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
return res*res;
}
float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}
float noise(vec3 p){
vec3 a = floor(p);
vec3 d = p - a;
d = d * d * (3.0 - 2.0 * d);
vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
vec4 k1 = perm(b.xyxy);
vec4 k2 = perm(k1.xyxy + b.zzww);
vec4 c = k2 + a.zzzz;
vec4 k3 = perm(c);
vec4 k4 = perm(c + 1.0);
vec4 o1 = fract(k3 * (1.0 / 41.0));
vec4 o2 = fract(k4 * (1.0 / 41.0));
vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
return o4.y * d.y + o4.x * (1.0 - d.y);
}
//	<https://www.shadertoy.com/view/4dS3Wd>
//	By Morgan McGuire @morgan3d, http://graphicscodex.com
//
float hash(float n) { return fract(sin(n) * 1e4); }
float hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
float noise(float x) {
float i = floor(x);
float f = fract(x);
float u = f * f * (3.0 - 2.0 * f);
return mix(hash(i), hash(i + 1.0), u);
}
float noise(vec2 x) {
vec2 i = floor(x);
vec2 f = fract(x);
// Four corners in 2D of a tile
float a = hash(i);
float b = hash(i + vec2(1.0, 0.0));
float c = hash(i + vec2(0.0, 1.0));
float d = hash(i + vec2(1.0, 1.0));
// Simple 2D lerp using smoothstep envelope between the values.
// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),
//			mix(c, d, smoothstep(0.0, 1.0, f.x)),
//			smoothstep(0.0, 1.0, f.y)));
// Same code, with the clamps in smoothstep and common subexpressions
// optimized away.
vec2 u = f * f * (3.0 - 2.0 * f);
return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
// This one has non-ideal tiling properties that I'm still tuning
float noise(vec3 x) {
const vec3 step = vec3(110, 241, 171);
vec3 i = floor(x);
vec3 f = fract(x);
// For performance, compute the base input to a 1D hash from the integer part of the argument and the
// incremental change to the 1D based on the 3D -> 1D wrapping
float n = dot(i, step);
vec3 u = f * f * (3.0 - 2.0 * f);
return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),
mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),
mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
}
Perlin Noise
float rand(vec2 c){
return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
float noise(vec2 p, float freq ){
float unit = screenWidth/freq;
vec2 ij = floor(p/unit);
vec2 xy = mod(p,unit)/unit;
//xy = 3.*xy*xy-2.*xy*xy*xy;
xy = .5*(1.-cos(PI*xy));
float a = rand((ij+vec2(0.,0.)));
float b = rand((ij+vec2(1.,0.)));
float c = rand((ij+vec2(0.,1.)));
float d = rand((ij+vec2(1.,1.)));
float x1 = mix(a, b, xy.x);
float x2 = mix(c, d, xy.x);
return mix(x1, x2, xy.y);
}
float pNoise(vec2 p, int res){
float persistance = .5;
float n = 0.;
float normK = 0.;
float f = 4.;
float amp = 1.;
int iCount = 0;
for (int i = 0; i<50; i++){
n+=amp*noise(p, f);
f*=2.;
normK+=amp;
amp*=persistance;
if (iCount == res) break;
iCount++;
}
float nf = n/normK;
return nf*nf*nf*nf;
}
#define M_PI 3.14159265358979323846
float rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}
float rand (vec2 co, float l) {return rand(vec2(rand(co), l));}
float rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}
float perlin(vec2 p, float dim, float time) {
vec2 pos = floor(p * dim);
vec2 posx = pos + vec2(1.0, 0.0);
vec2 posy = pos + vec2(0.0, 1.0);
vec2 posxy = pos + vec2(1.0);
float c = rand(pos, dim, time);
float cx = rand(posx, dim, time);
float cy = rand(posy, dim, time);
float cxy = rand(posxy, dim, time);
vec2 d = fract(p * dim);
d = -0.5 * cos(d * M_PI) + 0.5;
float ccx = mix(c, cx, d.x);
float cycxy = mix(cy, cxy, d.x);
float center = mix(ccx, cycxy, d.y);
return center * 2.0 - 1.0;
}
// p must be normalized!
float perlin(vec2 p, float dim) {
/*vec2 pos = floor(p * dim);
vec2 posx = pos + vec2(1.0, 0.0);
vec2 posy = pos + vec2(0.0, 1.0);
vec2 posxy = pos + vec2(1.0);
// For exclusively black/white noise
/*float c = step(rand(pos, dim), 0.5);
float cx = step(rand(posx, dim), 0.5);
float cy = step(rand(posy, dim), 0.5);
float cxy = step(rand(posxy, dim), 0.5);*/
/*float c = rand(pos, dim);
float cx = rand(posx, dim);
float cy = rand(posy, dim);
float cxy = rand(posxy, dim);
vec2 d = fract(p * dim);
d = -0.5 * cos(d * M_PI) + 0.5;
float ccx = mix(c, cx, d.x);
float cycxy = mix(cy, cxy, d.x);
float center = mix(ccx, cycxy, d.y);
return center * 2.0 - 1.0;*/
return perlin(p, dim, 0.0);
}
Classic Perlin Noise
//	Classic Perlin 2D Noise
//	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
float cnoise(vec2 P){
vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
vec4 ix = Pi.xzxz;
vec4 iy = Pi.yyww;
vec4 fx = Pf.xzxz;
vec4 fy = Pf.yyww;
vec4 i = permute(permute(ix) + iy);
vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
vec4 gy = abs(gx) - 0.5;
vec4 tx = floor(gx + 0.5);
gx = gx - tx;
vec2 g00 = vec2(gx.x,gy.x);
vec2 g10 = vec2(gx.y,gy.y);
vec2 g01 = vec2(gx.z,gy.z);
vec2 g11 = vec2(gx.w,gy.w);
vec4 norm = 1.79284291400159 - 0.85373472095314 *
vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
g00 *= norm.x;
g01 *= norm.y;
g10 *= norm.z;
g11 *= norm.w;
float n00 = dot(g00, vec2(fx.x, fy.x));
float n10 = dot(g10, vec2(fx.y, fy.y));
float n01 = dot(g01, vec2(fx.z, fy.z));
float n11 = dot(g11, vec2(fx.w, fy.w));
vec2 fade_xy = fade(Pf.xy);
vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
return 2.3 * n_xy;
}
//	Classic Perlin 3D Noise
//	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
float cnoise(vec3 P){
vec3 Pi0 = floor(P); // Integer part for indexing
vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
Pi0 = mod(Pi0, 289.0);
Pi1 = mod(Pi1, 289.0);
vec3 Pf0 = fract(P); // Fractional part for interpolation
vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
vec4 iy = vec4(Pi0.yy, Pi1.yy);
vec4 iz0 = Pi0.zzzz;
vec4 iz1 = Pi1.zzzz;
vec4 ixy = permute(permute(ix) + iy);
vec4 ixy0 = permute(ixy + iz0);
vec4 ixy1 = permute(ixy + iz1);
vec4 gx0 = ixy0 / 7.0;
vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
gx0 = fract(gx0);
vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
vec4 sz0 = step(gz0, vec4(0.0));
gx0 -= sz0 * (step(0.0, gx0) - 0.5);
gy0 -= sz0 * (step(0.0, gy0) - 0.5);
vec4 gx1 = ixy1 / 7.0;
vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
gx1 = fract(gx1);
vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
vec4 sz1 = step(gz1, vec4(0.0));
gx1 -= sz1 * (step(0.0, gx1) - 0.5);
gy1 -= sz1 * (step(0.0, gy1) - 0.5);
vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
g000 *= norm0.x;
g010 *= norm0.y;
g100 *= norm0.z;
g110 *= norm0.w;
vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
g001 *= norm1.x;
g011 *= norm1.y;
g101 *= norm1.z;
g111 *= norm1.w;
float n000 = dot(g000, Pf0);
float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
float n111 = dot(g111, Pf1);
vec3 fade_xyz = fade(Pf0);
vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
return 2.2 * n_xyz;
}
//	Classic Perlin 3D Noise
//	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
float cnoise(vec4 P){
vec4 Pi0 = floor(P); // Integer part for indexing
vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
Pi0 = mod(Pi0, 289.0);
Pi1 = mod(Pi1, 289.0);
vec4 Pf0 = fract(P); // Fractional part for interpolation
vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
vec4 iy = vec4(Pi0.yy, Pi1.yy);
vec4 iz0 = vec4(Pi0.zzzz);
vec4 iz1 = vec4(Pi1.zzzz);
vec4 iw0 = vec4(Pi0.wwww);
vec4 iw1 = vec4(Pi1.wwww);
vec4 ixy = permute(permute(ix) + iy);
vec4 ixy0 = permute(ixy + iz0);
vec4 ixy1 = permute(ixy + iz1);
vec4 ixy00 = permute(ixy0 + iw0);
vec4 ixy01 = permute(ixy0 + iw1);
vec4 ixy10 = permute(ixy1 + iw0);
vec4 ixy11 = permute(ixy1 + iw1);
vec4 gx00 = ixy00 / 7.0;
vec4 gy00 = floor(gx00) / 7.0;
vec4 gz00 = floor(gy00) / 6.0;
gx00 = fract(gx00) - 0.5;
gy00 = fract(gy00) - 0.5;
gz00 = fract(gz00) - 0.5;
vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
vec4 sw00 = step(gw00, vec4(0.0));
gx00 -= sw00 * (step(0.0, gx00) - 0.5);
gy00 -= sw00 * (step(0.0, gy00) - 0.5);
vec4 gx01 = ixy01 / 7.0;
vec4 gy01 = floor(gx01) / 7.0;
vec4 gz01 = floor(gy01) / 6.0;
gx01 = fract(gx01) - 0.5;
gy01 = fract(gy01) - 0.5;
gz01 = fract(gz01) - 0.5;
vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
vec4 sw01 = step(gw01, vec4(0.0));
gx01 -= sw01 * (step(0.0, gx01) - 0.5);
gy01 -= sw01 * (step(0.0, gy01) - 0.5);
vec4 gx10 = ixy10 / 7.0;
vec4 gy10 = floor(gx10) / 7.0;
vec4 gz10 = floor(gy10) / 6.0;
gx10 = fract(gx10) - 0.5;
gy10 = fract(gy10) - 0.5;
gz10 = fract(gz10) - 0.5;
vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
vec4 sw10 = step(gw10, vec4(0.0));
gx10 -= sw10 * (step(0.0, gx10) - 0.5);
gy10 -= sw10 * (step(0.0, gy10) - 0.5);
vec4 gx11 = ixy11 / 7.0;
vec4 gy11 = floor(gx11) / 7.0;
vec4 gz11 = floor(gy11) / 6.0;
gx11 = fract(gx11) - 0.5;
gy11 = fract(gy11) - 0.5;
gz11 = fract(gz11) - 0.5;
vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
vec4 sw11 = step(gw11, vec4(0.0));
gx11 -= sw11 * (step(0.0, gx11) - 0.5);
gy11 -= sw11 * (step(0.0, gy11) - 0.5);
vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
g0000 *= norm00.x;
g0100 *= norm00.y;
g1000 *= norm00.z;
g1100 *= norm00.w;
vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
g0001 *= norm01.x;
g0101 *= norm01.y;
g1001 *= norm01.z;
g1101 *= norm01.w;
vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
g0010 *= norm10.x;
g0110 *= norm10.y;
g1010 *= norm10.z;
g1110 *= norm10.w;
vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
g0011 *= norm11.x;
g0111 *= norm11.y;
g1011 *= norm11.z;
g1111 *= norm11.w;
float n0000 = dot(g0000, Pf0);
float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
float n1111 = dot(g1111, Pf1);
vec4 fade_xyzw = fade(Pf0);
vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
return 2.2 * n_xyzw;
}
// Classic Perlin noise, periodic version
float cnoise(vec4 P, vec4 rep){
vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep
vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep
vec4 Pf0 = fract(P); // Fractional part for interpolation
vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
vec4 iy = vec4(Pi0.yy, Pi1.yy);
vec4 iz0 = vec4(Pi0.zzzz);
vec4 iz1 = vec4(Pi1.zzzz);
vec4 iw0 = vec4(Pi0.wwww);
vec4 iw1 = vec4(Pi1.wwww);
vec4 ixy = permute(permute(ix) + iy);
vec4 ixy0 = permute(ixy + iz0);
vec4 ixy1 = permute(ixy + iz1);
vec4 ixy00 = permute(ixy0 + iw0);
vec4 ixy01 = permute(ixy0 + iw1);
vec4 ixy10 = permute(ixy1 + iw0);
vec4 ixy11 = permute(ixy1 + iw1);
vec4 gx00 = ixy00 / 7.0;
vec4 gy00 = floor(gx00) / 7.0;
vec4 gz00 = floor(gy00) / 6.0;
gx00 = fract(gx00) - 0.5;
gy00 = fract(gy00) - 0.5;
gz00 = fract(gz00) - 0.5;
vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
vec4 sw00 = step(gw00, vec4(0.0));
gx00 -= sw00 * (step(0.0, gx00) - 0.5);
gy00 -= sw00 * (step(0.0, gy00) - 0.5);
vec4 gx01 = ixy01 / 7.0;
vec4 gy01 = floor(gx01) / 7.0;
vec4 gz01 = floor(gy01) / 6.0;
gx01 = fract(gx01) - 0.5;
gy01 = fract(gy01) - 0.5;
gz01 = fract(gz01) - 0.5;
vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
vec4 sw01 = step(gw01, vec4(0.0));
gx01 -= sw01 * (step(0.0, gx01) - 0.5);
gy01 -= sw01 * (step(0.0, gy01) - 0.5);
vec4 gx10 = ixy10 / 7.0;
vec4 gy10 = floor(gx10) / 7.0;
vec4 gz10 = floor(gy10) / 6.0;
gx10 = fract(gx10) - 0.5;
gy10 = fract(gy10) - 0.5;
gz10 = fract(gz10) - 0.5;
vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
vec4 sw10 = step(gw10, vec4(0.0));
gx10 -= sw10 * (step(0.0, gx10) - 0.5);
gy10 -= sw10 * (step(0.0, gy10) - 0.5);
vec4 gx11 = ixy11 / 7.0;
vec4 gy11 = floor(gx11) / 7.0;
vec4 gz11 = floor(gy11) / 6.0;
gx11 = fract(gx11) - 0.5;
gy11 = fract(gy11) - 0.5;
gz11 = fract(gz11) - 0.5;
vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
vec4 sw11 = step(gw11, vec4(0.0));
gx11 -= sw11 * (step(0.0, gx11) - 0.5);
gy11 -= sw11 * (step(0.0, gy11) - 0.5);
vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
g0000 *= norm00.x;
g0100 *= norm00.y;
g1000 *= norm00.z;
g1100 *= norm00.w;
vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
g0001 *= norm01.x;
g0101 *= norm01.y;
g1001 *= norm01.z;
g1101 *= norm01.w;
vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
g0010 *= norm10.x;
g0110 *= norm10.y;
g1010 *= norm10.z;
g1110 *= norm10.w;
vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
g0011 *= norm11.x;
g0111 *= norm11.y;
g1011 *= norm11.z;
g1111 *= norm11.w;
float n0000 = dot(g0000, Pf0);
float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
float n1111 = dot(g1111, Pf1);
vec4 fade_xyzw = fade(Pf0);
vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
return 2.2 * n_xyzw;
}
Simplex Noise
// Simplex 2D noise
//
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
float snoise(vec2 v){
const vec4 C = vec4(0.211324865405187, 0.366025403784439,
-0.577350269189626, 0.024390243902439);
vec2 i
= floor(v + dot(v, C.yy) );
vec2 x0 = v -
i + dot(i, C.xx);
vec2 i1;
i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
vec4 x12 = x0.xyxy + C.xxzz;
x12.xy -= i1;
i = mod(i, 289.0);
vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
+ i.x + vec3(0.0, i1.x, 1.0 ));
vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
dot(x12.zw,x12.zw)), 0.0);
m = m*m ;
m = m*m ;
vec3 x = 2.0 * fract(p * C.www) - 1.0;
vec3 h = abs(x) - 0.5;
vec3 ox = floor(x + 0.5);
vec3 a0 = x - ox;
m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
vec3 g;
g.x
= a0.x
* x0.x
+ h.x
* x0.y;
g.yz = a0.yz * x12.xz + h.yz * x12.yw;
return 130.0 * dot(m, g);
}
//	Simplex 3D Noise
//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
float snoise(vec3 v){
const vec2
C = vec2(1.0/6.0, 1.0/3.0) ;
const vec4
D = vec4(0.0, 0.5, 1.0, 2.0);
// First corner
vec3 i
= floor(v + dot(v, C.yyy) );
vec3 x0 =
v - i + dot(i, C.xxx) ;
// Other corners
vec3 g = step(x0.yzx, x0.xyz);
vec3 l = 1.0 - g;
vec3 i1 = min( g.xyz, l.zxy );
vec3 i2 = max( g.xyz, l.zxy );
//
x0 = x0 - 0. + 0.0 * C
vec3 x1 = x0 - i1 + 1.0 * C.xxx;
vec3 x2 = x0 - i2 + 2.0 * C.xxx;
vec3 x3 = x0 - 1. + 3.0 * C.xxx;
// Permutations
i = mod(i, 289.0 );
vec4 p = permute( permute( permute(
i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
// Gradients
// ( N*N points uniformly over a square, mapped onto an octahedron.)
float n_ = 1.0/7.0; // N=7
vec3
ns = n_ * D.wyz - D.xzx;
vec4 j = p - 49.0 * floor(p * ns.z *ns.z);
//
mod(p,N*N)
vec4 x_ = floor(j * ns.z);
vec4 y_ = floor(j - 7.0 * x_ );
// mod(j,N)
vec4 x = x_ *ns.x + ns.yyyy;
vec4 y = y_ *ns.x + ns.yyyy;
vec4 h = 1.0 - abs(x) - abs(y);
vec4 b0 = vec4( x.xy, y.xy );
vec4 b1 = vec4( x.zw, y.zw );
vec4 s0 = floor(b0)*2.0 + 1.0;
vec4 s1 = floor(b1)*2.0 + 1.0;
vec4 sh = -step(h, vec4(0.0));
vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
vec3 p0 = vec3(a0.xy,h.x);
vec3 p1 = vec3(a0.zw,h.y);
vec3 p2 = vec3(a1.xy,h.z);
vec3 p3 = vec3(a1.zw,h.w);
//Normalise gradients
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
// Mix final noise value
vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
m = m * m;
return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
dot(p2,x2), dot(p3,x3) ) );
}
//	Simplex 4D Noise
//	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
float permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
float taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}
vec4 grad4(float j, vec4 ip){
const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
vec4 p,s;
p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
s = vec4(lessThan(p, vec4(0.0)));
p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
return p;
}
float snoise(vec4 v){
const vec2
C = vec2( 0.138196601125010504,
// (5 - sqrt(5))/20
G4
0.309016994374947451); // (sqrt(5) - 1)/4
F4
// First corner
vec4 i
= floor(v + dot(v, C.yyyy) );
vec4 x0 = v -
i + dot(i, C.xxxx);
// Other corners
// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
vec4 i0;
vec3 isX = step( x0.yzw, x0.xxx );
vec3 isYZ = step( x0.zww, x0.yyz );
//
i0.x = dot( isX, vec3( 1.0 ) );
i0.x = isX.x + isX.y + isX.z;
i0.yzw = 1.0 - isX;
//
i0.y += dot( isYZ.xy, vec2( 1.0 ) );
i0.y += isYZ.x + isYZ.y;
i0.zw += 1.0 - isYZ.xy;
i0.z += isYZ.z;
i0.w += 1.0 - isYZ.z;
// i0 now contains the unique values 0,1,2,3 in each channel
vec4 i3 = clamp( i0, 0.0, 1.0 );
vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );
//
x0 = x0 - 0.0 + 0.0 * C
vec4 x1 = x0 - i1 + 1.0 * C.xxxx;
vec4 x2 = x0 - i2 + 2.0 * C.xxxx;
vec4 x3 = x0 - i3 + 3.0 * C.xxxx;
vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;
// Permutations
i = mod(i, 289.0);
float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
vec4 j1 = permute( permute( permute( permute (
i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
// Gradients
// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)
// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;
vec4 p0 = grad4(j0,
ip);
vec4 p1 = grad4(j1.x, ip);
vec4 p2 = grad4(j1.y, ip);
vec4 p3 = grad4(j1.z, ip);
vec4 p4 = grad4(j1.w, ip);
// Normalise gradients
vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
p0 *= norm.x;
p1 *= norm.y;
p2 *= norm.z;
p3 *= norm.w;
p4 *= taylorInvSqrt(dot(p4,p4));
// Mix contributions from the five corners
vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)
), 0.0);
m0 = m0 * m0;
m1 = m1 * m1;
return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
}
// 	<www.shadertoy.com/view/XsX3zB>
//	by Nikita Miropolskiy
/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */
vec3 random3(vec3 c) {
float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
vec3 r;
r.z = fract(512.0*j);
j *= .125;
r.x = fract(512.0*j);
j *= .125;
r.y = fract(512.0*j);
return r-0.5;
}
const float F3 =
0.3333333;
const float G3 =
0.1666667;
float snoise(vec3 p) {
vec3 s = floor(p + dot(p, vec3(F3)));
vec3 x = p - s + dot(s, vec3(G3));
vec3 e = step(vec3(0.0), x - x.yzx);
vec3 i1 = e*(1.0 - e.zxy);
vec3 i2 = 1.0 - e.zxy*(1.0 - e);
vec3 x1 = x - i1 + G3;
vec3 x2 = x - i2 + 2.0*G3;
vec3 x3 = x - 1.0 + 3.0*G3;
vec4 w, d;
w.x = dot(x, x);
w.y = dot(x1, x1);
w.z = dot(x2, x2);
w.w = dot(x3, x3);
w = max(0.6 - w, 0.0);
d.x = dot(random3(s), x);
d.y = dot(random3(s + i1), x1);
d.z = dot(random3(s + i2), x2);
d.w = dot(random3(s + 1.0), x3);
w *= w;
w *= w;
d *= w;
return dot(d, vec4(52.0));
}
float snoiseFractal(vec3 m) {
return
0.5333333* snoise(m)
+0.2666667* snoise(2.0*m)
+0.1333333* snoise(4.0*m)
+0.0666667* snoise(8.0*m);
}
NormalMap Noise
vec3 normalNoise(vec2 _st, float _zoom, float _speed){
vec2 v1 = _st;
vec2 v2 = _st;
vec2 v3 = _st;
float expon = pow(10.0, _zoom*2.0);
v1 /= 1.0*expon;
v2 /= 0.62*expon;
v3 /= 0.83*expon;
float n = time*_speed;
float nr = (simplexNoise(vec3(v1, n)) + simplexNoise(vec3(v2, n)) + simplexNoise(vec3(v3, n))) / 6.0 + 0.5;
n = time * _speed + 1000.0;
float ng = (simplexNoise(vec3(v1, n)) + simplexNoise(vec3(v2, n)) + simplexNoise(vec3(v3, n))) / 6.0 + 0.5;
return vec3(nr,ng,0.5);
}
VoroNoise
//	<https://www.shadertoy.com/view/Xd23Dh>
//	by inigo quilez <http://iquilezles.org/www/articles/voronoise/voronoise.htm>
//
vec3 hash3( vec2 p ){
vec3 q = vec3( dot(p,vec2(127.1,311.7)),
dot(p,vec2(269.5,183.3)),
dot(p,vec2(419.2,371.9)) );
return fract(sin(q)*43758.5453);
}
float iqnoise( in vec2 x, float u, float v ){
vec2 p = floor(x);
vec2 f = fract(x);
float k = 1.0+63.0*pow(1.0-v,4.0);
float va = 0.0;
float wt = 0.0;
for( int j=-2; j<=2; j++ )
for( int i=-2; i<=2; i++ )
{
vec2 g = vec2( float(i),float(j) );
vec3 o = hash3( p + g )*vec3(u,u,1.0);
vec2 r = g - f + o.xy;
float d = dot(r,r);
float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );
va += o.z*ww;
wt += ww;
}
return va/wt;
}
//	https://www.shadertoy.com/view/lsjGWD
//	by Pietro De Nicola
//
#define OCTAVES
1		// 7
#define SWITCH_TIME 	60.0		// seconds
float t = time/SWITCH_TIME;
float function 			= mod(t,4.0);
bool
multiply_by_F1	= mod(t,8.0)
>= 4.0;
bool
inverse				= mod(t,16.0) >= 8.0;
float distance_type	= mod(t/16.0,4.0);
vec2 hash( vec2 p ){
p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));
return fract(sin(p)*43758.5453);
}
float voronoi( in vec2 x ){
vec2 n = floor( x );
vec2 f = fract( x );
float F1 = 8.0;
float F2 = 8.0;
for( int j=-1; j<=1; j++ )
for( int i=-1; i<=1; i++ ){
vec2 g = vec2(i,j);
vec2 o = hash( n + g );
o = 0.5 + 0.41*sin( time + 6.2831*o );
vec2 r = g - f + o;
float d = 	distance_type < 1.0 ? dot(r,r)
:				// euclidean^2
distance_type < 2.0 ? sqrt(dot(r,r)) :			// euclidean
distance_type < 3.0 ? abs(r.x) + abs(r.y) :		// manhattan
distance_type < 4.0 ? max(abs(r.x), abs(r.y)) :	// chebyshev
0.0;
if( d<F1 ) {
F2 = F1;
F1 = d;
} else if( d<F2 ) {
F2 = d;
}
}
float c = function < 1.0 ? F1 :
function < 2.0 ? F2 :
function < 3.0 ? F2-F1 :
function < 4.0 ? (F1+F2)/2.0 :
0.0;
if( multiply_by_F1 )	c *= F1;
if( inverse )			c = 1.0 - c;
return c;
}
float fbm( in vec2 p ){
float s = 0.0;
float m = 0.0;
float a = 0.5;
for( int i=0; i<OCTAVES; i++ ){
s += a * voronoi(p);
m += a;
a *= 0.5;
p *= 2.0;
}
return s/m;
}
// Use:
//		vec2 p = gl_FragCoord.xy/iResolution.xx;
//
float c = POWER*fbm( SCALE*p ) + BIAS;
Fractional Brownian motion
#define NUM_OCTAVES 5
float fbm(float x) {
float v = 0.0;
float a = 0.5;
float shift = float(100);
for (int i = 0; i < NUM_OCTAVES; ++i) {
v += a * noise(x);
x = x * 2.0 + shift;
a *= 0.5;
}
return v;
}
float fbm(vec2 x) {
float v = 0.0;
float a = 0.5;
vec2 shift = vec2(100);
// Rotate to reduce axial bias
mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
for (int i = 0; i < NUM_OCTAVES; ++i) {
v += a * noise(x);
x = rot * x * 2.0 + shift;
a *= 0.5;
}
return v;
}
float fbm(vec3 x) {
float v = 0.0;
float a = 0.5;
vec3 shift = vec3(100);
for (int i = 0; i < NUM_OCTAVES; ++i) {
v += a * noise(x);
x = x * 2.0 + shift;
a *= 0.5;
}
return v;
}
// 	<https://www.shadertoy.com/view/MdX3Rr>
//	by inigo quilez
//
const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);
float fbm( in vec2 p ){
float f = 0.0;
f += 0.5000*noise( p ); p = m2*p*2.02;
f += 0.2500*noise( p ); p = m2*p*2.03;
f += 0.1250*noise( p ); p = m2*p*2.01;
f += 0.0625*noise( p );
return f/0.9375;
}
Articles:
Improving Noise, Ken Perlin http://mrl.nyu.edu/~perlin/paper445.pdf
Perlin Noise, Hugo Elias http://freespace.virgin.net/hugo.elias/models/m_perlin.htm
Implementation of Perlin Noise on GPU, Leena Kora http://www.sci.utah.edu/~leenak/IndStudy_reportfall/Perlin%20Noise%20on%20GPU.html
Implementing Improved Perlin Noise, Simon Green http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html
Perlin Noise http://mines.lumpylumpy.com/Electronics/Computers/Software/Cpp/Graphics/Bitmap/Textures/Noise/Perlin.php#.U7Fvs41dVhs
Simplex Noise http://mines.lumpylumpy.com/Electronics/Computers/Software/Cpp/Graphics/Bitmap/Textures/Noise/Simplex.php#.U7FwI41dVhs
Voronoise http://mines.lumpylumpy.com/Electronics/Computers/Software/Cpp/Graphics/Bitmap/Textures/Noise/Voronoi.php#.U7FwM41dVhs
Voronoise, inigo quilez http://iquilezles.org/www/articles/voronoise/voronoise.htm
Voronoi Noise, http://www.pixeleuphoria.com/node/34
Mosaic Noise http://mines.lumpylumpy.com/Electronics/Computers/Software/Cpp/Graphics/Bitmap/Textures/Noise/Mosaic.php#.U7FwZo1dVhs
Inigo Quilez http://iquilezles.org/www/articles/morenoise/morenoise.htm
Examples:
Andrew Baldwin http://thndl.com/?15
Load earlier comments...
Copy link
Author
patriciogonzalezvivo
commented
Feb 14, 2018
Better to grab them from here
http://thebookofshaders.com/10/
http://thebookofshaders.com/11/
http://thebookofshaders.com/12/
http://thebookofshaders.com/13/
They are better explained there ; )
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
lxsmnsyc
commented
Mar 7, 2019
in the top most noise (Generic Noise), the second noise function has a 2-D vector 'b' that is passed to the function 'rand' which only accepts float type. I think this is a mistake.
float rand(float n){return fract(sin(n) * 43758.5453123);}
float noise(vec2 n) {
const vec2 d = vec2(0.0, 1.0);
vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
akd-io
commented
Dec 14, 2019
Better to grab them from here
http://thebookofshaders.com/10/
http://thebookofshaders.com/11/
http://thebookofshaders.com/12/
http://thebookofshaders.com/13/
They are better explained there ; )
Thank you Patricio, those links were super helpful!
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
munrocket
commented
Jul 5, 2021
First and second noise literally the same. Second just refactored little bit and result are squared.
By the way, what license on noises that without the author?
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
Author
patriciogonzalezvivo
commented
Jul 5, 2021
Hi! This resource is very old/buggy and not with the right licenses. Please consider using this https://github.com/patriciogonzalezvivo/lygia/tree/main/generative
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
asforever
commented
Aug 19, 2021
Why the constant is 43758.5453123
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
ttmso
commented
Mar 31, 2023
this is why i hate everything:
32: vec4 permute(vec4 x){
^
error X3000: invalid target or usage string
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Mar 31, 2023
Your bug report is terse, and doesn't really give us much useful information. What is the context for the error?
(Also, saying that you "hate everything" might not be the best way of asking for help, but we are all intimately familiar with frustration, so no worries.)
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
Author
patriciogonzalezvivo
commented
Mar 31, 2023
Just a reminder that a more up to date version of this noise algorithms for GLSL/HLSL/WGSL/CUDA can be found
https://lygia.xyz/generative
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Mar 31, 2023
via email
Please fix the author and license information for "psrdnoise". The MIT
license is very permissive, but it's not public domain code. Both Ian and
myself kindly ask to be given proper credit both in your use of our code
and in further derivatives, which is the entire purpose of attaching the
MIT license to it.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
xorange
commented
Sep 21, 2023
Why the constant is 43758.5453123
@asforever interesting related topic: https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Sep 21, 2023
via email
That number has a bit pattern that is "good" for hashing. It's not a magic
number, many other numbers would work just as well, but you want a good,
non-regular but reasonably even mix of ones and zeroes.
Den tors 21 sep. 2023 08:42Oliver Xu ***@***.***> skrev:
…
***@***.**** commented on this gist.
------------------------------
Why the constant is 43758.5453123
@asforever <https://github.com/asforever> interesting related topic:
https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner
—
Reply to this email directly, view it on GitHub
<https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#gistcomment-4699127>
or unsubscribe
<https://github.com/notifications/unsubscribe-auth/AAFGK2QTC33RM2FK53GEIBDX3POUXBFKMF2HI4TJMJ2XIZLTSKBKK5TBNR2WLJDHNFZXJJDOMFWWLK3UNBZGKYLEL52HS4DFQKSXMYLMOVS2I5DSOVS2I3TBNVS3W5DIOJSWCZC7OBQXE5DJMNUXAYLOORPWCY3UNF3GS5DZVRZXKYTKMVRXIX3UPFYGLK2HNFZXIQ3PNVWWK3TUUZ2G64DJMNZZDAVEOR4XAZNEM5UXG5FFOZQWY5LFVAYTEOBSHEYTQMFHORZGSZ3HMVZKMY3SMVQXIZI>
.
You are receiving this email because you commented on the thread.
Triage notifications on the go with GitHub Mobile for iOS
<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
or Android
<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>
.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
xorange
commented
Sep 21, 2023
•
edited
Loading
Uh oh!
There was an error while loading. Please reload this page.
I would like to ask what is the intention of this common snippet?
float i = floor(x);
float f = fract(x);
float u = f * f * (3.0 - 2.0 * f); // ?
I've tried to plot this function, it seemed it does something similar to sigmoid in the range [0, 1]
f = 0.5, u = 0.5
f = 0.99, u = 0.999702
What's so special about it ? or What's so special about values near 0. or 1. that we have to push them nearer towards the bound ?
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Sep 21, 2023
via email
That is the "Hermite" interpolation polynomial, the "smoothstep" function
to blend between two values as the fractional part goes from 0 to 1.
Den tors 21 sep. 2023 11:57Oliver Xu ***@***.***> skrev:
…
***@***.**** commented on this gist.
------------------------------
I would like to ask what is the intention of this common snippet?
float i = floor(x);
float f = fract(x);
float u = f * f * (3.0 - 2.0 * f);
—
Reply to this email directly, view it on GitHub
<https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#gistcomment-4699339>
or unsubscribe
<https://github.com/notifications/unsubscribe-auth/AAFGK2R2X3GCMYZ2TYRZC7DX3QFPNBFKMF2HI4TJMJ2XIZLTSKBKK5TBNR2WLJDHNFZXJJDOMFWWLK3UNBZGKYLEL52HS4DFQKSXMYLMOVS2I5DSOVS2I3TBNVS3W5DIOJSWCZC7OBQXE5DJMNUXAYLOORPWCY3UNF3GS5DZVRZXKYTKMVRXIX3UPFYGLK2HNFZXIQ3PNVWWK3TUUZ2G64DJMNZZDAVEOR4XAZNEM5UXG5FFOZQWY5LFVAYTEOBSHEYTQMFHORZGSZ3HMVZKMY3SMVQXIZI>
.
You are receiving this email because you commented on the thread.
Triage notifications on the go with GitHub Mobile for iOS
<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
or Android
<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>
.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
ghost
commented
Feb 5, 2024
people have been complaining about licenses since 2016, not a single generic "thank you" so far
thanks for your noise dude!
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Feb 5, 2024
The reason I have been complaining about the improper removal of the license information from the simplex noise code is that the MIT license is very permissive, "please give credit", and still it was taken off. I do take issue with that.
For a more modern version with more features, look for "psrdnoise" on Github, also by me and Ian McEwan. And please respect the license. It's just a matter of not deleting a comment, and then you can do whatever you want with the code.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
roa-nyx
commented
May 21, 2024
I ported this into Godot for my own use, but I'm not sure if I screwed something up.
I naively assumed that the output range for snoise(vec3) would be [0..1), but it seems like it's not in my own testing:
star = snoisev3(EYEDIR*3.);
if(star > 0.)
star = 0.;
else if (star < 0.)
star = 1.;
COLOR = vec3(star);
Playing with the threshold values in my code I manage to get white blobs. What is the output range for simplex noise supposed to be? Further experimentation seems to put it in the range of roughly (-1.04,1.04)...
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
ghost
commented
May 21, 2024
I ported this into Godot for my own use, but I'm not sure if I screwed something up.
I naively assumed that the output range for snoise(vec3) would be [0..1), but it seems like it's not in my own testing:
star = snoisev3(EYEDIR*3.);
if(star > 0.)
star = 0.;
else if (star < 0.)
star = 1.;
COLOR = vec3(star);
Playing with the threshold values in my code I manage to get white blobs. What is the output range for simplex noise supposed to be? Further experimentation seems to put it in the range of roughly (-1.04,1.04)...
I guess we could just remap it to [0..1]
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
May 23, 2024
via email
The range, as with all raw functions similar to Perlin noise, is supposed
to be [-1, 1] with a zero mean, but the scaling seems to be off,
considering you found 1.04 and -1.04. I thought I tested it in the entire
domain both in 2D and 3D, but apparently I missed a loval extreme
somewhere. (The 4D version is not tested in the entire domain, I just
sampled that randomly.)
Den tis 21 maj 2024 12:12Eyad Ahmed ***@***.***> skrev:
…
***@***.**** commented on this gist.
------------------------------
I ported this into Godot for my own use, but I'm not sure if I screwed
something up.
I naively assumed that the output range for snoise(vec3) would be [0..1),
but it seems like it's not in my own testing:
star = snoisev3(EYEDIR*3.);
if(star > 0.)
star = 0.;
else if (star < 0.)
star = 1.;
COLOR = vec3(star);
Playing with the threshold values in my code I manage to get white blobs.
What is the output range for simplex noise supposed to be? Further
experimentation seems to put it in the range of roughly (-1.04,1.04)...
I guess we could just remap it to [0..1]
—
Reply to this email directly, view it on GitHub
<https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#gistcomment-5064048>
or unsubscribe
<https://github.com/notifications/unsubscribe-auth/AAFGK2QVIPMTQOR2YXJVSI3ZDMMYJBFKMF2HI4TJMJ2XIZLTSKBKK5TBNR2WLJDUOJ2WLJDOMFWWLO3UNBZGKYLEL5YGC4TUNFRWS4DBNZ2F6YLDORUXM2LUPGBKK5TBNR2WLJDHNFZXJJDOMFWWLK3UNBZGKYLEL52HS4DFVRZXKYTKMVRXIX3UPFYGLK2HNFZXIQ3PNVWWK3TUUZ2G64DJMNZZDAVEOR4XAZNEM5UXG5FFOZQWY5LFVAYTEOBSHEYTQMFHORZGSZ3HMVZKMY3SMVQXIZI>
.
You are receiving this email because you commented on the thread.
Triage notifications on the go with GitHub Mobile for iOS
<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
or Android
<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>
.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
May 23, 2024
via email
Nit pick, because I teach this stuff: your example code is inefficient in
that it has two "if" tests with different conditions rather than an if-else
on the same condition. This pattern is also the typical use case for the
"step" function in most shading languages. Instead of the "if" with two
conditional assignments you just do "output = step(0.0, noisevalue)", which
basically maps to a single machine instruction.
Your code also excludes the case star==0 from making any of the two
conditional assignments, which makes is extra difficult for the compiler to
optimize.
Shader code is still time critical to the point where you might want to
care about this kind of usually unimportant details.
I will shut up now. Force of habit, sorry...
Den tis 21 maj 2024 07:25roa-nyx ***@***.***> skrev:
…
***@***.**** commented on this gist.
------------------------------
I ported this into Godot for my own use, but I'm not sure if I screwed
something up.
I naively assumed that the output range for snoise(vec3) would be [0..1),
but it seems like it's not in my own testing:
star = snoisev3(EYEDIR*3.);
if(star > 0.)
star = 0.;
else if (star < 0.)
star = 1.;
COLOR = vec3(star);
Playing with the threshold values in my code I manage to get white blobs.
What is the output range for simplex noise supposed to be? Further
experimentation seems to put it in the range of roughly (-1.04,1.04)...
—
Reply to this email directly, view it on GitHub
<https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#gistcomment-5063804>
or unsubscribe
<https://github.com/notifications/unsubscribe-auth/AAFGK2VIRBVGSMJPRINUTKDZDLLFFBFKMF2HI4TJMJ2XIZLTSKBKK5TBNR2WLJDUOJ2WLJDOMFWWLO3UNBZGKYLEL5YGC4TUNFRWS4DBNZ2F6YLDORUXM2LUPGBKK5TBNR2WLJDHNFZXJJDOMFWWLK3UNBZGKYLEL52HS4DFVRZXKYTKMVRXIX3UPFYGLK2HNFZXIQ3PNVWWK3TUUZ2G64DJMNZZDAVEOR4XAZNEM5UXG5FFOZQWY5LFVAYTEOBSHEYTQMFHORZGSZ3HMVZKMY3SMVQXIZI>
.
You are receiving this email because you commented on the thread.
Triage notifications on the go with GitHub Mobile for iOS
<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
or Android
<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>
.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
tripdragon
commented
Jan 31, 2025
what a fun read, to this day there remains no DIAMOND standard set of files even from aiiiiii, lygia looks to be good but its an install the whole repo thing. Anyhoo
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Jan 31, 2025
The reason there is no diamond standard is that there is no way to make everyone happy. Different versions of noise solve different problems. I try to keep my functions clean and generic, while others optimize for a certain platform or aim for speed at the expense of quality. And others want to roll their own code to learn. We are all different.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
tripdragon
commented
Jan 31, 2025
and yet the task goal is very similar, make noise, do stuff with output. But getting there even just loading the code can be wildly more complex. Pre-compilers needed, or translations to other langs.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Feb 1, 2025
via email
I know, believe me...
For this reason, my GLSL noise functions are all self-contained, just cut
and paste and call the function. I don't like dependencies.
Den fre 31 jan. 2025 21:51tripdragon ***@***.***> skrev:
…
***@***.**** commented on this gist.
------------------------------
and yet the task goal is very similar, make noise, do stuff with output.
But getting there even just loading the code can be wildly more complex.
Pre-compilers needed, or translations to other langs.
—
Reply to this email directly, view it on GitHub
<https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#gistcomment-5417494>
or unsubscribe
<https://github.com/notifications/unsubscribe-auth/AAFGK2VCYCSAPBOR4FGWTID2NPO6PBFKMF2HI4TJMJ2XIZLTSKBKK5TBNR2WLJDUOJ2WLJDOMFWWLO3UNBZGKYLEL5YGC4TUNFRWS4DBNZ2F6YLDORUXM2LUPGBKK5TBNR2WLJDHNFZXJJDOMFWWLK3UNBZGKYLEL52HS4DFVRZXKYTKMVRXIX3UPFYGLK2HNFZXIQ3PNVWWK3TUUZ2G64DJMNZZDAVEOR4XAZNEM5UXG5FFOZQWY5LFVAYTEOBSHEYTQMFHORZGSZ3HMVZKMY3SMVQXIZI>
.
You are receiving this email because you commented on the thread.
Triage notifications on the go with GitHub Mobile for iOS
<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
or Android
<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>
.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
Author
patriciogonzalezvivo
commented
Feb 1, 2025
Just as a note. You can retrieve the files from the server which will resolve the dependencies for you:
https://lygia.xyz/generative/snoise.glsl
https://lygia.xyz/generative/cnoise.glsl
https://lygia.xyz/generative/pnoise.glsl
https://lygia.xyz/generative/voronoise.glsl
... etc with every file on the generative folder https://lygia.xyz/generative/
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
tripdragon
commented
Feb 11, 2025
interesting! I did though get the thing building with vite and the includes plugin. So it solves the dilemma for now. Once I have solid settings from tweaking a vert frag shaders I dump that into template strings into the js file for three so I cant break stuff. A messy workflow but a bit more future proof.
Just to rant, we still dont have function naming standards and never will 100 years from now example Vec4 Float4 lerp blend mix, props order, and so on, which makes visual noodle nodes tools impossible to have a solid exchange format. Also gltf wont have custom shader support
anyhooo!
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
Unfinished632
commented
Feb 24, 2025
How can i implement seeds in 3D simplex noise? I looked around everywhere and it seems like it depends on the implementation so im lost.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
stegu
commented
Feb 27, 2025
via email
You can just send an integer to the function and add it to thw coordinates
for every hash you make. If you add the seed at the start of the hash, you
will only do the equivalent of a translation of the coordinates, but you
can add it before the second and/or third step instead. This assumes that
you perform the hashing as hash(hash(hash(x)+y)+z), which is what most
implementations do.
Den mån 24 feb. 2025 20:12Unfinished_ ***@***.***> skrev:
…
***@***.**** commented on this gist.
------------------------------
How can i implement seeds in 3D simplex noise? I looked around everywhere
and it seems like it depends on the implementation so im lost.
—
Reply to this email directly, view it on GitHub
<https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#gistcomment-5455320>
or unsubscribe
<https://github.com/notifications/unsubscribe-auth/AAFGK2QTXKT7XJV7F4JULQL2RNVLVBFKMF2HI4TJMJ2XIZLTSKBKK5TBNR2WLJDUOJ2WLJDOMFWWLO3UNBZGKYLEL5YGC4TUNFRWS4DBNZ2F6YLDORUXM2LUPGBKK5TBNR2WLJDHNFZXJJDOMFWWLK3UNBZGKYLEL52HS4DFVRZXKYTKMVRXIX3UPFYGLK2HNFZXIQ3PNVWWK3TUUZ2G64DJMNZZDAVEOR4XAZNEM5UXG5FFOZQWY5LFVAYTEOBSHEYTQMFHORZGSZ3HMVZKMY3SMVQXIZI>
.
You are receiving this email because you commented on the thread.
Triage notifications on the go with GitHub Mobile for iOS
<https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
or Android
<https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>
.
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
Unfinished632
commented
Feb 28, 2025
Thanks! This'll help me a lot
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Copy link
Rubiidev-IPad
commented
Mar 4, 2025
claude 3.7 actually credited you for this
Sorry, something went wrong.
Uh oh!
There was an error while loading. Please reload this page.
Sign up for free
to join this conversation on GitHub.
Already have an account?
Sign in to comment
Footer
© 2025 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Community
Docs
Contact
Manage cookies
Do not share my personal information
You can’t perform that action at this time.