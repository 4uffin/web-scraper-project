GitHub - fmtlib/fmt: A modern formatting library
Skip to content
Navigation Menu
Toggle navigation
Sign in
Appearance settings
Platform
GitHub Copilot
Write better code with AI
GitHub Spark
New
Build and deploy intelligent apps
GitHub Models
New
Manage and compare prompts
GitHub Advanced Security
Find and fix vulnerabilities
Actions
Automate any workflow
Codespaces
Instant dev environments
Issues
Plan and track work
Code Review
Manage code changes
Discussions
Collaborate outside of code
Code Search
Find more, search less
Explore
Why GitHub
Documentation
GitHub Skills
Blog
Integrations
GitHub Marketplace
MCP Registry
View all features
Solutions
By company size
Enterprises
Small and medium teams
Startups
Nonprofits
By use case
App Modernization
DevSecOps
DevOps
CI/CD
View all use cases
By industry
Healthcare
Financial services
Manufacturing
Government
View all industries
View all solutions
Resources
Topics
AI
DevOps
Security
Software Development
View all
Explore
Learning Pathways
Events & Webinars
Ebooks & Whitepapers
Customer Stories
Partners
Executive Insights
Open Source
GitHub Sponsors
Fund open source developers
The ReadME Project
GitHub community articles
Repositories
Topics
Trending
Collections
Enterprise
Enterprise platform
AI-powered developer platform
Available add-ons
GitHub Advanced Security
Enterprise-grade security features
Copilot for business
Enterprise-grade AI features
Premium Support
Enterprise-grade 24/7 support
Pricing
Search or jump to...
Search code, repositories, users, issues, pull requests...
Search
Clear
Search syntax tips
Provide feedback
We read every piece of feedback, and take your input very seriously.
Include my email address so I can be contacted
Cancel
Submit feedback
Saved searches
Use saved searches to filter your results more quickly
Name
Query
To see all available qualifiers, see our documentation.
Cancel
Create saved search
Sign in
Sign up
Appearance settings
Resetting focus
You signed in with another tab or window. Reload to refresh your session.
You signed out in another tab or window. Reload to refresh your session.
You switched accounts on another tab or window. Reload to refresh your session.
Dismiss alert
fmtlib
/
fmt
Public
Notifications
You must be signed in to change notification settings
Fork
2.7k
Star
22.6k
A modern formatting library
fmt.dev
License
View license
22.6k
stars
2.7k
forks
Branches
Tags
Activity
Star
Notifications
You must be signed in to change notification settings
Code
Issues
14
Pull requests
0
Actions
Projects
0
Security
Uh oh!
There was an error while loading. Please reload this page.
Insights
Additional navigation options
Code
Issues
Pull requests
Actions
Projects
Security
Insights
fmtlib/fmt
masterBranchesTagsGo to fileCodeOpen more actions menuFolders and filesNameNameLast commit messageLast commit dateLatest commit¬†History7,634 Commits.github.github¬†¬†docdoc¬†¬†include/fmtinclude/fmt¬†¬†srcsrc¬†¬†supportsupport¬†¬†testtest¬†¬†.clang-format.clang-format¬†¬†.clang-tidy.clang-tidy¬†¬†.gitignore.gitignore¬†¬†CMakeLists.txtCMakeLists.txt¬†¬†CONTRIBUTING.mdCONTRIBUTING.md¬†¬†ChangeLog.mdChangeLog.md¬†¬†LICENSELICENSE¬†¬†README.mdREADME.md¬†¬†View all filesRepository files navigationREADMEContributingLicense
{fmt} is an open-source formatting library providing a fast and safe
alternative to C stdio and C++ iostreams.
If you like this project, please consider donating to one of the funds
that help victims of the war in Ukraine: https://www.stopputin.net/.
Documentation
Cheat Sheets
Q&A: ask questions on StackOverflow with the tag
fmt.
Try {fmt} in Compiler Explorer.
Features
Simple format API with positional
arguments for localization
Implementation of C++20
std::format and
C++23 std::print
Format string syntax similar
to Python's
format
Fast IEEE 754 floating-point formatter with correct rounding,
shortness and round-trip guarantees using the
Dragonbox algorithm
Portable Unicode support
Safe printf
implementation
including the POSIX extension for positional arguments
Extensibility: support for user-defined
types
High performance: faster than common standard library
implementations of (s)printf, iostreams, to_string and
to_chars, see Speed tests and Converting a
hundred million integers to strings per
second
Small code size both in terms of source code with the minimum
configuration consisting of just three files, base.h, format.h
and format-inl.h, and compiled code; see Compile time and code
bloat
Reliability: the library has an extensive set of
tests and is
continuously fuzzed
Safety: the library is fully type-safe, errors in format strings can
be reported at compile time, automatic memory management prevents
buffer overflow errors
Ease of use: small self-contained code base, no external
dependencies, permissive MIT
license
Portability with
consistent output across platforms and support for older compilers
Clean warning-free codebase even on high warning levels such as
-Wall -Wextra -pedantic
Locale independence by default
Optional header-only configuration enabled with the
FMT_HEADER_ONLY macro
See the documentation for more details.
Examples
Print to stdout (run)
#include <fmt/base.h>
int main() {
fmt::print("Hello, world!\n");
}
Format a string (run)
std::string s = fmt::format("The answer is {}.", 42);
// s == "The answer is 42."
Format a string using positional arguments
(run)
std::string s = fmt::format("I'd rather be {1} than {0}.", "right", "happy");
// s == "I'd rather be happy than right."
Print dates and times (run)
#include <fmt/chrono.h>
int main() {
auto now = std::chrono::system_clock::now();
fmt::print("Date and time: {}\n", now);
fmt::print("Time: {:%H:%M}\n", now);
}
Output:
Date and time: 2023-12-26 19:10:31.557195597
Time: 19:10
Print a container (run)
#include <vector>
#include <fmt/ranges.h>
int main() {
std::vector<int> v = {1, 2, 3};
fmt::print("{}\n", v);
}
Output:
[1, 2, 3]
Check a format string at compile time
std::string s = fmt::format("{:d}", "I am not a number");
This gives a compile-time error in C++20 because d is an invalid
format specifier for a string.
Write a file from a single thread
#include <fmt/os.h>
int main() {
auto out = fmt::output_file("guide.txt");
out.print("Don't {}", "Panic");
}
This can be 5 to 9 times faster than
fprintf.
Print with colors and text styles
#include <fmt/color.h>
int main() {
fmt::print(fg(fmt::color::crimson) | fmt::emphasis::bold,
"Hello, {}!\n", "world");
fmt::print(fg(fmt::color::floral_white) | bg(fmt::color::slate_gray) |
fmt::emphasis::underline, "Ol√°, {}!\n", "Mundo");
fmt::print(fg(fmt::color::steel_blue) | fmt::emphasis::italic,
"‰Ω†Â•Ω{}ÔºÅ\n", "‰∏ñÁïå");
}
Output on a modern terminal with Unicode support:
Benchmarks
Speed tests
Library
Method
Run Time, s
libc
printf
0.91
libc++
std::ostream
2.49
{fmt} 9.1
fmt::print
0.74
Boost Format 1.80
boost::format
6.26
Folly Format
folly::format
1.87
{fmt} is the fastest of the benchmarked methods, ~20% faster than
printf.
The above results were generated by building tinyformat_test.cpp on
macOS 12.6.1 with clang++ -O3 -DNDEBUG -DSPEED_TEST -DHAVE_FORMAT, and
taking the best of three runs. In the test, the format string
"%0.10f:%04d:%+g:%s:%p:%c:%%\n" or equivalent is filled 2,000,000
times with output sent to /dev/null; for further details refer to the
source.
{fmt} is up to 20-30x faster than std::ostringstream and sprintf on
IEEE754 float and double formatting
(dtoa-benchmark) and faster
than double-conversion
and ryu:
Compile time and code bloat
The script bloat-test.py from format-benchmark tests compile
time and code bloat for nontrivial projects. It generates 100 translation units
and uses printf() or its alternative five times in each to simulate a
medium-sized project. The resulting executable size and compile time (Apple
clang version 15.0.0 (clang-1500.1.0.2.5), macOS Sonoma, best of three) is shown
in the following tables.
Optimized build (-O3)
Method
Compile Time, s
Executable size, KiB
Stripped size, KiB
printf
1.6
54
50
IOStreams
25.9
98
84
fmt 83652df
4.8
54
50
tinyformat
29.1
161
136
Boost Format
55.0
530
317
{fmt} is fast to compile and is comparable to printf in terms of per-call
binary size (within a rounding error on this system).
Non-optimized build
Method
Compile Time, s
Executable size, KiB
Stripped size, KiB
printf
1.4
54
50
IOStreams
23.4
92
68
{fmt} 83652df
4.4
89
85
tinyformat
24.5
204
161
Boost Format
36.4
831
462
libc, lib(std)c++, and libfmt are all linked as shared libraries
to compare formatting function overhead only. Boost Format is a
header-only library so it doesn't provide any linkage options.
Running the tests
Please refer to Building the
library for
instructions on how to build the library and run the unit tests.
Benchmarks reside in a separate repository,
format-benchmarks, so to
run the benchmarks you first need to clone this repository and generate
Makefiles with CMake:
$ git clone --recursive https://github.com/fmtlib/format-benchmark.git
$ cd format-benchmark
$ cmake .
Then you can run the speed test:
$ make speed-test
or the bloat test:
$ make bloat-test
Migrating code
clang-tidy v18 provides the
modernize-use-std-print
check that is capable of converting occurrences of printf and
fprintf to fmt::print if configured to do so. (By default it
converts to std::print.)
Notable projects using this library
0 A.D.: a free, open-source, cross-platform
real-time strategy game
AMPL/MP: an open-source library for
mathematical programming
Apple's FoundationDB: an open-source,
distributed, transactional key-value store
Aseprite: animated sprite
editor & pixel art tool
AvioBook: a comprehensive aircraft
operations suite
Blizzard Battle.net: an online gaming
platform
Celestia: real-time 3D visualization of
space
Ceph: a scalable distributed storage system
ccache: a compiler cache
ClickHouse: an
analytical database management system
ContextVision: medical imaging software
Contour: a modern
terminal emulator
CUAUV: Cornell University's autonomous
underwater vehicle
Drake: a planning, control, and analysis
toolbox for nonlinear dynamical systems (MIT)
Envoy: C++ L7 proxy and
communication bus (Lyft)
FiveM: a modification framework for GTA V
fmtlog: a performant
fmtlib-style logging library with latency in nanoseconds
Folly: Facebook open-source
library
GemRB: a portable open-source implementation
of Bioware's Infinity Engine
Grand Mountain
Adventure:
a beautiful open-world ski & snowboarding game
HarpyWar/pvpgn: Player vs
Player Gaming Network with tweaks
KBEngine: an open-source
MMOG server engine
Keypirinha: a semantic launcher for
Windows
Kodi (formerly xbmc): home theater software
Knuth: high-performance Bitcoin full-node
libunicode: a
modern C++17 Unicode library
MariaDB: relational database management
system
Microsoft Verona: research
programming language for concurrent ownership
MongoDB: distributed document database
MongoDB Smasher: a small
tool to generate randomized datasets
OpenSpace: an open-source
astrovisualization framework
PenUltima Online (POL): an MMO server,
compatible with most Ultima Online clients
PyTorch: an open-source
machine learning library
quasardb: a distributed,
high-performance, associative database
Quill: asynchronous low-latency
logging library
QKW: generalizing aliasing to
simplify navigation, and execute complex multi-line terminal
command sequences
redis-cerberus: a Redis
cluster proxy
redpanda: a 10x faster Kafka¬Æ
replacement for mission-critical systems written in C++
rpclib: a modern C++ msgpack-RPC server and
client library
Salesforce Analytics
Cloud:
business intelligence software
Scylla: a Cassandra-compatible NoSQL
data store that can handle 1 million transactions per second on a
single server
Seastar: an advanced, open-source
C++ framework for high-performance server applications on modern
hardware
spdlog: super fast C++ logging
library
Stellar: financial platform
Touch Surgery: surgery simulator
TrinityCore:
open-source MMORPG framework
üêô userver framework: open-source
asynchronous framework with a rich set of abstractions and database
drivers
Windows Terminal: the new
Windows terminal
More...
If you are aware of other projects using this library, please let me
know by email or by submitting an
issue.
Motivation
So why yet another formatting library?
There are plenty of methods for doing this task, from standard ones like
the printf family of function and iostreams to Boost Format and
FastFormat libraries. The reason for creating a new library is that
every existing solution that I found either had serious issues or
didn't provide all the features I needed.
printf
The good thing about printf is that it is pretty fast and readily
available being a part of the C standard library. The main drawback is
that it doesn't support user-defined types. printf also has safety
issues although they are somewhat mitigated with __attribute__
((format (printf,
...)) in
GCC. There is a POSIX extension that adds positional arguments required
for
i18n
to printf but it is not a part of C99 and may not be available on some
platforms.
iostreams
The main issue with iostreams is best illustrated with an example:
std::cout << std::setprecision(2) << std::fixed << 1.23456 << "\n";
which is a lot of typing compared to printf:
printf("%.2f\n", 1.23456);
Matthew Wilson, the author of FastFormat, called this "chevron hell".
iostreams don't support positional arguments by design.
The good part is that iostreams support user-defined types and are safe
although error handling is awkward.
Boost Format
This is a very powerful library that supports both printf-like format
strings and positional arguments. Its main drawback is performance.
According to various benchmarks, it is much slower than other methods
considered here. Boost Format also has excessive build times and severe
code bloat issues (see Benchmarks).
FastFormat
This is an interesting library that is fast, safe and has positional
arguments. However, it has significant limitations, citing its author:
Three features that have no hope of being accommodated within the
current design are:
Leading zeros (or any other non-space padding)
Octal/hexadecimal encoding
Runtime width/alignment specification
It is also quite big and has a heavy dependency, on STLSoft, which might be
too restrictive for use in some projects.
Boost Spirit.Karma
This is not a formatting library but I decided to include it here for
completeness. As iostreams, it suffers from the problem of mixing
verbatim text with arguments. The library is pretty fast, but slower on
integer formatting than fmt::format_to with format string compilation
on Karma's own benchmark, see Converting a hundred million integers to
strings per
second.
License
{fmt} is distributed under the MIT
license.
Documentation License
The Format String Syntax section
in the documentation is based on the one from Python string module
documentation.
For this reason, the documentation is distributed under the Python
Software Foundation license available in
doc/python-license.txt.
It only applies if you distribute the documentation of {fmt}.
Maintainers
The {fmt} library is maintained by Victor Zverovich
(vitaut) with contributions from many other
people. See
Contributors and
Releases for some of the
names. Let us know if your contribution is not listed or mentioned
incorrectly and we'll make it right.
Security Policy
To report a security issue, please disclose it at security
advisory.
This project is maintained by a team of volunteers on a
reasonable-effort basis. As such, please give us at least 90 days to
work on a fix before public exposure.
About
A modern formatting library
fmt.dev
Topics
c-plus-plus
unicode
performance
cross-platform
cpp
formatting
printf
output
multiplatform
floating-point
ranges
chrono
Resources
Readme
License
View license
Contributing
Contributing
Uh oh!
There was an error while loading. Please reload this page.
Activity
Custom properties
Stars
22.6k
stars
Watchers
325
watching
Forks
2.7k
forks
Report repository
Releases
56
12.0.0
Latest
Sep 17, 2025
+ 55 releases
Uh oh!
There was an error while loading. Please reload this page.
Contributors
525
+ 511 contributors
Languages
C++
96.3%
Python
1.9%
CMake
1.7%
Shell
0.1%
Cuda
0.0%
Makefile
0.0%
Footer
¬© 2025 GitHub,¬†Inc.
Footer navigation
Terms
Privacy
Security
Status
Community
Docs
Contact
Manage cookies
Do not share my personal information
You can‚Äôt perform that action at this time.