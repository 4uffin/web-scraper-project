CSS Selectors | CSS-Tricks
Skip to main content
CSS-Tricks
Articles
Notes
Links
Guides
Almanac
Picks
Shuffle
Search
Home /
Guides /
CSS Selectors
Geoff Graham
on
May 2, 2025
A complete guide covering all of the various methods we have to select elements in CSS and how to use them for applying styles.
Brought to you by DigitalOcean
DigitalOcean has the cloud computing services you need to support your growth at any stage. Get started with a free $200 credit!
Overview
CSS is really good at many things, but it‚Äôs really, really good at two specific things: selecting elements and styling them. That‚Äôs the raison d‚Äô√™tre for CSS and why it‚Äôs a core web language. In this guide, we will cover the different ways to select elements ‚Äî because the styles we write are pretty much useless without the ability to select which elements to apply them to.
The source of truth for CSS selectors is documented in the Selectors Module Level 4 specification. With one exception (which we‚Äôll get to), all of the selectors covered here are well-covered by browsers across the board, and most certainly by all modern browsers.
In addition to selectors, this guide also looks at CSS combinators. If selectors identify what we are selecting, you might think of combinators as how the styles are applied. Combinators are like additional instructions we give CSS to select a very particular element on the page, not totally unlike the way we can use filters in search engines to find the exact result we want.
Quick reference
Common Selectors
/* Universal */
* {
box-sizing: border-box;
}
/* Type or Tag */
p {
margin-block: 1.5rem;
}
/* Classname */
.class {
text-decoration: underline;
}
/* ID */
#id {
font-family: monospace;
}
/* Relational */
li:has(a) {
display: flex;
}
Common Combinators
/* Descendant */
header h1 {
/* Selects all Heading 1 elements in a Header element. */
}
/* Child */
header > h1 {
/* Selects all Heading 1 elements that are children of Header elements. */
}
/* General sibling */
h1 ~ p {
/* Selects a Paragraph as long as it follows a Heading 1. */
}
/* Adjacent sibling */
h1 + p {
/* Selects a Paragraph if it immediately follows a Heading 1 */
}
/* Chained */
h1, p {
/* Selects both elements. */
}
General Selectors
When we talk about CSS selectors, we‚Äôre talking about the first part of a CSS ruleset:
/* CSS Ruleset */
selector {
/* Style rule */
property: value;
}
See that selector? That can be as simple as the HTML tag we want to select. For example, let‚Äôs select all <article> elements on a given page.
/* Select all <article> elements... */
article {
/* ... and apply this background-color on them */
background-color: hsl(25 100% 50%);
}
That‚Äôs the general process of selecting elements to apply styles to them. Selecting an element by its HTML tag is merely one selector type of several. Let‚Äôs see what those are in the following section.
Element selectors
Element selectors are exactly the type of selector we looked at in that last example: Select the element‚Äôs HTML tag and start styling!
That‚Äôs great and all, but consider this: Do you actually want to select all of the <article> elements on the page? That‚Äôs what we‚Äôre doing when we select an element by its tag ‚Äî any and all HTML elements matching that tag get the styles. The following demo selects all <article> elements on the page, then applies a white (#fff) background to them. Notice how all three articles get the white background even though we only wrote one selector.
CodePen Embed Fallback
I‚Äôve tried to make it so the relevant for code for this and other demos in this guide is provided at the top of the CSS tab. Anything in a @layer can be ignored. And if you‚Äôre new to @layer, you can learn all about it in our CSS Cascade Layers guide.
But maybe what we actually want is for the first element to have a different background ‚Äî maybe it‚Äôs a featured piece of content and we need to make it stand out from the other articles. That requires us to be more specific in the type of selector we use to apply the styles.
Let‚Äôs turn our attention to other selector types that allow us to be more specific about what we‚Äôre selecting.
ID selectors
ID selectors are one way we can select one element without selecting another of the same element type. Let‚Äôs say we were to update the HTML in our <article> example so that the first article is ‚Äútagged‚Äù with an ID:
<article id="featured">
<!-- Article 1 -->
</article>
<article>
<!-- Article 2 -->
</article>
<article>
<!-- Article 3 -->
</article>
Now we can use that ID to differentiate that first article from the others and apply styles specifically to it. We prepend a hashtag character (#) to the ID name when writing our CSS selector to properly select it.
/* Selects all <article> elements */
article {
background: #fff;
}
/* Selects any element with id="featured" */
#featured {
background: hsl(35 100% 90%);
border-color: hsl(35 100% 50%);
}
There we go, that makes the first article pop a little more than the others!
CodePen Embed Fallback
Before you go running out and adding IDs all over your HTML, be aware that IDs are considered a heavy-handed approach to selecting. IDs are so specific, that it is tough to override them with other styles in your CSS. IDs have so much specificity power than any selector trying to override it needs at least an ID as well. Once you‚Äôve reached near the top of the ladder of this specificity war, it tends to lead to using !important rules and such that are in turn nearly impossible to override.
Let‚Äôs rearrange our CSS from that last example to see that in action:
/* Selects any element with id="featured" */
#featured {
background: hsl(35 100% 90%);
border-color: hsl(35 100% 50%);
}
/* Selects all <article> elements */
article {
background: #fff;
}
The ID selector now comes before the element selector. According to how the CSS Cascade determines styles, you might expect that the article elements all get a white background since that ruleset comes after the ID selector ruleset. But that‚Äôs not what happens.
CodePen Embed Fallback
So, you see how IDs might be a little too ‚Äúspecific‚Äù when it comes to selecting elements because it affects the order in which the CSS Cascade applies styles and that makes styles more difficult to manage and maintain.
The other reason to avoid IDs as selectors? We‚Äôre technically only allowed to use an ID once on a page, per ID. In other words, we can have one element with #featured but not two. That severely limits what we‚Äôre able to style if we need to extend those styles to other elements ‚Äî not even getting into the difficulty of overriding the ID‚Äôs styles.
A better use case for IDs is for selecting items in JavaScript ‚Äî not only does that prevent the sort of style conflict we saw above, but it helps maintain a separation of concerns between what we select in CSS for styling versus what we select in JavaScript for interaction.
Another thing about ID selectors: The ID establishes what we call an ‚Äúanchor‚Äù which is a fancy term for saying we can link directly to an element on the page. For example, if we have an article with an ID assigned to it:
<article id="featured">...</article>
‚Ä¶then we can create a link to it like this:
<a href="featured">Jump to article below ‚¨áÔ∏è</a>
<!-- muuuuuuch further down the page. -->
<article id="featured">...</article>
Clicking the link will navigate you to the element as though the link is anchored to that element. Try doing exactly that in the following demo:
CodePen Embed Fallback
This little HTML goodie opens up some pretty darn interesting possibilities when we sprinkle in a little CSS. Here are a few articles to explore those possibilities.
Class selectors
Class selectors might be the most commonly used type of CSS selector you will see around the web. Classes are ideal because they are slightly more specific than element selectors but without the heavy-handedness of IDs. You can read a deep explanation of how the CSS Cascade determines specificity, but the following is an abbreviated illustration focusing specifically (get it?!) on the selector types we‚Äôve looked at so far.
That‚Äôs what makes class selectors so popular ‚Äî they‚Äôre only slightly more specific than elements, but keep specificity low enough to be manageable if we need to override the styles in one ruleset with styles in another.
The only difference when writing a class is that we prepend a period (.) in front of the class name instead of the hashtag (#).
/* Selects all <article> elements */
article {
background: #fff;
}
/* Selects any element with class="featured" */
.featured {
background: hsl(35 100% 90%);
border-color: hsl(35 100% 50%);
}
Here‚Äôs how our <article> example shapes up when we swap out #featured with .featured.
CodePen Embed Fallback
Same result, better specificity. And, yes, we can absolutely combine different selector types on the same element:
<article id="someID" class="featured">...</article>
Do you see all of the possibilities we have to select an <article>? We can select it by:
Its element type (article)
Its ID (#someID)
Its class (.featured)
The following articles will give you some clever ideas for using class selectors in CSS.
But we have even more ways to select elements like this, so let‚Äôs continue.
Attribute selectors
ID and class selectors technically fall into this attribute selectors category. We call them ‚Äúattributes‚Äù because they are present in the HTML and give more context about the element. All of the following are attributes in HTML:
<!-- ID, Class, Data Attribute -->
<article id="#id" class=".class" data-attribute="attribute">
</article>
<!-- href, Title, Target -->
<a href="https://css-tricks.com" title="Visit CSS-Tricks" target="_blank"></a>
<!-- src, Width, Height, Loading -->
<img src="star.svg" width="250" height="250" loading="laxy" >
<!-- Type, ID, Name, Checked -->
<input type="checkbox" id="consent" name="consent" checked />
<!-- Class, Role, Aria Label -->
<div class="buttons" role="tablist" aria-label="Tab Buttons">
Anything with an equals sign (=) followed by a value in that example code is an attribute. So, we can technically style all links with an href attribute equal to https://css-tricks.com:
a[href="https://css-tricks.com"] {
color: orangered;
}
Notice the syntax? We‚Äôre using square brackets ([]) to select an attribute instead of a period or hashtag as we do with classes and IDs, respectively.
CodePen Embed Fallback
The equals sign used in attributes suggests that there‚Äôs more we can do to select elements besides matching something that‚Äôs exactly equal to the value. That is indeed the case. For example, we can make sure that the matching selector is capitalized or not. A good use for that could be selecting elements with the href attribute as long as they do not contain uppercase letters:
/* Case sensitive */
a[href*='css-tricks' s] {}
The s in there tells CSS that we only want to select a link with an href attribute that does not contain uppercase letters.
<!-- üëé No match -->
<a href="https://CSS-Tricks.com">...</a>
<!-- üëç Match! -->
<a href="https://css-tricks.com">...</a>
If case sensitivity isn‚Äôt a big deal, we can tell CSS that as well:
/* Case insensitive */
a[href*='css-tricks' i] {}
Now, either one of the link examples will match regardless of there being upper- or lowercase letters in the href attribute.
<!-- üëç I match! -->
<a href="https://CSS-Tricks.com">...</a>
<!-- üëç I match too! -->
<a href="https://css-tricks.com">...</a>
There are many, many different types of HTML attributes. Be sure to check out our Data Attributes guide for a complete rundown of not only [data-attribute] but how they relate to other attributes and how to style them with CSS.
Universal selector
CSS-Tricks has a special relationship with the Universal Selector ‚Äî it‚Äôs our logo!
That‚Äôs right, the asterisk symbol (*) is a selector all unto itself whose purpose is to select all the things. Quite literally, we can select everything on a page ‚Äî every single element ‚Äî with that one little asterisk. Note I said every single element, so this won‚Äôt pick up things like IDs, classes, or even pseudo-elements. It‚Äôs the element selector for selecting all elements.
/* Select ALL THE THINGS! üí• */
* {
/* Styles */
}
Or, we can use it with another selector type to select everything inside a specific element.
/* Select everything in an <article> */
article * {
/* Styles */
}
That is a handy way to select everything in an <article>, even in the future if you decide to add other elements inside that element to the HTML. The times you‚Äôll see the Universal Selector used most is to set border-sizing on all elements across the board, including all elements and pseudo-elements.
*,
*::before,
*::after {
box-sizing: border-box;
}
There‚Äôs a good reason this snippet of CSS winds up in so many stylesheets, which you can read all about in the following articles.
Sometimes the Universal Selector is implied. For example, when using a pseudo selector at the start of a new selector. These are selecting exactly the same:
*:has(article) { }
:has(article)
{ }
Pseudo-selectors
Pseudo-selectors are for selecting pseudo-elements, just as element selectors are for selecting elements. And a pseudo-element is just like an element, but it doesn‚Äôt actually show up in the HTML. If pseudo-elements are new to you, we have a quick explainer you can reference.
Every element has a ::before and ::after pseudo-element attached to it even though we can‚Äôt see it in the HTML.
<div class="container">
<!-- ::before psuedo-element here -->
<div>Item</div>
<div>Item</div>
<div>Item</div>
<!-- ::after psuedo-element here -->
</div>
These are super handy because they‚Äôre additional ways we can hook into an element and apply additional styles without adding more markup to the HTML. Keep things as clean as possible, right?!
We know that ::before and ::after are pseudo-elements because they are preceded by a pair of colons (::). That‚Äôs how we select them, too!
.container::before {
/* Styles */
}
The ::before and ::after pseudo-elements can also be written with a single colon ‚Äî i.e., :before and :after ‚Äî but it‚Äôs still more common to see a double colon because it helps distinguish pseudo-elements from pseudo-classes.
But there‚Äôs a catch when using pseudo-selectors: they require the content property. That‚Äôs because pseudos aren‚Äôt ‚Äúreal‚Äù elements but ones that do not exist as far as HTML is concerned. That means they need content that can be displayed‚Ä¶ even if it‚Äôs empty content:
.container::before {
content: "";
}
Of course, if we were to supply words in the content property, those would be displayed on the page.
CodePen Embed Fallback
Complex selectors
Complex selectors may need a little marketing help because ‚Äúcomplex‚Äù is an awfully scary term to come across when you‚Äôre in the beginning stages of learning this stuff. While selectors can indeed become complex and messy, the general idea is super straightforward: we can combine multiple selectors in the same ruleset.
Let‚Äôs look at three different routes we have for writing these ‚Äúnot-so-complex‚Äù complex selectors.
Listing selectors
First off, it‚Äôs possible to combine selectors so that they share the same set of styles. All we do is separate each selector with a comma.
.selector-1,
.selector-2,
.selector-3 {
/* We share these styles! ü§ó */
}
You‚Äôll see this often when styling headings ‚Äî which tend to share the same general styling except, perhaps, for font-size.
h1,
h2,
h3,
h4,
h5,
h6 {
color: hsl(25 80% 15%);
font-family: "Poppins", system-ui;
}
Adding a line break between selectors can make things more legible. You can probably imagine how complex and messy this might get. Here‚Äôs one, for example:
section h1, section h2, section h3, section h4, section h5, section h6,
article h1, article h2, article h3, article h4, article h5, article h6,
aside h1, aside h2, aside h3, aside h4, aside h5, aside h6,
nav h1, nav h2, nav h3, nav h4, nav h5, nav h6 {
color: #BADA55;
}
Ummmm, okay. No one wants this in their stylesheet. It‚Äôs tough to tell what exactly is being selected, right?
The good news is that we have modern ways of combining these selectors more efficiently, such as the :is() pseudo selector. In this example, notice that we‚Äôre technically selecting all of the same elements. If we were to take out the four section, article, aside, and nav element selectors and left the descendants in place, we‚Äôd have this:
h1, h2, h3, h4, h5, h6,
h1, h2, h3, h4, h5, h6,
h1, h2, h3, h4, h5, h6,
h1, h2, h3, h4, h5, h6, {
color: #BADA55;
}
The only difference is which element those headings are scoped to. This is where :is() comes in handy because we can match those four elements like this:
:is(section, article, aside, nav) {
color: #BADA55;
}
That will apply color to the elements themselves, but what we want is to apply it to the headings. Instead of listing those out for each heading, we can reach for :is() again to select them in one fell swoop:
/* Matches any of the following headings scoped to any of the following elements.
*/
:is(section, article, aside, nav) :is(h1, h2, h3, h4, h5, h6) {
color: #BADA55;
}
While we‚Äôre talking about :is() it‚Äôs worth noting that we have the :where() pseudo selector as well and that it does the exact same thing as :is(). The difference? The specificity of :is() will equal the specificity of the most specific element in the list. Meanwhile, :where() maintains zero specificity. So, if you want a complex selector like this that‚Äôs easier to override, go with :where() instead.
Nesting selectors
That last example showing how :is() can be used to write more efficient complex selectors is good, but we can do even better now that CSS nesting is a widely supported feature.
This browser support data is from Caniuse, which has more detail. A number indicates that browser supports the feature at that version and up.DesktopChromeFirefoxIEEdgeSafari120117No12017.2Mobile / TabletAndroid ChromeAndroid FirefoxAndroidiOS Safari14014214017.2
CSS nesting allows us to better see the relationship between selectors. You know how we can clearly see the relationship between elements in HTML when we indent descendant elements?
<!-- Parent -->
<article>
<!-- Child -->
<img src="" alt="...">
<!-- Child -->
<div class="article-content">
<!-- Grandchild -->
<h2>Title</h2>
<!-- Grandchild -->
<p>Article content.</p>
</div>
</article>
CSS nesting is a similar way that we can format CSS rulesets. We start with a parent ruleset and then embed descendant rulesets inside. So, if we were to select the <h2> element in that last HTML example, we might write a descendant selector like this:
article h2 { /* Styles */ }
With nesting:
article
{
/* Article styles */
h2 { /* Heading 2 styles */ }
}
You probably noticed that we can technically go one level deeper since the heading is contained in another .article-content element:
article
{
/* Article styles */
.article-content {
/* Container styles */
h2 { /* Heading 2 styles */ }
}
}
So, all said and done, selecting the heading with nesting is the equivalent of writing a descendant selector in a flat structure:
article .article-content h2 { /* Heading 2 styles */ }
You might be wondering how the heck it‚Äôs possible to write a chained selector in a nesting format. I mean, we could easily nest a chained selector inside another selector:
article
{
/* Article styles */
h2.article-content {
/* Heading 2 styles */
}
}
But it‚Äôs not like we can re-declare the article element selector as a nested selector:
article
{
/* Article styles */
/* Nope! üëé */
article.article-element {
/* Container styles */
/* Nope! üëé */
h2.article-content {
/* Heading 2 styles */
}
}
}
Even if we could do that, it sort of defeats the purpose of a neatly organized nest that shows the relationships between selectors. Instead, we can use the ampersand (&) symbol to represent the selector that we‚Äôre nesting into. We call this the nesting selector.
article
{
&.article-content {
/* Equates to: article.article-content */
}
}
Compounding selectors
We‚Äôve talked quite a bit about the Cascade and how it determines which styles to apply to matching selectors using a specificity score. We saw earlier how an element selector is less specific than a class selector, which is less specific than an ID selector, and so on.
article { /* Specificity: 0, 0, 1 */ }
.featured { /* Specificity: 0, 1, 0 */ }
#featured { /* Specificity: 1, 0, 0 */ }
Well, we can increase specificity by chaining ‚Äî or ‚Äúcompounding‚Äù ‚Äî selectors together. This way, we give our selector a higher priority when it comes to evaluating two or more matching styles. Again, overriding ID selectors is incredibly difficult so we‚Äôll work with the element and class selectors to illustrate chained selectors.
We can chain our article element selector with our .featured class selector to generate a higher specificity score.
article { /* Specificity: 0, 0, 1 */ }
.featured { /* Specificity: 0, 1, 0 */ }
articie.featured { /* Specificity: 0, 1, 1 */ }
This new compound selector is more specific (and powerful!) than the other two individual selectors. Notice in the following demo how the compound selector comes before the two individual selectors in the CSS yet still beats them when the Cascade evaluates their specificity scores.
CodePen Embed Fallback
Interestingly, we can use ‚Äúfake‚Äù classes in chained selectors as a strategy for managing specificity. Take this real-life example:
.wp-block-theme-button .button:not(.specificity):not(.extra-specificity) { }
Whoa, right? There‚Äôs a lot going on there. But the idea is this: the .specificity and .extra-specificity class selectors are only there to bump up the specificity of the .wp-block-theme .button descendant selector. Let‚Äôs compare the specificity score with and without those artificial classes (that are :not() included in the match).
.wp-block-theme-button .button {
/* Specificity: 0, 2, 0 */
}
.wp-block-theme-button .button:not(.specificity) {
/* Specificity: 0, 3, 0 */
}
.wp-block-theme-button
.button:not(.specificity):not(.extra-specificity {
/* Specificity: 0, 4, 0 */
}
Interesting! I‚Äôm not sure if I would use this in my own CSS but it is a less heavy-handed approach than resorting to the !important keyword, which is just as tough to override as an ID selector.
Combinators
If selectors are ‚Äúwhat‚Äù we select in CSS, then you might think of CSS combinators as ‚Äúhow‚Äù we select them. they‚Äôre used to write selectors that combine other selectors in order to target elements. Inception!
The name ‚Äúcombinator‚Äù is excellent because it accurately conveys the many different ways we‚Äôre able to combine selectors. Why would we need to combine selectors? As we discussed earlier with Chained Selectors, there are two common situations where we‚Äôd want to do that:
When we want to increase the specificity of what is selected.
When we want to select an element based on a condition.
Let‚Äôs go over the many types of combinators that are available in CSS to account for those two situations in addition to chained selectors.
Descendant combinator
We call it a ‚Äúdescendant‚Äù combinator because we use it to select elements inside other elements, sorta like this:
/* Selects all elements in .parent with .child class */
.parent .child {}
‚Ä¶which would select all of the elements with the .child class in the following HTML example:
<div class="parent">
<div class="child"></div>
<div class="child"></div>
<div class="friend"></div>
<div class="child"></div>
<div class="child"></div>
</div>
See that element with the .friend classname? That‚Äôs the only element inside of the .parent element that is not selected with the .parent .child {} descendant combinator since it does not match .child even though it is also a descendant of the .parent element.
Child combinator
A child combinator is really just an offshoot of the descendant combinator, only it is more specific than the descendant combinator because it only selects direct children of an element, rather than any descendant.
Let‚Äôs revise the last HTML example we looked at by introducing a descendant element that goes deeper into the family tree, like a .grandchild:
<div class="parent">
<div class="child"></div>
<div class="child">
<div class="grandchild"></div>
</div>
<div class="child"></div>
<div class="child"></div>
</div>
So, what we have is a .parent to four .child elements, one of which contains a .grandchild element inside of it.
Maybe we want to select the .child element without inadvertently selecting the second .child element‚Äôs .grandchild. That‚Äôs what a child combinator can do. All of the following child combinators would accomplish the same thing:
/* Select only the "direct" children of .parent */
.parent > .child {}
.parent > div {}
.parent > * {}
See how we‚Äôre combining different selector types to make a selection? We‚Äôre combinating, dangit! We‚Äôre just doing it in slightly different ways based on the type of child selector we‚Äôre combining.
/* Select only the "direct" children of .parent */
.parent > #child { /* direct child with #child ID */
.parent > .child { /* direct child with .child class */ }
.parent > div { /* direct child div elements */ }
.parent > * { /* all direct child elements */ }
It‚Äôs pretty darn neat that we not only have a way to select only the direct children of an element, but be more or less specific about it based on the type of selector. For example, the ID selector is more specific than the class selector, which is more specific than the element selector, and so on.
General sibling combinator
If two elements share the same parent element, that makes them siblings like brother and sister. We saw an example of this in passing when discussing the descendant combinator. Let‚Äôs revise the class names from that example to make the sibling relationship a little clearer:
<div class="parent">
<div class="brother"></div>
<div class="sister"></div>
</div>
This is how we can select the .sister element as long as it is preceded by a sibling with class .brother.
/* Select .sister only if follows .brother */
.brother ~ .sister { }
The Tilda symbol (~) is what tells us this is a sibling combinator.
It doesn‚Äôt matter if a .sister comes immediately after a .brother or not ‚Äî as long as a .sister comes after a brother and they share the same parent element, it will be selected. Let‚Äôs see a more complicated HTML example:
<main class="parent">
<!-- .sister immediately after .brother -->
<div class="brother"></div>
<div class="sister"></div>
<!-- .sister immediately after .brother -->
<div class="brother"></div>
<div class="sister"></div>
<!-- .sister immediately after .sister -->
<div class="sister"></div>
<!-- .cousin immediately after .brother -->
<div class="brother"></div>
<div class="cousin">
<!-- .sister contained in a .cousin -->
<div class="sister"></div>
</div>
</main>
The sibling combinator we wrote only selects the first three .sister elements because they are the only ones that come after a .brother element and share the same parent ‚Äî even in the case of the third .sister which comes after another sister! The fourth .sister is contained inside of a .cousin, which prevents it from matching the selector.
Let‚Äôs see this in context. So, we can select all of the elements with an element selector since each element in the HTML is a div:
CodePen Embed Fallback
From there, we can select just the brothers with a class selector to give them a different background color:
CodePen Embed Fallback
We can also use a class selector to set a different background color on all of the elements with a .sister class:
CodePen Embed Fallback
And, finally, we can use a general sibling combinator to select only sisters that are directly after a brother.
CodePen Embed Fallback
Did you notice how the last .sister element‚Äôs background color remained green while the others became purple? That‚Äôs because it‚Äôs the only .sister in the bunch that does not share the same .parent as a .brother element.
Adjacent combinator
Believe it or not, we can get even more specific about what elements we select with an adjacent combinator. The general sibling selector we just looked at will select all of the .sister elements on the page as long as it shares the same parent as .brother and comes after the .brother.
What makes an adjacent combinator different is that it selects any element immediately following another. Remember how the last .sister didn‚Äôt match because it is contained in a different parent element (i.e., .cousin)? Well, we can indeed select it by itself using an adjacent combinator:
/* Select .sister only if directly follows .brother */
.brother + .sister { }
Notice what happens when we add that to our last example:
CodePen Embed Fallback
The first two .sister elements changed color! That‚Äôs because they are the only sisters that come immediately after a .brother. The third .sister comes immediately after another .sister and the fourth one is contained in a .cousin which prevents both of them from matching the selection.
Learn more about CSS selectors
Selectors (CSS-Tricks Almanac)
Learn CSS: Selectors (Mozilla Developer Network)
Guide to Advanced Selectors (ModernCSS.dev)
Selectors (web.dev)
Selectors Explained: Translate Selectors into English (Kitty Giraudel)
CSS Diner (Interactive game)
Table of contents
Overview
Quick reference
General Selectors
Complex selectors
Combinators
Learn more about CSS selectors
References
References
The vast majority of what you‚Äôre reading here is information pulled from articles we‚Äôve published on CSS-Tricks and those are linked up throughout the guide. In addition to those articles, the following resources were super helpful for putting this guide together.
CSS Selectors Level 4 (W3C)
3.2.6¬†Global Attributes (HTML Living Standard)
Psst! Create a DigitalOcean account and get $200 in free credit for cloud-based hosting and services.
Comments
Oliver Permalink to comment# July 18, 2024
Thanks for the article!
Maybe you could also mention the owln selector ?
https://alistapart.com/article/axiomatic-css-and-lobotomized-owls/
It‚Äôs cool and I missed it here.
Reply
Alphakeem Adroit Permalink to comment# July 28, 2024
I just wanted to say how incredibly helpful these tips on CSS selectors are! They‚Äôve really improved my understanding and application of CSS in my projects. Thank you for sharing your knowledge and expertise. Keep up the fantastic work
Reply
ash Permalink to comment# June 24, 2025
‚Äúarticie.featured‚Äù :^)
under compounding selectors
Reply
Leave a Reply Cancel replyYour email address will not be published. Required fields are marked *Comment * Name *
Email *
Website
Save my name, email, and website in this browser for the next time I comment.
Copy and paste this code: micuno *
Leave this field empty
Œî
CSS-Tricks is powered by DigitalOcean.
Keep up to date on web dev
with our hand-crafted newsletter
DigitalOcean
About DO
Cloudways
Legal stuff
Get free credit!
CSS-Tricks
Contact
Write for CSS-Tricks!
Advertise with us
Social
RSS Feeds
CodePen
Mastodon
Bluesky
Back to Top