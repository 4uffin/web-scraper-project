Additive Animation with the Web Animations API | CSS-Tricks
Skip to main content
CSS-Tricks
Articles
Notes
Links
Guides
Almanac
Picks
Shuffle
Search
animation waapi
Additive Animation with the Web Animations API
Dan Wilson
on
Mar 30, 2020
Get affordable and hassle-free WordPress hosting plans with Cloudways — start your free trial today.
These features have not landed in any stable browsers at the time of writing. However, everything discussed is already in Firefox Nightly by default and key parts are in Chrome Canary (with the Experimental Web Platform Features flag enabled), so I recommend using one of those browsers (when reading this article) to see as many of the features in action as possible.
Regardless your preferred method of animation on the web, there will be times that you need to animate the same property in separate animations. Maybe you have a hover effect that scales an image and a click event that triggers a translate — both affecting the transform. By default, those animations do not know anything about the other, and only one will visually be applied (since they are affecting the same CSS property and the other value will be overridden).
element.animate({
transform: ['translateY(0)', 'translateY(10px)']
}, 1000);
/* This will completely override the previous animation */
element.animate({
transform: ['scale(1)', 'scale(1.15)']
}, 1500);
The second animation in this Web Animations API example is the only one that would be visually rendered in this example as both animations play at the same time and it was the last one defined.
Sometimes we even have grander ideas where we want a foundational animation and then based on some user interaction change in state we smoothly modify the animation a bit midway without affecting its existing duration, keyframes, or easing. CSS Animations and the current Web Animations API in stable browsers today cannot do this out of the box.
A New Option
The Web Animations specification introduces the composite property (and the related iterationComposite). The default composite is 'replace' and has the behavior we have had for years now where an actively animating property’s value simply replaces any previously set value — either from a rule set or another animation.
The 'add' value is where things change from the previous norms.
element.animate({
transform: ['scale(1)', 'scale(1.5)']
}, {
duration: 1000,
fill: 'both'
});
element.animate({
transform: ['rotate(0deg)', 'rotate(180deg)']
}, {
duration: 1500,
fill: 'both',
composite: 'add'
});
Now both animations will be seen as the browser on the fly figures out the appropriate transformation at a given point in the element’s timeline accounting for both transformations. In our examples, the easing is 'linear' by default and the animations start at the same time, so we can break out what the effective transform is at any given point. Such as:
0ms: scale(1) rotate(0deg)
500ms: scale(1.25) rotate(60deg) (halfway through first animation, 1/3 through second)
1000ms: scale(1.5) rotate(120deg) (end of first, 2/3 through second)
1500ms: scale(1.5) rotate(180deg) (end of second)
See the Pen Animation Composite
by Dan Wilson (@danwilson) on CodePen.
So Let’s Get Creative
An individual animation does not just consist of a start state and end state — it can have its own easing, iteration count, duration, and more keyframes in the middle. While an element is mid animation you can throw an additional transformation on it with its own timing options.
See the Pen Add more transform animations by Dan Wilson (@danwilson) on CodePen.
This example lets you apply multiple animations on the same element, all affecting the transform property. To keep from going all out in this example, we limit each animation to a single transformation function at a time (such as only a scale), starting at a default value (such as scale(1) or translateX(0)), and ending at a reasonable random value on that same transformation function, repeated infinitely. The next animation will affect another single function with its own randomized duration and easing.
element.animate(getTransform(), //e.g. { transform: ['rotate(0deg), 'rotate(45deg)'] }
{
duration: getDuration(), //between 1000 and 6000ms
iterations: Infinity,
composite: 'add',
easing: getEasing() //one of two options
});
When each animation starts, the browser will effectively find where it is in its previously applied animations and start a new rotation animation with the specified timing options. Even if there is already a rotation going in the opposite direction, the browser will do the math to figure out how much a rotation needs to happen.
Since each animation has its own timing options, you are unlikely to see the exact same motion repeated in this example once you have added a few.
This gives the animation a fresh feel as you watch it.
Since each animation in our example starts at the default value (0 for translations and 1 for scaling) we get a smooth start. If we instead had keyframes such as { transform: ['scale(.5)', 'scale(.8)'] } we would get a jump because the didn’t have this scale before and all of a sudden starts its animation at half scale.
How are values added?
Transformation values follow the syntax of
in the spec, and if you add a transformation you are appending to a list.
For transform animations A, B, and C the resulting computed transform value will be [current value in A] [current value in B] [current value in C]. For example, assume the following three animations:
element.animate({
transform: ['translateX(0)', 'translateX(10px)']
}, 1000);
element.animate({
transform: ['translateY(0)', 'translateY(-20px)']
}, {
duration:1000,
composite: 'add'
});
element.animate({
transform: ['translateX(0)', 'translateX(300px)']
}, {
duration:1000,
composite: 'add'
});
Each animation runs for 1 second with a linear easing, so halfway through the animations the resulting transform would have the value translateX(5px) translateY(-10px) translateX(150px). Easings, durations, delays, and more will all affect the value as you go along.
Transforms are not the only thing we can animate, however. Filters (hue-rotate(), blur(), etc) follow a similar pattern where the items are appended to a filter list.
Some properties use a number as a value, such as opacity. Here the numbers will add up to a single sum.
element.animate({
opacity: [0, .1]
}, 1000);
element.animate({
opacity: [0, .2]
}, {
duration:1000,
composite: 'add'
});
element.animate({
opacity: [0, .4]
}, {
duration:1000,
composite: 'add'
});
Since each animation again is 1s in duration with a linear easing, we can calculate the resulting value at any point in that animation.
0ms: opacity: 0 (0 + 0 + 0)
500ms: opacity: .35 (.05 + .1 + .2)
1000ms: opacity: .7 (.1 + .2 + .4)
As such, you won’t be seeing much if you have several animations that include the value 1 as a keyframe. That is a max value for its visual state, so adding up to values beyond that will look the same as if it were just a 1.
See the Pen Add more opacity animations by Dan Wilson (@danwilson) on CodePen.
Similar to opacity and other properties that accept number values, properties that accept lengths, percentages, or colors will also sum to a single result value.
With colors, you must remember they also have a max value, too (whether a max of 255 in rgb() or 100% for saturation/lightness in hsl()), so your result could max out to a white. With lengths, you can switch between units (such as px to vmin) as though it is inside a calc().
For more details, the specification outlines the different types of animation and how the result is calculated.
Working with Fill Modes
When you are not doing an infinite animation (whether you are using a composite or not) by default the animation will not keep its end state as the animation ends. The fill property allows us to change that behavior. If you want to have a smooth transition when you add a finite animation, you likely will want a fill mode of either forwards or both to make sure the end state remains.
See the Pen Spiral: Composite Add + Fill Forwards by Dan Wilson (@danwilson) on CodePen.
This example has an animation with a spiral path by specifying a rotation and a translation. There are two buttons that add new one second animations with an additional small translation. Since they specify fill: 'forwards' each additional translation effectively remains part of the transform list. The expanding (or shrinking) spiral adapts smoothly with each translation adjustment because it is an additive animation from translateX(0) to a new amount and remains at that new amount.
Accumulating animations
The new composite option has a third value — 'accumulate'. It is conceptually in line with 'add' except certain types of animations will behave differently. Keeping with our transform, let’s start with a new example using 'add' and then discuss how 'accumulate' is different.
element.animate({
transform: ['translateX(0)', 'translateX(20px)']
}, {
duration: 1000,
composite: 'add'
});
element.animate({
transform: ['translateX(0)', 'translateX(30px)']
}, {
duration: 1000,
composite: 'add'
});
element.animate({
transform: ['scale(1)', 'scale(.5)']
}, {
duration: 1000,
composite: 'add'
});
At the 1 second mark (the end of the animations), the effective value will be:
transform: translateX(20px) translateX(30px) scale(.5)
Which will visually push an element to the right 50px and then scale it down to half width and half height.
If each animation had been using 'accumulate' instead, then the result would be:
transform: translateX(50px) scale(.5)
Which will visually push an element to the right 50px and then scale it down to half width and half height.
No need for a double take, the visual results are in fact the exact same — so how is 'accumulate' any different?
Technically when accumulating a transform animation we are no longer always appending to a list. If a transformation function already exists (such as the translateX() in our example) we will not append the value when we start our second animation. Instead, the inner values (i.e. the length values) will be added and placed in the existing function.
If our visual results are the same, why does the option to accumulate inner values exist?
In the case of transform, order of the list of functions matters. The transformation translateX(20px) translateX(30px) scale(.5) is different than translateX(20px) scale(.5) translateX(30px) because each function affects the coordinate system of the functions that follow it. When you do a scale(.5) in the middle, the latter functions will also happen at the half scale. Therefore with this example the translateX(30px) will visually render as a 15px translation to the right.
See the Pen Visual Reference: Transform Coordinate Systems by Dan Wilson (@danwilson) on CodePen.
Therefore, with accumulation we can have an order that is different then when we always append the values to the list.
Accumulating for Each Iteration
I mentioned before that there is also a new related iterationComposite property. It provides the ability to do some of the behaviors we have already discussed except on a single animation from one iteration to the next.
Unlike composite, this property only has two valid values: 'replace' (the default behavior you already know and love) and 'accumulate'. With 'accumulate' values follow the already discussed accumulation process for lists (as with transform) or are added together for number based properties like opacity.
As a starting example, the visual result for the following two animations would be identical:
intervals.animate([{
transform: `rotate(0deg) translateX(0vmin)`,
opacity: 0
}, {
transform: `rotate(50deg) translateX(2vmin)`,
opacity: .5
}], {
duration: 2000,
iterations: 2,
fill: 'forwards',
iterationComposite: 'accumulate'
});
intervals2.animate([{
transform: `rotate(0deg) translateX(0vmin)`,
opacity: 0
},{
transform: `rotate(100deg) translateX(4vmin)`,
opacity: 1
}], {
duration: 4000,
iterations: 1,
fill: 'forwards',
iterationComposite: 'replace' //default value
});
The first animation is only bumping up its opacity by .5, rotating 50 degrees, and moving 2vmin for 2000 milliseconds. It has our new iterationComposite value and is set to run for 2 iterations. Therefore, when the animation ends, it will have run for 2 * 2000ms and reached an opacity of 1 (2 * .5), rotated 100 degrees (2 * 50deg) and translated 4vmin (2 * 2vmin).
See the Pen Spiral with WAAPI iterationComposite by Dan Wilson (@danwilson) on CodePen.
Great! We just used a new property that is supported in only Firefox Nightly to recreate what we can already do with the Web Animations API (or CSS)!
The more interesting aspects of iterationComposite come into play when you combine it with other items in the Web Animations spec that are coming soon (and also already in Firefox Nightly).
Setting New Effect Options
The Web Animations API as it stands in stable browsers today is largely on par with CSS Animations with some added niceties like a playbackRate option and the ability to jump/seek to different points. However, the Animation object is gaining the ability to update the effect and timing options on already running animations.
See the Pen WAAPI iterationComposite & composite by Dan Wilson (@danwilson) on CodePen.
Here we have an element with two animations affecting the transform property and relying on composite: 'add' — one that makes the element move across the screen horizontally and one moving it vertically in a staggered manner. The end state is a little higher on the screen than the start state of this second animation, and with iterationComposite: 'accumulate' it keeps getting higher and higher. After eight iterations the animation finishes and reverses itself for another eight iterations back down to the bottom of the screen where the process begins again.
We can change how far up the screen the animation goes by changing the number of iterations on the fly. These animations are playing indefinitely, but you can change the dropdown to a different iteration count in the middle of the animation. If you are, for example, going from seven iterations to nine and you are seeing the sixth iteration currently, your animation keeps running as though nothing has changed. However, you will see that instead of starting a reverse after that next (seventh) iteration, it will continue for two more. You can also swap in new keyframes, and the animation timing will remain unchanged.
animation.effect.timing.iterations = 4;
animation.effect.setKeyframes([
{ transform: 'scale(1)' },
{ transform: 'scale(1.2)' }
]);
Modifying animations midway may not be something you will use every day, but since it is something new at the browser level we will be learning of its possibilities as the functionality becomes more widely available. Changing iteration counts could be handy for a game when a user get a bonus round and gameplay continues longer than originally intended. Different keyframes can make sense when a user goes from some error state to a success state.
Where do we go from here?
The new composite options and the ability to change timing options and keyframes open new doors for reactive and choreographed animations. There is also an ongoing discussion in the CSS Working Group about adding this functionality to CSS, even beyond the context of animations — affecting the cascade in a new way. We have time before any of this will land in a stable major browser, but it is exciting to see new options coming and even more exciting to be able to experiment with them today.
Psst! Create a DigitalOcean account and get $200 in free credit for cloud-based hosting and services.
Comments
Brian Montana Permalink to comment# January 10, 2018
Thank you so much Dan, this is lovely! These new features are incredibly powerful for the WAAPI :D
This comment thread is closed. If you have important information to share, please contact us.
CSS-Tricks is powered by DigitalOcean.
Keep up to date on web dev
with our hand-crafted newsletter
DigitalOcean
About DO
Cloudways
Legal stuff
Get free credit!
CSS-Tricks
Contact
Write for CSS-Tricks!
Advertise with us
Social
RSS Feeds
CodePen
Mastodon
Bluesky
Back to Top