How to spin Python’s challenges into AI gold | InfoWorld
Topics
Spotlight: IT CareersVideosNewslettersResources
AboutAbout UsAdvertiseContact UsEditorial Ethics PolicyFoundry CareersNewslettersContribute to InfoWorldReprintsPoliciesTerms of ServicePrivacy PolicyCookie PolicyCopyright NoticeMember PreferencesAbout AdChoicesYour California Privacy RightsOur NetworkCIOComputerworldCSONetwork WorldMoreNewsFeaturesBlogsBrandPostsEventsVideosEnterprise Buyer’s Guides
Close
AnalyticsArtificial IntelligenceGenerative AICareersCloud ComputingData ManagementDatabasesEmerging TechnologyTechnology IndustrySecuritySoftware Development Microsoft .NETDevelopment ToolsDevopsOpen SourceProgramming LanguagesJavaJavaScriptPythonIT LeadershipEnterprise Buyer’s Guides
Back
Close
Back
Close
Popular Topics
Artificial IntelligenceCloud ComputingData ManagementSoftware Development
Search
Topics
Spotlight: IT CareersVideosNewslettersResourcesAboutPoliciesOur NetworkMore
Back
Topics
AnalyticsArtificial IntelligenceGenerative AICareersCloud ComputingData ManagementDatabasesEmerging TechnologyTechnology IndustrySecuritySoftware DevelopmentMicrosoft .NETDevelopment ToolsDevopsOpen SourceProgramming LanguagesJavaJavaScriptPythonIT LeadershipEnterprise Buyer’s Guides
Back
AboutAbout UsAdvertiseContact UsEditorial Ethics PolicyFoundry CareersNewslettersContribute to InfoWorldReprints
Back
PoliciesTerms of ServicePrivacy PolicyCookie PolicyCopyright NoticeMember PreferencesAbout AdChoicesYour California Privacy Rights
Back
Our NetworkCIOComputerworldCSONetwork World
Back
MoreNewsFeaturesBlogsBrandPostsEventsVideosEnterprise Buyer’s Guides
Home
Careers
How to spin Python’s challenges into AI gold
by									Matt Asay
Contributing Writer
How to spin Python’s challenges into AI gold
opinion
Sep 8, 20257 minsDeveloperGenerative AIPython
The multitude of Python tools makes for many choices and many potential pitfalls. Streamline your AI projects by standardizing on tools, approaches, and a ‘golden path’ for development.
Credit: 															nikkytok / Shutterstock
Here’s the uncomfortable truth about Python in the enterprise: The language is easy; the ecosystem is not. Most developers can write readable Python by week two. What derails them—and therefore your schedules—is everything around the language: the project scaffolding, packaging, imports, testing, and the data stack where Python earns its keep. All these issues were laid bare in the replies to Python expert Matt Harrison’s question, “What is your biggest struggle with learning Python?” The replies didn’t complain about syntax; they were about everything orbiting it. If you lead a team of developers, that’s your cue to spend less time focused on for loops and more time on paving a reliable road through Python’s vibrant, complicated ecosystem.
If you’re wondering whether the struggle is worth it, the market has already answered. Python surged again in the 2025 Stack Overflow survey—up seven percentage points year over year—driven by AI and data workloads. For developers and the technical leaders who enable them, investing in Python proficiency isn’t optional; it’s table stakes for modern engineering.
I’ve argued for years that Python became the lingua franca of AI not because it’s the fastest language but because it’s the shortest distance from idea to working code. But that doesn’t mean it’s easy. If you’re a manager, your job is to remove the friction that prevents Python from compounding into business value.
Paving the development path
Harrison’s thread surfaces the same themes I regularly hear about Python from developers in large companies: environment setup, packaging and dependency drift, confusing imports, shaky mental models for dataframes, and a hazy line between “fast enough” prototypes and production-ready services. These are not insurmountable issues. All of them are amplified by organizational indecision—too many ways to start a project, too many “standard” tools, too few high-signal examples.
In other words, your teams aren’t failing at Python; they’re failing at choices.
When leaders ignore this, Python looks fickle. Builds pass on a laptop and fail in CI (continuous integration). Two teams choose two packaging systems and can’t share a library. Data scientists write correct code with painful performance because no one taught vectorization as a first principle. Developers mindlessly embrace async without understanding when concurrency helps. Each incident is small, but the aggregate is a tax you pay every sprint.
The fix is not a thousand-line internal style guide no one reads. It’s a paved road, a “golden path” that makes the right thing the easy thing.
First, start at the beginning. Every Python project should begin its life exactly the same way, with a single command that creates a working repository: standardized layout, test harness, pre-commit hooks, and CI already wired up. Don’t ask engineers to remember a sequence of pip and venv incantations; give them an opinionated scaffold that produces a green build out of the gate. When a developer clones the template and pushes the first commit, they’re not just starting a project—they’re inheriting your defaults for quality. This will cut weeks off the onboarding process, while maintaining consistency.
Second, codify packaging. This is where many Python journeys go off-road, so establish guardrails. The ecosystem has settled on a common configuration file, pyproject.toml, to declare build and project metadata (PEP 621). Make it the baseline in your organization. Whether your teams use Poetry, PDM, or modern consolidated tools, the managerial lever is to pick one and to encode that choice into your templates and CI so drift is noisy and rare. Modern tools are also reducing the pain here. There’s been real velocity behind efforts to unify and speed packaging, but those benefits only show up if you stop treating packaging as a choose-your-own-adventure.
Third, standardize imports and project layouts. This is a quieter class of production bugs—modules that import differently in development versus in production, packages that shadow themselves on sys.path. Don’t rely on tribal knowledge. Bake a single, simple layout into your templates and enforce it in code review. The point isn’t to be clever; it’s to be boring in the best possible way.
Finally, make quality automatic. Python’s low barrier to entry is a feature, not a bug, but it also makes it easy to ship untested prototypes. Put linting, formatting, type checking, and tests on the paved road. Run the tests by default and block any merge on a failing build. You’ll ship more production-ready Python without extra process.
Teach mental models, not trivia
Language features don’t slow teams down; missing mental models do. You’ll get the biggest return on training where Python’s design meets developer intuition. Start with these three elements:
First, the data model. Instead of death-by-dunder (memorizing __this__ and __that__), teach what the model buys you. Show how implementing __iter__ makes your type for-loopable, how __enter__and__exit__ power resource safety with with, how descriptors sit behind @property. These are not party tricks; they’re the foundation for writing Python that feels native, which means code reviewers can reason about it quickly and you’ll be able to maintain it more easily. (Consider this yet another warning not to let your junior developers vibe code without understanding the code, lest it be good vibes and bad code.)
Second, the dataframe mindset. New Python users coming from imperative backgrounds often write row-by-row loops where vectorization belongs. That produces correct results with tragic performance. Teach dataframes as “columnar, vectorized, and chainable.” Start with small, real data sets and reinforce the habit of applying operations to columns, not rows. By the time your teams graduate to bigger engines—whether that’s Pandas at scale, Polars, DuckDB, or Apache Spark—the mental model already fits. You save weeks of unlearning.
Third, concurrency decisions. The Global Interpreter Lock (GIL) discourse scares people away from Python when it shouldn’t. The rule of thumb that keeps teams sane is simple: I/O-bound work benefits from async or threads; CPU-bound work benefits from processes or native extensions. Your paved road should document that decision tree with a couple of internal examples. When the default is clear, fewer developers reach for concurrency to solve the wrong problem.
None of this requires you to turn managers into Pythonistas. It requires you to sponsor short, high-leverage workshops, recorded and indexed, that teach how to think in Python. If the same questions keep showing up in code review—“Why does this import break in CI?”—that’s your curriculum.
What Python nirvana looks like
How do you know when you’ve done this right? The developer experience becomes predictably boring in all the right places. A new hire clones a repo, runs one command, and sees a passing test suite. Imports behave the same way on every laptop and in CI. Data code runs “fast enough” the first time because developers think in columns, not rows. Instead of writing a for loop that iterates through every row to apply a function, developers would instead use vectorized operations provided by libraries like Pandas. Async doesn’t creep where it doesn’t help. And when someone does need to do something unusual, such as shipping a high-performance piece of a pipeline in Rust or Cython, that path is documented, with an example to copy.
A boring process pays you back when you actually want excitement: delivering features faster, tightening feedback loops with data teams, and shipping AI-inflected capabilities that are more than demos. It’s not really about Python or any other language: Organizations win with process and leverage. Python just happens to be the language where a little leverage goes a long way.
Python isn’t a fad you can wait out. It’s the substrate for the work you’ve already prioritized. The language will take care of itself; your job is to make everything around it feel inevitable and simple.
Related content
feature
Advanced debug logging techniques: A technical guide By Neel Shah
Sep 22, 2025 5 mins
Development Tools
JavaScript
Python
analysis
Making good choices: How to get the best from Python tools By Serdar Yegulalp
Sep 12, 2025 3 mins
Development Tools
Generative AI
Python
how-to
Chat with data the easy way in R or Python By Sharon Machlis
Sep 4, 2025 13 mins
Generative AI
Python
R Language
Other Sections
Resources
Videos
Spotlight: IT Careers
by
Matt Asay
Contributing Writer
Follow Matt Asay on X
Follow Matt Asay on LinkedIn
Matt Asay runs developer marketing at Oracle. Previously Asay ran developer relations at MongoDB, and before that he was a Principal at Amazon Web Services and Head of Developer Ecosystem for Adobe. Prior to Adobe, Asay held a range of roles at open source companies: VP of business development, marketing, and community at MongoDB; VP of business development at real-time analytics company Nodeable (acquired by Appcelerator); VP of business development and interim CEO at mobile HTML5 start-up Strobe (acquired by Facebook); COO at Canonical, the Ubuntu Linux company; and head of the Americas at Alfresco, a content management startup. Asay is an emeritus board member of the Open Source Initiative (OSI) and holds a JD from Stanford, where he focused on open source and other IP licensing issues. The views expressed in Matt’s posts are Matt’s, and don’t represent the views of his employer.
More from this author
opinionNPM attacks and the security of software supply chains Sep 22, 2025 7 minsopinionMore hardware won’t fix bad engineering Sep 15, 2025 6 minsopinionWhy DocumentDB can be a win for MongoDB Sep 1, 2025 8 minsanalysisEnterprise essentials for generative AI Aug 25, 2025 10 minsopinionWhy AI fails at business context, and what to do about it Aug 18, 2025 8 minsopinionWho does the unsexy but essential work for open source? Aug 11, 2025 7 minsopinionBridging the trust gap in AI-driven development Aug 4, 2025 7 minsopinionThe importance of memory for AI Jul 28, 2025 9 mins
Show me morePopularArticlesVideos
news
Teradata taps open source frameworks to offer agent-building capabilities By Anirban GhoshalSep 23, 20254 mins
Generative AI
analysis
Cloud computing has an ROI problem By David LinthicumSep 23, 20256 mins
Hybrid CloudMulticloudROI and Metrics
analysis
Vibe coding and the future of software development By Isaac SacolickSep 23, 202511 mins
DevSecOpsDevelopment ToolsGenerative AI
video
Easier Chrome browser automation with PyDoll Sep 16, 20254 mins
Python
video
How to use Rust workspaces to speed up compile times Sep 9, 20253 mins
Python
video
Getting encryption wrong (and getting it right, too) Sep 2, 20257 mins
Python
Sponsored Links
Secure AI by Design: Unleash the power of AI and keep applications, usage and data secure.
Empower your cybersecurity team with expert insights from Palo Alto Networks.
Solve your most complex IT challenges with solutions that simplify your modernization journey.
About
About Us
Advertise
Contact Us
Editorial Ethics Policy
Foundry Careers
Reprints
Newsletters
BrandPosts
Policies
Terms of Service
Privacy Policy
Cookie Policy
Copyright Notice
Member Preferences
About AdChoices
Your California Privacy Rights
Privacy Settings
Our Network
CIO
Computerworld
CSO
Network World
FacebookXYouTubeGoogle NewsLinkedIn
© 2025
FoundryCo, Inc. All Rights Reserved.