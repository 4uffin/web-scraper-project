Is AI the 4GL we’ve been waiting for? | InfoWorld
Topics
Spotlight: IT CareersVideosNewslettersResources
AboutAbout UsAdvertiseContact UsEditorial Ethics PolicyFoundry CareersNewslettersContribute to InfoWorldReprintsPoliciesTerms of ServicePrivacy PolicyCookie PolicyCopyright NoticeMember PreferencesAbout AdChoicesYour California Privacy RightsOur NetworkCIOComputerworldCSONetwork WorldMoreNewsFeaturesBlogsBrandPostsEventsVideosEnterprise Buyer’s Guides
Close
AnalyticsArtificial IntelligenceGenerative AICareersCloud ComputingData ManagementDatabasesEmerging TechnologyTechnology IndustrySecuritySoftware Development Microsoft .NETDevelopment ToolsDevopsOpen SourceProgramming LanguagesJavaJavaScriptPythonIT LeadershipEnterprise Buyer’s Guides
Back
Close
Back
Close
Popular Topics
Artificial IntelligenceCloud ComputingData ManagementSoftware Development
Search
Topics
Spotlight: IT CareersVideosNewslettersResourcesAboutPoliciesOur NetworkMore
Back
Topics
AnalyticsArtificial IntelligenceGenerative AICareersCloud ComputingData ManagementDatabasesEmerging TechnologyTechnology IndustrySecuritySoftware DevelopmentMicrosoft .NETDevelopment ToolsDevopsOpen SourceProgramming LanguagesJavaJavaScriptPythonIT LeadershipEnterprise Buyer’s Guides
Back
AboutAbout UsAdvertiseContact UsEditorial Ethics PolicyFoundry CareersNewslettersContribute to InfoWorldReprints
Back
PoliciesTerms of ServicePrivacy PolicyCookie PolicyCopyright NoticeMember PreferencesAbout AdChoicesYour California Privacy Rights
Back
Our NetworkCIOComputerworldCSONetwork World
Back
MoreNewsFeaturesBlogsBrandPostsEventsVideosEnterprise Buyer’s Guides
Home
Artificial Intelligence
Is AI the 4GL we’ve been waiting for?
by									Matthew Tyson
Contributing Writer
Is AI the 4GL we’ve been waiting for?
analysis
Sep 17, 20257 minsGenerative AINo Code and Low CodeProgramming Languages
Clearly, artificial intelligence has achieved more significance than fourth-generation languages ever did. But the similarities merit our attention.
Credit: 															Bernd von Darl
When I was a young engineer, there was a gruff old programmer named Larry who often imparted his wisdom to us young’uns. A man in his forties, he had that gritty, seen-it-all manner that bespoke years of hard-fought battles in the coding trenches. His was a heart of gold covered in a cloak of cynicism; imagine Philip Seymour Hoffman as a Perl programmer.
Over his fourteenth cup of coffee, Larry would dispense his ruminations on the life of coding, the realities of projects (and project managers), and the virtues of vi versus EMACS. One thing he said, that has stuck with me all these years, was that fourth-generation languages (4GL) had never worked and never would.
Like most software developers, I have been frolicking in the gardens of AI-generated code for a couple of years now. I’m starting to wonder: Is this it? Have we arrived at the long-awaited utopia of 4GL?
What is 4GL?
Wikipedia has a good overview of the fourth-generation language concept, which was supposed to sweep across software like a revelation. Among other things, 4GLs are sometimes described as “program-generating languages.” They are a higher-level abstraction from familiar third-generation languages like Java and JavaScript, and tend to focus on more natural language syntax.
Terms like natural language interface and program-generating certainly do sound like generative AI, don’t they? There was even a book written in 1981 called Application Development Without Programmers, which foresaw a future where artificial intelligence would replace human developers.
But actual 4GLs like FOCUS, along with modern derivatives like WYSIWYG editors, rapid application development (RAD) frameworks, and low-code/no-code platforms, all fail to live up to that promise for one simple reason: They all require a developer who knows how to use them. Even with natural language coding solutions, there are times when someone needs to be able to drop into the underlying system and fix it. (See my recent Roo Code review for more about this.)
4GL and generative AI
Most non-programmers would agree that using a 4GL-derived solution feels a lot like programming. Even a WYSIWYG RAD framework requires considerable thought and some knowledge of programming concepts. You need a basic understanding of datastores and schemas (yes, even with NoSQL), the middleware that connects a datastore to the interface, and the interface itself. You also need to understand the relationship between services and APIs and the infrastructure that enables and secures them.
This also seems to be true when using large language models (LLMs) to generate code, but to a lesser degree. Very broad natural language descriptions of functionality are not terribly effective. What is most effective when programming with AI, in my experience, is an iterative back-and-forth process that dips in and out of varying degrees of granularity.
The more we push abstractions to handle complexity, the more evident it becomes that a proficient human being must still drive the work itself. Understanding the details that are smoothed out by abstraction become more important when each of the parts and all their interrelations are stretched.
When working directly on the details of a component, using a 4GL tool to interface with it can feel like trying to do detailed handiwork with bulky gloves on. I think most experienced programmers would say the same about using an AI coding assistant.
What AI gets right
Don’t get me wrong: It’s incredibly handy to be able to ask an AI tool to spit out a decent function that does exactly what you need, and a recent study shows that more senior developers are taking full advantage of AI capabilities. But the more broadly we shotgun AI power at complex problems, the more we create something that feels like technical debt. Maybe a better term in this case would be comprehension debt.
AI is a great tool for interfacing with general knowledge about design and architecture. The ability to bring programming code and concepts into a common frame is a big advantage of AI, and of 4GL. But to leverage either tool, the user must have some basic understanding of programming concepts and how they are applied.
Without the will to completion
Higher order abstractions tend to excel at prototyping, but they’re not so well-suited to developing the final product in production. That last act tends to require one or more people who not only understand the underlying infrastructure but have what I call the will to completion.
What I’m saying is, you need someone who will take whatever mechanism is provided and drive toward an envisioned goal, and who will keep adapting and moving forward until that goal is realized. This is a uniquely human trait that cannot be abstracted away. Like 4GL, artificial intelligence may serve that end, but it can’t drive it.
A human programmer brings something to the table which I will call caring, also known as “giving a @#^$.” Every experienced developer by now has noticed the way that AI will just confidently deliver the wrong solution over and over again, or break one thing while fixing another. That’s because AI doesn’t actually care about the result.
When laziness leads to more work
It’s a strange paradox that the more you need the AI, the less useful it is. Seasoned software developers can confidently use AI because, when it goes wrong, we can just jump in there and fix it. Years of programming experience make it easy to see where machine intelligence is going off the rails. But when less experienced developers rely on AI, they are less equipped to catch the mistakes. This is the peril of “lazy programming” writ large.
As an example, consider my long-standing dysfunctional relationship with CSS. The truth is, I’m just not very good at it. For a time, I was thinking AI coding assistance might solve my problem. With AI, I might suddenly become a more competent, less-stressed-out CSS developer. Instead, I am still a mediocre CSS developer—and now also a user of AI-generated CSS.
I can keep muddling through with CSS and leaning on AI tools to catch me when I fail. But the real solution, I’ve found, is to work with a human being who actually understands CSS in all the ways I don’t. That’s okay; I like those people and enjoy working with them. They are magical beings, kind of like those who can cook pasta properly.
Conclusion
The dream of AI looks an awful lot like the dream of 4GL. Clearly, AI has achieved more significance in its practical effects than 4GLs ever did. But the limitations and fault lines are similar enough to merit our attention. I seriously wonder if the vast tracts of AI-generated code will just drive up the demand for more software engineering expertise—old hands like Larry, who remain skeptical any of this will lead to much.
Related content
news
Rust 1.90 brings workspace publishing support to Cargo By Paul Krill
Sep 19, 2025 2 mins
Apple
Programming Languages
Rust
analysis
Adding up the hidden costs of generative AI By Josh Fruhlinger
Sep 19, 2025 3 mins
Artificial Intelligence
Generative AI
Technology Industry
news
Wasm 3.0 adds 64-bit backing, language support By Paul Krill
Sep 19, 2025 3 mins
Java
Kotlin
Scala
news
AI Alliance forges agent-native language, knowledge base By Paul Krill
Sep 18, 2025 2 mins
Artificial Intelligence
Generative AI
Programming Languages
Other Sections
Resources
Videos
Spotlight: IT Careers
by
Matthew Tyson
Contributing Writer
Matthew Tyson is a contributing writer at InfoWorld. A seasoned technology journalist and expert in enterprise software development, Matthew has written about programming, programming languages, language frameworks, application platforms, development tools, databases, cryptography, information security, cloud computing, and emerging technologies such as blockchain and machine learning for more than 15 years. His work has appeared in leading publications including InfoWorld, CIO, CSO Online, and IBM developerWorks. Matthew also has had the privilege of interviewing many tech luminaries including Brendan Eich, Grady Booch, Guillermo Rauch, and Martin Hellman.
Matthew’s diverse background encompasses full-stack development (Java, JVM languages such as Kotlin, JavaScript, Python, .NET), front-end development (Angular, React, Vue, Svelte) and back-end development (Spring Boot, Node.js, Django), software architecture, and IT infrastructure at companies ranging from startups to Fortune 500 enterprises. He is a trusted authority in critical technology areas such as database design (SQL and NoSQL), AI-assisted coding, agentic AI, open-source initiatives, enterprise integration, and cloud platforms, providing insightful analysis and practical guidance rooted in real-world experience.
More from this author
feature9 vital concepts of modern JavaScript Sep 10, 2025 10 minsanalysisWhat makes JavaScript great Sep 5, 2025 4 minsfeatureWhat is the JVM? Introducing the Java virtual machine Sep 3, 2025 13 minshow-toHands-on with Solid: Reactive programming with signals Aug 27, 2025 11 minsanalysisIs the generative AI bubble about to burst? Aug 20, 2025 8 minshow-toHands-on with Svelte: Build-time compilation in a reactive framework Aug 13, 2025 11 minsreviewsRoo Code review: Autonomous AI-powered development in the IDE Aug 6, 2025 13 minsanalysisFun and profit with ECMAScript 2025: What’s new in JavaScript Aug 1, 2025 3 mins
Show me morePopularArticlesVideos
analysis
How Oracle became a cloud player By David LinthicumSep 19, 20257 mins
Artificial IntelligenceCloud ArchitectureCloud Computing
feature
How AI changes the data analyst role By Carl PerrySep 19, 20256 mins
AnalyticsBusiness AnalystCareers
news
Replit update sparks developers’ dissatisfaction over pricing By Anirban GhoshalSep 19, 20254 mins
Artificial IntelligenceDeveloper
video
Easier Chrome browser automation with PyDoll Sep 16, 20254 mins
Python
video
How to use Rust workspaces to speed up compile times Sep 9, 20253 mins
Python
video
Getting encryption wrong (and getting it right, too) Sep 2, 20257 mins
Python
Sponsored Links
Empower your cybersecurity team with expert insights from Palo Alto Networks.
Solve your most complex IT challenges with solutions that simplify your modernization journey.
Secure AI by Design: Unleash the power of AI and keep applications, usage and data secure.
About
About Us
Advertise
Contact Us
Editorial Ethics Policy
Foundry Careers
Reprints
Newsletters
BrandPosts
Policies
Terms of Service
Privacy Policy
Cookie Policy
Copyright Notice
Member Preferences
About AdChoices
Your California Privacy Rights
Privacy Settings
Our Network
CIO
Computerworld
CSO
Network World
FacebookXYouTubeGoogle NewsLinkedIn
© 2025
FoundryCo, Inc. All Rights Reserved.