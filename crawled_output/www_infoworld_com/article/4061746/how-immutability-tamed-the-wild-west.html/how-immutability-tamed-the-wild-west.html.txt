How immutability tamed the Wild West | InfoWorld
Topics
Spotlight: IT CareersVideosNewslettersResources
AboutAbout UsAdvertiseContact UsEditorial Ethics PolicyFoundry CareersNewslettersContribute to InfoWorldReprintsPoliciesTerms of ServicePrivacy PolicyCookie PolicyCopyright NoticeMember PreferencesAbout AdChoicesYour California Privacy RightsOur NetworkCIOComputerworldCSONetwork WorldMoreNewsFeaturesBlogsBrandPostsEventsVideosEnterprise Buyer’s Guides
Close
AnalyticsArtificial IntelligenceGenerative AICareersCloud ComputingData ManagementDatabasesEmerging TechnologyTechnology IndustrySecuritySoftware Development Microsoft .NETDevelopment ToolsDevopsOpen SourceProgramming LanguagesJavaJavaScriptPythonIT LeadershipEnterprise Buyer’s Guides
Back
Close
Back
Close
Popular Topics
Artificial IntelligenceCloud ComputingData ManagementSoftware Development
Search
Topics
Spotlight: IT CareersVideosNewslettersResourcesAboutPoliciesOur NetworkMore
Back
Topics
AnalyticsArtificial IntelligenceGenerative AICareersCloud ComputingData ManagementDatabasesEmerging TechnologyTechnology IndustrySecuritySoftware DevelopmentMicrosoft .NETDevelopment ToolsDevopsOpen SourceProgramming LanguagesJavaJavaScriptPythonIT LeadershipEnterprise Buyer’s Guides
Back
AboutAbout UsAdvertiseContact UsEditorial Ethics PolicyFoundry CareersNewslettersContribute to InfoWorldReprints
Back
PoliciesTerms of ServicePrivacy PolicyCookie PolicyCopyright NoticeMember PreferencesAbout AdChoicesYour California Privacy Rights
Back
Our NetworkCIOComputerworldCSONetwork World
Back
MoreNewsFeaturesBlogsBrandPostsEventsVideosEnterprise Buyer’s Guides
Home
Blogs
Rubber Duck Reflections
How immutability tamed the Wild West
by									Nick Hodges
How immutability tamed the Wild West
opinion
Sep 24, 20255 minsCareersDeveloperSoftware Development
Once upon a time, everything was a global variable. Immutability and pure functions delivered us from the chaos.
Credit: 															Jeanne Provost / Shutterstock
When I started coding in the 1970s, I used BASIC. I remember discovering the cool new language feature called GOSUB that let you jump around easily in code and then return to where you had previously been. What a revelation!
The language at the time had variables—but no constants. Parameters were not a thing—we had GOSUB!—and the notion of scope was completely unheard of. Everything was a global variable. Wild, right?
Immutability is the exact opposite of those Wild West days. Instead of “anything goes,” we get “tie everything down and nothing will slide around the back of the stage coach.”
And the notion of a constant was bizarre. I remember wondering why you’d ever want something like that when I learned about the idea.
Even today, the notion of immutability is often given short shrift—a hangover from years gone by? But we now realize that all systems grow incredibly complex, and that immutability is a cornerstone of good, clean code. Today we have large, complex, multi-threaded applications that make the old way of thinking very troublesome.
Change is bad
One of the first lessons that a new programmer should learn is that global variables are a crime against all that is good and just. If a variable is passed around like a football, and its state can change anywhere along the way, then its state will change along the way. Naturally, this leads to hair pulling and frustration. Global variables create coupling, and deep and broad coupling is the true crime against the profession.
At first, immutability seems kind of crazy—why eliminate variables? Of course things need to change! How the heck am I going to keep track of the number of items sold or the running total of an order if I can’t change anything?
Think of ordering a pizza. If you ask for a slice of pepperoni, you want it baked that way from scratch. You don’t want the cook taking yesterday’s veggie slice, scraping off the mushrooms, tossing on pepperoni, and reheating it. That’s gross. Variables and functions should work the same way. Don’t recycle the old slice, just give me a fresh one every time. You don’t want a changed slice—you want a new one.
Immutability is a powerful mental shift. Your mind needs to go from “change what is there” to “make a fresh, new thing without changing the old.” It is the idea that instead of editing what’s already there, you always make something new. That simple shift makes code safer and easier to reason about.
Pure functions are good
The key to immutability is understanding the notion of a pure function. A pure function is one that always returns the same output for a given input. Pure functions are said to be deterministic, in that the output is 100% predictable based on the input. In simpler terms, a pure function is a function with no side effects. It will never change something behind your back.
We’ve all had this experience:
function addPie(items: string[]) {
items.push("Apple Pie"); // side effect!
return items;
}
const order = ["Burger", "Fries"];
const before = order;
const updated = addPie(order);
console.log("before:", before); // ["Burger", "Fries", "Apple Pie"] ← oops
console.log("updated:", updated); // ["Burger", "Fries", "Apple Pie"]
Note the addPie function, which is impure and thus has a side effect. It changes the items array you send it. As a result, the before reference changes as well. Not good—you might not expect that. When data is shared, being mutable turns everything into a moving target that is hard to hit.
But if the function provides immutability:
function addPieImmutable(items: string[]) {
return [...items, "Apple Pie"]; // no side effects, new array
}
const order = ["Burger", "Fries"];
const before = order;
const updated = addPieImmutable(order);
console.log("before:", before);
// ["Burger", "Fries"] stable
console.log("updated:", updated); // ["Burger", "Fries", "Apple Pie"]
Here, the before reference remains unchanged. Because instead of updating the order, we created a new one (updated).
Change happens
Now this is a trivial example, but you can see how in the second version, there can never be a race condition or a battle for data because the order itself never changes. Instead, the order is recreated. Immutability doesn’t mean nothing changes; it means values never change once created. You still “change” by rebinding a name to a new value.
The notion of a “before” and “after” state is critical if you want features like undo, audit tracing, and other things that require a complete history of state.
Back in the day, GOSUB was a mind-expanding concept. It seems so quaint today. Now, the big revelation is that immutability and pure functions help eliminate the surprises that those global variables wrought and bring consistency and reliability to our code.
Related content
news
Microsoft Marketplace opens for AI apps, agents By Paul Krill
Sep 25, 2025 2 mins
Generative AI
Microsoft .NET
Microsoft Azure
news
GitHub Copilot-backed app modernization available for Java, .NET By Paul Krill
Sep 25, 2025 1 min
Generative AI
GitHub
Java
how-to
Introduction to Java records: Simplified data-centric programming in Java By Rafael del Nero
Sep 25, 2025 10 mins
Java
Programming Languages
Software Development
analysis
Spec-driven AI coding with GitHub’s Spec Kit By Simon Bisson
Sep 25, 2025 9 mins
Artificial Intelligence
Development Tools
Software Development
Other Sections
Resources
Videos
Spotlight: IT Careers
by
Nick Hodges
Follow Nick Hodges on X
Follow Nick Hodges on LinkedIn
Nick has a BA in classical languages from Carleton College and an MS in information technology management from the Naval Postgraduate School. In his career, he has been a busboy, a cook, a caddie, a telemarketer (for which he apologizes), an office manager, a high school teacher, a naval intelligence officer, a software developer, a product manager, and a software development manager. In addition, he is a former Delphi Product Manager and Delphi R&D Team Manager and the author of Coding in Delphi. He is a passionate Minnesota sports fan—especially the Timberwolves—as he grew up and went to college in the Land of 10,000 Lakes. He currently lives in West Chester, PA.
More from this author
opinionSoftware developers aren’t buying it Sep 17, 2025 5 minsopinionSix hard truths for software development bosses Sep 10, 2025 5 minsopinionSeven little habits for writing better code Sep 3, 2025 7 minsopinionThe discipline of great code Aug 27, 2025 4 minsopinionYour code is more strongly coupled than you think Aug 20, 2025 7 minsopinionFive ways your code is coupled, for better or worse Aug 13, 2025 8 minsopinionHow to measure coupled code Aug 6, 2025 4 minsopinionHow to write a good bug report Jul 30, 2025 6 mins
Show me morePopularArticlesVideos
feature
The best new features in Postgres 18 By Tom KincaidSep 25, 20256 mins
DatabasesPostgreSQLRelational Databases
news
Google releases MCP server to Data Commons public data sets By Paul KrillSep 24, 20252 mins
Artificial IntelligenceDevelopment ToolsGenerative AI
news
Open source registries signal shift toward paid models as AI strains infrastructure By Gyana SwainSep 24, 20255 mins
Artificial IntelligenceOpen Source
video
Python 3.14's live debugging interface Sep 23, 20254 mins
Python
video
Easier Chrome browser automation with PyDoll Sep 16, 20254 mins
Python
video
How to use Rust workspaces to speed up compile times Sep 9, 20253 mins
Python
Sponsored Links
Empower your cybersecurity team with expert insights from Palo Alto Networks.
Solve your most complex IT challenges with solutions that simplify your modernization journey.
Secure AI by Design: Unleash the power of AI and keep applications, usage and data secure.
About
About Us
Advertise
Contact Us
Editorial Ethics Policy
Foundry Careers
Reprints
Newsletters
BrandPosts
Policies
Terms of Service
Privacy Policy
Cookie Policy
Copyright Notice
Member Preferences
About AdChoices
Your California Privacy Rights
Privacy Settings
Our Network
CIO
Computerworld
CSO
Network World
FacebookXYouTubeGoogle NewsLinkedIn
© 2025
FoundryCo, Inc. All Rights Reserved.