(3/4) LLM: Inside the Transformer - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SREâ€”the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project â€” features, bugs, performance, self-hosting.
Crypto Forem
Follow
A collaborative community for all things Cryptoâ€”from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Jimin Lee
Posted on Sep 13
(3/4) LLM: Inside the Transformer
#deeplearning
#architecture
#ai
#llm
LLM (4 Part Series)
1
(1/4) LLM: How LLMs Became the Bedrock of Modern AI
2
(2/4) LLM: Data, Transformers, and Relentless Compute
3
(3/4) LLM: Inside the Transformer
4
(4/4) LLM: In-Context Learning, Hype, and the Road Ahead
This post was written in April 2023, so some parts may now be a bit outdated. However, most of the key ideas about LLMs remain just as relevant today.
Encoder-Only, Decoder-Only
The full Encoderâ€“Decoder Transformer is powerful, but not everyone needs both halves. Researchers asked: What if we only used the encoder? What if we only used the decoder?
Encoder-Only
The most famous encoder-only model? BERT.
BERT keeps just the encoder stack. Sometimes all you need is a good representation of text (context vectors), not generation.
Great for classification tasks:
Is this review positive or negative?
Does this sentence contain a personâ€™s name?
Classification works on embeddings. Better embeddings â†’ better classifiers. BERT looks at text bidirectionally, encodes whole sentences, and produces rich representations. Plug them into a classifier and accuracy jumps.
Is BERT a language model? Strictly, no â€” it doesnâ€™t do auto-regressive next-word prediction. Itâ€™s trained as a masked language model (predict the missing word), which is different from traditional LMs.
Decoder-Only
On the other side: GPT.
GPT (GPT-2/3, ChatGPT, GPT-4â€¦) keeps only the decoder stack.
Why drop the encoder? If your goal is just next-word prediction â€” the pure LM task â€” you can feed the decoder with the text so far and let it continue auto-regressively.
Input: â€œThe flowers by the roadside are bloomingâ€
Decoder predicts: â€œbeautifully.â€
That prediction feeds back in, and generation continues.
This is why GPT and its cousins (LaMDA, PaLM, LLaMA, Claude, etc.) follow the decoder-only recipe. Itâ€™s the simplest and most direct way to scale LMs into generative engines.
Encoder + Decoder
Models like T5 and BART keep the full structure and shine at clear input â†’ output transformations (translation, summarization, etc.).
Encoder vs. Decoder
Historically, encoder-only exploded first (BERT) because many NLP tasks were classification-heavy. Decoder-only models initially looked like â€œnonsense generators.â€
Key difference:
Encoder-only models canâ€™t generate text.
Decoder-only models can â€” and with scale, their potential is enormous. Even classification can be reframed as generation (â€œThe review is â€¦ [positive/negative]â€).
Thatâ€™s why decoder-only LMs became the dominant LLMs.
A Long Tradition
Transformers didnâ€™t invent encoderâ€“decoder. Before 2017, RNNs/LSTMs/GRUs were the standard way to build it. Transformers replaced RNNs.
Biggest reason people cite: Self-Attention.
Why Do Transformers Work So Well? Self-Attention
Two concepts are central:
The Encoderâ€“Decoder structure
Self-Attention
Letâ€™s start with Attention itself.
Attention
Attention first showed up in RNN-based seq2seq models. Recall the pipeline:
Input â†’ Encoder â†’ Context â†’ Decoder â†’ Output
The decoder generates tokens one by one. Early models used a fixed Context for every step, but different output words need to â€œlook backâ€ at different parts of the input.
Example:
â€œë‚˜ëŠ” ì–´ì œ í•™êµì— ê°”ìŠµë‹ˆë‹¤.â€ â†’ â€œI went to school yesterday.â€
If the model could focus on ê°”ìŠµë‹ˆë‹¤ (went) and ì–´ì œ (yesterday) at the right time, it would more reliably pick â€œwentâ€ (past tense) over â€œgo.â€
Thatâ€™s Attention: at each step, re-weight which parts of the input matter most.
Self-Attention
Seq2seq Attention asks: Which parts of the source should I attend to while generating the target?
Self-Attention asks: Within a single sentence, which words should each word attend to?
Example:
â€œThe animal didnâ€™t cross the street because it was too tired.â€
Here, â€œitâ€ should link strongly to â€œanimalâ€, but also relates to â€œtired.â€
Why is this powerful for LMs?
To predict â€œbloomedâ€ in â€œThe flowers by the roadside â€¦ bloomed,â€ â€œflowersâ€ should get the highest weight.
To pick tense, â€œyesterdayâ€ matters more than â€œschool.â€
Self-Attention lets the model discover this automatically.
Multi-Head Self-Attention
Language has multiple relationship types:
Grammatical (subject â†” verb)
Semantic (animal â†” it)
Attributes (it â†” tired)
One attention map canâ€™t capture every view. The fix: run multiple attention heads in parallel, each with a different â€œview.â€
Under the hood, word embeddings are split into subspaces (chunks of numbers). Each head attends within a different subspace, encouraging different aspects (grammar, meaning, style) to emerge.
Instead of one spotlight, give the model a dozen flashlights, each shining on a different relationship.
Thatâ€™s the magic of Multi-Head Self-Attention â€” one of key reasons Transformers dethroned RNNs.
175B? 540B? What Do Parameter Counts Actually Mean?
Youâ€™ll often hear sizes like 175B (GPT-3) or 540B (PaLM). These are the number of parameters â€” the weights in the Transformer.
More parameters â†’ more capacity. Hence the popular (but flawed) shortcut:
Bigger model â†’ better performance.
In reality, performance depends on more than size:
How much data was used?
How high-quality was that data?
Were the hyperparameters tuned well?
How long (and how thoroughly) was the model trained?
So why do parameter counts dominate? Theyâ€™re easy to understand.
If someone asks, â€œWhich model is better, A or B?â€ you could unpack data quality, training steps, and optimizersâ€¦ or say:
â€œModel A is 70B. Model B is 200B. Model B is better.â€
Itâ€™s not necessarily true â€” but itâ€™s simple.
âš ï¸ Pro tip: If someone talks about model quality only in terms of parameter count, be cautious. They either donâ€™t fully understand, or theyâ€™re trying to sell you something.
Transformer in a Nutshell
Transformers were designed for Sequence-to-Sequence tasks.
The most common form is the Encoderâ€“Decoder structure.
Variants exist: Encoder-only (BERT), Decoder-only (GPT), Encoder+Decoder (T5, BART).
To generate language, you need a Decoder.
A core innovation is Self-Attention.
To capture different perspectives (grammar, semantics, style), Transformers use Multi-Head Self-Attention.
Compute Power
The last ingredient: compute.
LLMs wouldnâ€™t exist without massive progress in hardware and infrastructure:
GPUs (and TPUs) unlocked massively parallel training. GPUs were the rocket fuel of the deep learning boom, and today Nvidia still dominates with CUDA, optimized libraries, and cutting-edge hardware.
Parallel training techniques allow hundreds (or thousands) of GPUs to train a single model in sync.
Cloud infrastructure made it practical. Buying racks of GPUs is brutally expensive â€” and they start depreciating the moment you unbox them. Renting from AWS, Azure, or GCP lets teams scale without opening a hardware graveyard in the office.
In short: faster chips + smarter software + elastic cloud = the horsepower that makes LLMs possible.
Why LLMs Happened Now
Weâ€™ve walked through the three big ingredients:
Data: Web-scale text + self-supervised learning â†’ oceans of training material.
Algorithms: Transformers (self-attention, scalable stacks) replaced RNNs.
Compute: GPUs/TPUs + cloud infrastructure â†’ enough horsepower to train monster models.
Each piece alone wouldâ€™ve been impressive. Put together, they sparked a step-change.
A decade ago, we had:
Limited datasets (a few gigabytes at most).
Algorithms (RNNs, LSTMs) that struggled with long sequences.
GPUs that couldnâ€™t realistically handle 100B+ parameter models.
Today, we have:
Tens of terabytes of training data at our fingertips.
Transformer architectures that scale beautifully.
GPU/TPU clusters that can train trillion-parameter models.
No single breakthrough â€œinventedâ€ LLMs. It was the intersection of trends â€” data, algorithms, compute â€” that finally clicked into place.
Thatâ€™s why LLMs feel like they appeared â€œall of a sudden.â€ The truth is, researchers were laying the groundwork for years. The moment the three factors aligned, the field exploded.
And thatâ€™s where we are now: riding the wave of models that are bigger, smarter, and more capable than anyone thought possible five years ago.
In the next post, Iâ€™ll dive into zero-shot, few-shot, prompting, and the rest of the story.
LLM (4 Part Series)
1
(1/4) LLM: How LLMs Became the Bedrock of Modern AI
2
(2/4) LLM: Data, Transformers, and Relentless Compute
3
(3/4) LLM: Inside the Transformer
4
(4/4) LLM: In-Context Learning, Hype, and the Road Ahead
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
â€¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Jimin Lee
Follow
My name is Jimin.
Joined
Sep 13, 2025
More from Jimin Lee
(4/4) LLM: In-Context Learning, Hype, and the Road Ahead
#llm
#machinelearning
(2/4) LLM: Data, Transformers, and Relentless Compute
#data
#ai
#machinelearning
#llm
(1/4) LLM: How LLMs Became the Bedrock of Modern AI
#llm
#machinelearning
ğŸ’ DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community â€” A space to discuss and keep up software development and manage your software career
Home
DEV++
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem â€” the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community Â© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account