Control flow and error handling - JavaScript | MDN
Skip to main content
Skip to search
MDN
HTML
HTML: Markup language
HTML reference
Elements
Global attributes
Attributes
See allâ¦
HTML guides
Responsive images
HTML cheatsheet
Date & time formats
See allâ¦
Markup languages
SVG
MathML
XML
CSS
CSS: Styling language
CSS reference
Properties
Selectors
At-rules
Values & units
See allâ¦
CSS guides
Box model
Animations
Flexbox
Colors
See allâ¦
Layout cookbook
Column layouts
Centering an element
Card component
See allâ¦
JavaScript
JS
JavaScript: Scripting language
JS reference
Standard built-in objects
Expressions & operators
Statements & declarations
Functions
See allâ¦
JS guides
Control flow & error handing
Loops and iteration
Working with objects
Using classes
See allâ¦
Web APIs
Web APIs: Programming interfaces
Web API reference
File system API
Fetch API
Geolocation API
HTML DOM API
Push API
Service worker API
See allâ¦
Web API guides
Using the Web animation API
Using the Fetch API
Working with the History API
Using the Web speech API
Using web workers
All
All web technology
Technologies
Accessibility
HTTP
URI
Web extensions
WebAssembly
WebDriver
See allâ¦
Topics
Media
Performance
Privacy
Security
Progressive web apps
Learn
Learn web development
Frontend developer course
Getting started
Common questions
Curriculum
Learn HTML
Introduction to HTML
Getting started with HTML
Learn CSS
What is CSS
Getting started with CSS
Learn JavaScript
How to use data attributes
Add JavaScript to your web page
Tools
Discover our tools
Playground
HTTP Observatory
Border-image generator
Border-radius generator
Box-shadow generator
Color mixer
Color picker
Shape generator
About
Get to know MDN better
About MDN
Advertise with us
Community
MDN on GitHub
Blog
Web
JavaScript
Guide
Control flow and error handling
Control flow and error handling
Previous
Next
JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.
The JavaScript reference
contains exhaustive details about the statements in this chapter. The semicolon
(;) character is used to separate statements in JavaScript code.
Any JavaScript expression is also a statement.
See Expressions and operators
for complete information about expressions.
In this article
Block statementConditional statementsException handling statements
Block statement
The most basic statement is a block statement, which is used to group
statements. The block is delimited by a pair of curly braces:
js{
statement1;
statement2;
// â¦
statementN;
}
Example
Block statements are commonly used with control flow statements (if,
for, while).
jswhile (x < 10) {
x++;
}
Here, { x++; } is the block statement.
Note:
var-declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:
jsvar x = 1;
{
var x = 2;
}
console.log(x); // 2
This outputs 2 because the var x statement within the block is in the same scope as the var x statement before the block. (In C or Java, the equivalent code would have output 1.)
This scoping effect can be mitigated by using let or const.
Conditional statements
A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: if...else and
switch.
if...else statement
Use the if statement to execute a statement if a logical condition is
true. Use the optional else clause to execute a statement if
the condition is false.
An if statement looks like this:
jsif (condition) {
statement1;
} else {
statement2;
}
Here, the condition can be any expression that evaluates to
true or false. (See Boolean
for an explanation of what evaluates to true and false.)
If condition evaluates to true,
statement1 is executed. Otherwise,
statement2 is executed. statement1 and
statement2 can be any statement, including further nested
if statements.
You can also compound the statements using else if to have multiple
conditions tested in sequence, as follows:
jsif (condition1) {
statement1;
} else if (condition2) {
statement2;
} else if (conditionN) {
statementN;
} else {
statementLast;
}
In the case of multiple conditions, only the first logical condition which evaluates to
true will be executed. To execute multiple statements, group them within a
block statement ({ /* â¦ */ }).
Best practice
In general, it's good practice to always use block statementsâespecially when
nesting if statements:
jsif (condition) {
// Statements for when condition is true
// â¦
} else {
// Statements for when condition is false
// â¦
}
In general it's good practice to not have an if...else with an assignment like x = y as a condition:
jsif (x = y) {
// statements here
}
However, in the rare case you find yourself wanting to do something like that, the while documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.
Falsy values
The following values evaluate to false (also known as Falsy values):
false
undefined
null
0
NaN
the empty string ("")
All other valuesâincluding all objectsâevaluate to true when passed to a
conditional statement.
Note:
Do not confuse the primitive boolean values
true and false with the true and false values of the
Boolean object!
For example:
jsconst b = new Boolean(false);
if (b) {
// this condition evaluates to true
}
if (b == true) {
// this condition evaluates to false
}
Example
In the following example, the function checkData returns true
if the number of characters in a Text object is three. Otherwise, it
displays an alert and returns false.
jsfunction checkData() {
if (document.form1.threeChar.value.length === 3) {
return true;
}
alert(
`Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
);
return false;
}
switch statement
A switch statement allows a program to evaluate an expression and attempt
to match the expression's value to a case label. If a match is found, the
program executes the associated statement.
A switch statement looks like this:
jsswitch (expression) {
case label1:
statements1;
break;
case label2:
statements2;
break;
// â¦
default:
statementsDefault;
}
JavaScript evaluates the above switch statement as follows:
The program first looks for a case clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.
If no matching label is found, the program looks for the optional
default clause:
If a default clause is found, the program transfers control to that
clause, executing the associated statements.
If no default clause is found, the program resumes execution at the
statement following the end of switch.
(By convention, the default clause is written as the last clause,
but it does not need to be so.)
break statements
The optional break statement associated with each case clause
ensures that the program breaks out of switch once the matched statement is
executed, and then continues execution at the statement following switch.
If break is omitted, the program continues execution inside the
switch statement (and will execute statements under the next case, and so on).
Example
In the following example, if fruitType evaluates to
"Bananas", the program matches the value with case "Bananas"
and executes the associated statement. When break is encountered, the
program exits the switch and continues execution from the statement
following switch. If break were omitted, the statement for
case "Cherries" would also be executed.
jsswitch (fruitType) {
case "Oranges":
console.log("Oranges are $0.59 a pound.");
break;
case "Apples":
console.log("Apples are $0.32 a pound.");
break;
case "Bananas":
console.log("Bananas are $0.48 a pound.");
break;
case "Cherries":
console.log("Cherries are $3.00 a pound.");
break;
case "Mangoes":
console.log("Mangoes are $0.56 a pound.");
break;
case "Papayas":
console.log("Papayas are $2.79 a pound.");
break;
default:
console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
Exception handling statements
You can throw exceptions using the throw statement and handle them using
the try...catch statements.
throw statement
try...catch statement
Exception types
Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:
ECMAScript exceptions
DOMException
throw statement
Use the throw statement to throw an exception. A throw
statement specifies the value to be thrown:
jsthrow expression;
You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:
jsthrow "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
toString() {
return "I'm an object!";
},
};
try...catch statement
The try...catch statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the try...catch statement catches it.
The try...catch statement consists of a try block, which
contains one or more statements, and a catch block, containing statements
that specify what to do if an exception is thrown in the try block.
In other words, you want the try block to succeedâbut if it does not, you
want control to pass to the catch block. If any statement within the
try block (or in a function called from within the try block)
throws an exception, control immediately shifts to the catch
block. If no exception is thrown in the try block, the catch
block is skipped. The finally block executes after the try and
catch blocks execute but before the statements following the
try...catch statement.
The following example uses a try...catch statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(1 â 12), an exception is thrown with the value
'InvalidMonthNo' and the statements in the catch block set the
monthName variable to 'unknown'.
jsfunction getMonthName(mo) {
mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
// prettier-ignore
const months = [
"Jan", "Feb", "Mar", "Apr", "May", "Jun",
"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
];
if (!months[mo]) {
throw new Error("Invalid month code"); // throw keyword is used here
}
return months[mo];
}
try {
// statements to try
monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
monthName = "unknown";
logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
The catch block
You can use a catch block to handle all exceptions that may be generated
in the try block.
jscatch (exception) {
statements
}
The catch block specifies an identifier (exception
in the preceding syntax) that holds the value specified by the throw
statement. You can use this identifier to get information about the exception that was
thrown.
JavaScript creates this identifier when the catch block is entered. The
identifier lasts only for the duration of the catch block. Once the
catch block finishes executing, the identifier no longer exists.
For example, the following code throws an exception. When the exception occurs, control
transfers to the catch block.
jstry {
throw "myException"; // generates an exception
} catch (err) {
// statements to handle any exceptions
logMyErrors(err); // pass exception object to error handler
}
Note:
When logging errors to the console inside
a catch block, using console.error() rather than
console.log() is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.
The finally block
The finally block contains statements to be executed after the
try and catch blocks execute. Additionally, the
finally block executes before the code that follows the
try...catch...finally statement.
It is also important to note that the finally block will execute
whether or not an exception is thrown. If an exception is thrown, however, the
statements in the finally block execute even if no catch block
handles the exception that was thrown.
You can use the finally block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.
The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the finally block closes the file before the script fails.
Using finally here ensures that the file is never left open, even
if an error occurs.
jsopenMyFile();
try {
writeMyFile(theData); // This may throw an error
} catch (e) {
handleError(e); // If an error occurred, handle it
} finally {
closeMyFile(); // Always close the resource
}
If the finally block returns a value, this value becomes the return value
of the entire try...catch...finally production, regardless of any
return statements in the try and catch blocks:
jsfunction f() {
try {
console.log(0);
throw "bogus";
} catch (e) {
console.log(1);
// This return statement is suspended
// until finally block has completed
return true;
console.log(2); // not reachable
} finally {
console.log(3);
return false; // overwrites the previous "return"
// `f` exits here
console.log(4); // not reachable
}
console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
Overwriting of return values by the finally block also applies to
exceptions thrown or re-thrown inside of the catch block:
jsfunction f() {
try {
throw "bogus";
} catch (e) {
console.log('caught inner "bogus"');
// This throw statement is suspended until
// finally block has completed
throw e;
} finally {
return false; // overwrites the previous "throw"
// `f` exits here
}
}
try {
console.log(f());
} catch (e) {
// this is never reached!
// while f() executes, the `finally` block returns false,
// which overwrites the `throw` inside the above `catch`
console.log('caught outer "bogus"');
}
// Logs:
// caught inner "bogus"
// false
Nesting try...catch statements
You can nest one or more try...catch statements.
If an inner try block does not have a corresponding
catch block:
it must contain a finally block, and
the enclosing try...catch statement's catch block is
checked for a match.
For more information, see nested try-blocks
on the try...catch
reference page.
Utilizing Error objects
Depending on the type of error, you may be able to use the name and
message properties to get a more refined message.
The name property provides the general class of Error (such
as DOMException or Error), while message
generally provides a more succinct message than one would get by converting the error
object to a string.
If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your catch block doesn't discriminate between your own
exceptions and system ones), you can use the Error constructor.
For example:
jsfunction doSomethingErrorProne() {
if (ourCodeMakesAMistake()) {
throw new Error("The message");
}
doSomethingToGetAJavaScriptError();
}
try {
doSomethingErrorProne();
} catch (e) {
// Now, we actually use `console.error()`
console.error(e.name); // 'Error'
console.error(e.message); // 'The message', or a JavaScript error message
}
Previous
Next
Help improve MDN
Learn how to contribute
This page was last modified on â¨Aug 5, 2025â© by MDN contributors.
View this page on GitHub â¢ Report a problem with this content
JavaScriptTutorials and guidesBeginner's tutorialsYour first website: Adding interactivityDynamic scripting with JavaScriptJavaScript frameworks and librariesJavaScript GuideIntroductionGrammar and typesControl flow and error handlingLoops and iterationFunctionsExpressions and operatorsNumbers and stringsRepresenting dates & timesRegular expressionsIndexed collectionsKeyed collectionsWorking with objectsUsing classesUsing promisesJavaScript typed arraysIterators and generatorsResource managementInternationalizationJavaScript modulesIntermediateAdvanced JavaScript objectsAsynchronous JavaScriptClient-side web APIsLanguage overviewJavaScript data structuresEquality comparisons and samenessEnumerability and ownership of propertiesClosuresAdvancedInheritance and the prototype chainMeta programmingMemory ManagementReferencesBuilt-in objectsAggregateErrorArrayArrayBufferAsyncDisposableStackAsyncFunctionAsyncGeneratorAsyncGeneratorFunctionAsyncIteratorAtomicsBigIntBigInt64ArrayBigUint64ArrayBooleanDataViewDatedecodeURI()decodeURIComponent()DisposableStackencodeURI()encodeURIComponent()Errorescape()
Deprecated
eval()EvalErrorFinalizationRegistryFloat16ArrayFloat32ArrayFloat64ArrayFunctionGeneratorGeneratorFunctionglobalThisInfinityInt8ArrayInt16ArrayInt32ArrayInternalError
Non-standard
IntlisFinite()isNaN()IteratorJSONMapMathNaNNumberObjectparseFloat()parseInt()PromiseProxyRangeErrorReferenceErrorReflectRegExpSetSharedArrayBufferStringSuppressedErrorSymbolSyntaxErrorTemporal
Experimental
TypedArrayTypeErrorUint8ArrayUint8ClampedArrayUint16ArrayUint32Arrayundefinedunescape()
Deprecated
URIErrorWeakMapWeakRefWeakSetExpressions & operatorsAddition (+)Addition assignment (+=)Assignment (=)async function expressionasync function* expressionawaitBitwise AND (&)Bitwise AND assignment (&=)Bitwise NOT (~)Bitwise OR (|)Bitwise OR assignment (|=)Bitwise XOR (^)Bitwise XOR assignment (^=)class expressionComma operator (,)Conditional (ternary) operatorDecrement (--)deleteDestructuringDivision (/)Division assignment (/=)Equality (==)Exponentiation (**)Exponentiation assignment (**=)function expressionfunction* expressionGreater than (>)Greater than or equal (>=)Grouping operator ( )import.metaimport.meta.resolve()import()inIncrement (++)Inequality (!=)instanceofLeft shift (<<)Left shift assignment (<<=)Less than (<)Less than or equal (<=)Logical AND (&&)Logical AND assignment (&&=)Logical NOT (!)Logical OR (||)Logical OR assignment (||=)Multiplication (*)Multiplication assignment (*=)newnew.targetnullNullish coalescing assignment (??=)Nullish coalescing operator (??)Object initializerOperator precedenceOptional chaining (?.)Property accessorsRemainder (%)Remainder assignment (%=)Right shift (>>)Right shift assignment (>>=)Spread syntax (...)Strict equality (===)Strict inequality (!==)Subtraction (-)Subtraction assignment (-=)superthistypeofUnary negation (-)Unary plus (+)Unsigned right shift (>>>)Unsigned right shift assignment (>>>=)void operatoryieldyield*Statements & declarationsasync functionasync function*await usingBlock statementbreakclassconstcontinuedebuggerdo...whileEmpty statementexportExpression statementforfor await...offor...infor...offunctionfunction*if...elseimportImport attributesLabeled statementletreturnswitchthrowtry...catchusingvarwhilewith
Deprecated
FunctionsArrow function expressionsDefault parametersgetMethod definitionsRest parameterssetThe arguments object[Symbol.iterator]()callee
Deprecated
lengthClassesconstructorextendsPrivate elementsPublic class fieldsstaticStatic initialization blocksRegular expressionsBackreference: \1, \2Capturing group: (...)Character class escape: \d, \D, \w, \W, \s, \SCharacter class: [...], [^...]Character escape: \n, \u{...}Disjunction: |Input boundary assertion: ^, $Literal character: a, bLookahead assertion: (?=...), (?!...)Lookbehind assertion: (?<=...), (?<!...)Modifier: (?ims-ims:...)Named backreference: \k<name>Named capturing group: (?<name>...)Non-capturing group: (?:...)Quantifier: *, +, ?, {n}, {n,}, {n,m}Unicode character class escape: \p{...}, \P{...}Wildcard: .Word boundary assertion: \b, \BErrorsAggregateError: No Promise in Promise.any was resolvedError: Permission denied to access property "x"InternalError: too much recursionRangeError: argument is not a valid code pointRangeError: BigInt division by zeroRangeError: BigInt negative exponentRangeError: form must be one of 'NFC', 'NFD', 'NFKC', or 'NFKD'RangeError: invalid array lengthRangeError: invalid dateRangeError: precision is out of rangeRangeError: radix must be an integerRangeError: repeat count must be less than infinityRangeError: repeat count must be non-negativeRangeError: x can't be converted to BigInt because it isn't an integerReferenceError: "x" is not definedReferenceError: assignment to undeclared variable "x"ReferenceError: can't access lexical declaration 'X' before initializationReferenceError: must call super constructor before using 'this' in derived class constructorReferenceError: super() called twice in derived class constructorSyntaxError: 'arguments'/'eval' can't be defined or assigned to in strict mode codeSyntaxError: "0"-prefixed octal literals are deprecatedSyntaxError: "use strict" not allowed in function with non-simple parametersSyntaxError: "x" is a reserved identifierSyntaxError: \ at end of patternSyntaxError: a declaration in the head of a for-of loop can't have an initializerSyntaxError: applying the 'delete' operator to an unqualified name is deprecatedSyntaxError: arguments is not valid in fieldsSyntaxError: await is only valid in async functions, async generators and modulesSyntaxError: await/yield expression can't be used in parameterSyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressionsSyntaxError: character class escape cannot be used in class range in regular expressionSyntaxError: continue must be inside loopSyntaxError: duplicate capture group name in regular expressionSyntaxError: duplicate formal argument xSyntaxError: for-in loop head declarations may not have initializersSyntaxError: function statement requires a nameSyntaxError: functions cannot be labelledSyntaxError: getter and setter for private name #x should either be both static or non-staticSyntaxError: getter functions must have no argumentsSyntaxError: identifier starts immediately after numeric literalSyntaxError: illegal characterSyntaxError: import declarations may only appear at top level of a moduleSyntaxError: incomplete quantifier in regular expressionSyntaxError: invalid assignment left-hand sideSyntaxError: invalid BigInt syntaxSyntaxError: invalid capture group name in regular expressionSyntaxError: invalid character in class in regular expressionSyntaxError: invalid class set operation in regular expressionSyntaxError: invalid decimal escape in regular expressionSyntaxError: invalid identity escape in regular expressionSyntaxError: invalid named capture reference in regular expressionSyntaxError: invalid property name in regular expressionSyntaxError: invalid range in character classSyntaxError: invalid regexp groupSyntaxError: invalid regular expression flag "x"SyntaxError: invalid unicode escape in regular expressionSyntaxError: JSON.parse: bad parsingSyntaxError: label not foundSyntaxError: missing : after property idSyntaxError: missing ) after argument listSyntaxError: missing ) after conditionSyntaxError: missing ] after element listSyntaxError: missing } after function bodySyntaxError: missing } after property listSyntaxError: missing = in const declarationSyntaxError: missing formal parameterSyntaxError: missing name after . operatorSyntaxError: missing variable nameSyntaxError: negated character class with strings in regular expressionSyntaxError: new keyword cannot be used with an optional chainSyntaxError: nothing to repeatSyntaxError: numbers out of order in {} quantifier.SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode codeSyntaxError: parameter after rest parameterSyntaxError: private fields can't be deletedSyntaxError: property name __proto__ appears more than once in object literalSyntaxError: raw bracket is not allowed in regular expression with unicode flagSyntaxError: redeclaration of formal parameter "x"SyntaxError: reference to undeclared private field or method #xSyntaxError: rest parameter may not have a defaultSyntaxError: return not in functionSyntaxError: setter functions must have one argumentSyntaxError: string literal contains an unescaped line breakSyntaxError: super() is only valid in derived class constructorsSyntaxError: tagged template cannot be used with optional chainSyntaxError: Unexpected '#' used outside of class bodySyntaxError: Unexpected tokenSyntaxError: unlabeled break must be inside loop or switchSyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'SyntaxError: use of super property/member accesses only valid within methods or eval code within methodsSyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# insteadTypeError: 'caller', 'callee', and 'arguments' properties may not be accessedTypeError: 'x' is not iterableTypeError: "x" is (not) "y"TypeError: "x" is not a constructorTypeError: "x" is not a functionTypeError: "x" is not a non-null objectTypeError: "x" is read-onlyTypeError: already executing generatorTypeError: BigInt value can't be serialized in JSONTypeError: calling a builtin X constructor without new is forbiddenTypeError: can't access/set private field or method: object is not the right classTypeError: can't assign to property "x" on "y": not an objectTypeError: can't convert BigInt to numberTypeError: can't convert x to BigIntTypeError: can't define property "x": "obj" is not extensibleTypeError: can't delete non-configurable array elementTypeError: can't redefine non-configurable property "x"TypeError: can't set prototype of this objectTypeError: can't set prototype: it would cause a prototype chain cycleTypeError: cannot use 'in' operator to search for 'x' in 'y'TypeError: class constructors must be invoked with 'new'TypeError: cyclic object valueTypeError: derived class constructor returned invalid value xTypeError: getting private setter-only propertyTypeError: Initializing an object twice is an error with private fields/methodsTypeError: invalid 'instanceof' operand 'x'TypeError: invalid Array.prototype.sort argumentTypeError: invalid assignment to const "x"TypeError: Iterator/AsyncIterator constructor can't be used directlyTypeError: matchAll/replaceAll must be called with a global RegExpTypeError: More arguments neededTypeError: null/undefined has no propertiesTypeError: property "x" is non-configurable and can't be deletedTypeError: Reduce of empty array with no initial valueTypeError: setting getter-only property "x"TypeError: WeakSet key/WeakMap value 'x' must be an object or an unregistered symbolTypeError: X.prototype.y called on incompatible typeURIError: malformed URI sequenceWarning: -file- is being assigned a //# sourceMappingURL, but already has oneWarning: unreachable code after return statementMiscJavaScript technologies overviewExecution modelLexical grammarIteration protocolsStrict modeTemplate literalsTrailing commasDeprecated features
Your blueprint for a better internet.
MDN
About
Blog
Mozilla careers
Advertise with us
MDN Plus
Product help
Contribute
MDN Community
Community resources
Writing guidelines
MDN Discord
MDN on GitHub
Developers
Web technologies
Learn web development
Guides
Tutorials
Glossary
Hacks blog
Website Privacy Notice
Cookies
Legal
Community Participation Guidelines
Visit Mozilla Corporationâs not-for-profit parent, the Mozilla Foundation.
Portions of this content are Â©1998ââ¨2025â© by individual mozilla.org contributors. Content available under a Creative Commons license.