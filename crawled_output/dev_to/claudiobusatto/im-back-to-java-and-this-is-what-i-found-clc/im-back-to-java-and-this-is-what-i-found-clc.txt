I'm back to Java, and this is what I found (so far) - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
DUMB DEV Community
Follow
Memes and software development shitposting
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SREâ€”the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project â€” features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Cryptoâ€”from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Claudio Busatto
Posted on Sep 23
I'm back to Java, and this is what I found (so far)
#java
#programming
#development
#coding
Working with Java is a canonical moment in the career of a backend engineer, eventually you will see yourself opening Intellij (or Eclipse) and facing the beauty of XML files Java classes. The last time I worked professionally with Java was when the classical version 8 was released. After that, multiple companies moved their backend development from C# and Java to Node.js, so did I. Although the environment was different, I always had the feeling that I was working in some sort of Springboot lite version. Check it out this example of an inversify controller, you will understand me.
@controller("/foo")
export class FooController implements Controller {
constructor(
@inject("FooService")
private fooService: FooService
) {}
@httpGet("/")
private index(
@request() req: Request,
@response() res: Response,
@next() next: NextFunction): string {
return this.fooService.get(req.query.id);
}
}
Enter fullscreen mode
Exit fullscreen mode
Now, new projects require me to code in Java again and I decided to write some articles to share my experience of (re)learning Java.
This post is about two features that really caught my attention when checking the updates of Java 17: sealed classes and pattern matching.
Java 17: Regaining Control with Sealed Classes
Java 17 introduced Sealed Classes, which let you explicitly restrict which other classes can extend or implement a particular class or interface. This gives you more control over class hierarchies, which can improve code clarity, maintainability, and safety. For example, you can define a PaymentMethod and specify that it can only be extended/implemented by defined payment methods classes preventing other, unauthorized classes from inheriting from it. It becomes incredibly useful for modeling a finite set of possibilities in a domain.
// The sealed interface 'PaymentMethod' permits a finite set of implementations.
public sealed interface PaymentMethod permits CreditCardPayment, PayPalPayment, BankTransferPayment {}
// A final class for credit card payments.
public final class CreditCardPayment implements PaymentMethod {
private final String cardNumber;
private final String cardHolderName;
public CreditCardPayment(String cardNumber, String cardHolderName) {
this.cardNumber = cardNumber;
this.cardHolderName = cardHolderName;
}
public String getCardNumber() {
return cardNumber;
}
public String getCardHolderName() {
return cardHolderName;
}
}
// A final class for PayPal payments.
public final class PayPalPayment implements PaymentMethod {
private final String email;
public PayPalPayment(String email) {
this.email = email;
}
public String getEmail() {
return email;
}
}
// A final class for bank transfer payments.
public final class BankTransferPayment implements PaymentMethod {
private final String accountNumber;
private final String routingNumber;
public BankTransferPayment(String accountNumber, String routingNumber) {
this.accountNumber = accountNumber;
this.routingNumber = routingNumber;
}
public String getAccountNumber() {
return accountNumber;
}
public String getRoutingNumber() {
return routingNumber;
}
}
Enter fullscreen mode
Exit fullscreen mode
This setup guarantees that any PaymentMethod object you work with must be one of CreditCardPayment, PayPalPayment, or BankTransferPayment. If a developer tries to create a new class that implements PaymentMethod but isn't one of the three permitted classes, the compiler will produce an error. While this might seem unnecessary in a small example, the ability to restrict who can implement or extend a class is incredibly useful for controlling and managing how your codebase grows.
Java 17: Pattern Matching for Switch
In Java 8, if you implemented a strategy pattern once you probably saw a code like this one:
public class PaymentProcessor {
public void process(PaymentMethod paymentMethod) {
if (payment instanceof CreditCardPayment) {
System.out.println("Processing credit card payment for " + creditCard.getCardHolderName());
// Logic for processing a credit card
} else if (paymentMethod instanceof PayPalPayment) {
System.out.println("Processing PayPal payment for " + payPal.getEmail());
// Logic for processing a PayPal transaction
} else if (paymentMethod instanceof BankTransferPayment) {
System.out.println("Processing bank transfer to account " + bankTransfer.getAccountNumber());
// Logic for handling a bank transfer
} else {
// In this case we need to add a "default" handler as
// the compiler cannot know all the possible methods
throw new IllegalArgumentException("Unknown shape type");
}
}
}
Enter fullscreen mode
Exit fullscreen mode
Version 17 adds a Pattern Matching for switch, which allows patterns to be used in case labels, making code more concise and readable. The feature eliminates the need for explicit type casting after an instanceof check and can be used to handle different types of objects in a single switch statement.
The sealed interface is extremely powerful when combined with pattern matching for switch. You can write your logic without the boilerplate of an if-else chain.
public class PaymentProcessor {
public void process(PaymentMethod paymentMethod) {
switch (paymentMethod) {
case CreditCardPayment creditCard -> {
System.out.println("Processing credit card payment for " + creditCard.getCardHolderName());
// Logic for processing a credit card
}
case PayPalPayment payPal -> {
System.out.println("Processing PayPal payment for " + payPal.getEmail());
// Logic for processing a PayPal transaction
}
case BankTransferPayment bankTransfer -> {
System.out.println("Processing bank transfer to account " + bankTransfer.getAccountNumber());
// Logic for handling a bank transfer
}
// No 'default' case is needed because the compiler knows all
// possible subclasses of 'PaymentMethod' are handled.
}
}
}
Enter fullscreen mode
Exit fullscreen mode
Because the PaymentMethod interface is sealed, the Java compiler can analyze the switch statement and verify that all possible PaymentMethod types are covered. This provides compile-time safety, preventing bugs that could occur if a new, unhandled payment type were introduced. The compiler essentially guarantees that your code handles every valid scenario.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
â€¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Claudio Busatto
Follow
Lead Software Engineer @ Banxware GmbH
Joined
Oct 23, 2023
Trending on DEV Community
Hot
"Your Profile Doesn't Match the Role" and Other Interview Horror Stories
#watercooler
#career
#interview
#discuss
I built a voice AI agent to clean my emails, meetings, and Slack DMs (Composio, Vapi, OpenAI TTS) ðŸª„
#webdev
#programming
#ai
#javascript
The 90-Day Coding Routine That Made Me Think Like An Architect
#webdev
#programming
#ai
#discuss
ðŸ’Ž DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community â€” A space to discuss and keep up software development and manage your software career
Home
Welcome Thread
Reading List
Tags
About
Contact
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem â€” the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community Â© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account