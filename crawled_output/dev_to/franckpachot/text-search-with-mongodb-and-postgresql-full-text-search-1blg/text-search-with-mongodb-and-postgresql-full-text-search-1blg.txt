Text Search with MongoDB and PostgreSQL - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SREâ€”the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project â€” features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Crypto Forem
Follow
A collaborative community for all things Cryptoâ€”from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Franck Pachot
Posted on Sep 19
Text Search with MongoDB and PostgreSQL
#database
#mongodb
#postgres
MongoDB Search Indexes provide fullâ€‘text search capabilities directly within MongoDB, allowing complex queries to be run without copying data to a separate search system. Initially deployed in Atlas, MongoDBâ€™s managed service, Search Indexes are now also part of the community edition. This post compares the default fullâ€‘text search behaviour between MongoDB and PostgreSQL, using a simple example to illustrate the ranking algorithm.
Setup: a small dataset
Iâ€™ve inserted nine small documents, each consisting of different fruits, using emojis to make it more visual. The ğŸ and ğŸ emojis represent our primary search terms. They appear at varying frequencies in documents of different lengths.
db.articles.deleteMany({});
db.articles.insertMany([
{ description : "ğŸ ğŸŒ ğŸŠ" },
// short, 1 ğŸ
{ description : "ğŸ ğŸŒ ğŸŠ" },
// short, 1 ğŸ
{ description : "ğŸ ğŸŒ ğŸŠ ğŸ" },
// larger, 2 ğŸ
{ description : "ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ" },
// larger, 1 ğŸ
{ description : "ğŸ ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ°" },
// large, 1 ğŸ
{ description : "ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ" },
// large, 6 ğŸ
{ description : "ğŸ ğŸŒ" },
// very short, 1 ğŸ
{ description : "ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ° ğŸ" },
// large, 1 ğŸ
{ description : "ğŸ ğŸ ğŸŒ ğŸŒ ğŸŒ" },
// shorter, 2 ğŸ
]);
Enter fullscreen mode
Exit fullscreen mode
To enable dynamic indexing, I created a MongoDB Search Index without specifying any particular field names:
db.articles.createSearchIndex("default",
{ mappings: { dynamic: true } }
);
Enter fullscreen mode
Exit fullscreen mode
I created the equivalent on PostgreSQL:
DROP TABLE IF EXISTS articles;
CREATE TABLE articles (
id BIGSERIAL PRIMARY KEY,
description TEXT
);
INSERT INTO articles(description) VALUES
('ğŸ ğŸŒ ğŸŠ'),
('ğŸ ğŸŒ ğŸŠ'),
('ğŸ ğŸŒ ğŸŠ ğŸ'),
('ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ'),
('ğŸ ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ°'),
('ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ'),
('ğŸ ğŸŒ'),
('ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ° ğŸ'),
('ğŸ ğŸ ğŸŒ ğŸŒ ğŸŒ');
Enter fullscreen mode
Exit fullscreen mode
Since text search needs multiple index entries for each row, I set up a GIN (Generalized Inverted Index) and use tsvector to extract and index the relevant tokens.
CREATE INDEX articles_fts_idx
ON articles USING GIN (to_tsvector('simple', description))
;
Enter fullscreen mode
Exit fullscreen mode
MongoDB Text Search (Lucene BM25):
I use my custom search index to find articles containing either ğŸ or ğŸ in their descriptions. The results are sorted by relevance score and displayed as follows:
db.articles.aggregate([
{ $search: { text: { query: ["ğŸ", "ğŸ"], path: "description" }, index: "default" } },
{ $project: { _id: 0, score: { $meta: "searchScore" }, description: 1 } },
{ $sort: { score: -1 } }
]).forEach( i=> print(i.score.toFixed(3).padStart(5, " "),i.description) )
Enter fullscreen mode
Exit fullscreen mode
Here are the results, presented in order of best to worst match:
1.024 ğŸ ğŸŒ ğŸŠ
0.132 ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ
0.107 ğŸ ğŸŒ ğŸŠ ğŸ
0.101 ğŸ ğŸ ğŸŒ ğŸŒ ğŸŒ
0.097 ğŸ ğŸŒ
0.088 ğŸ ğŸŒ ğŸŠ
0.073 ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ
0.059 ğŸ ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ°
0.059 ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ° ğŸ
Enter fullscreen mode
Exit fullscreen mode
All documents were retrieved by this search since each contains a red or green apple. However, they are assigned different scores:
Multiple appearances boost the score: When a document contains the search term more than once, its ranking increases compared to those with only a single appearance. That's why documents featuring several ğŸ are ranked higher than those containing only one.
Rarity outweighs quantity: When a term like ğŸ appears in every document, it has less impact than a rare term, such as ğŸ. Therefore, even if ğŸ only appears once, the document containing it ranks higher than others with multiple ğŸ. In this model, rarity carries more weight than mere frequency.
Diminishing returns on term frequency: Each extra occurrence of a term adds less to the relevance score. For instance, increasing ğŸ from one to six times (from ğŸ ğŸŒ to ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ) boosts the score, but not by a factor of six. The effect of term repetition diminishes as the count rises.
Document length matters: A term that appears only once is scored higher in a short document than in a long one. That's why ğŸ ğŸŒ ranks higher than ğŸ ğŸŒ ğŸŠ, which itself ranks higher than ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ.
MongoDB Atlas Search indexes are powered by Luceneâ€™s BM25 algorithm, a refinement of the classic TFâ€‘IDF model:
Term Frequency (TF): More occurrences of a term in a document increase its relevance score, but with diminishing returns.
Inverse Document Frequency (IDF): Terms that appear in fewer documents receive higher weighting.
Length Normalization: Matches in shorter documents contribute more to relevance than the same matches in longer documents.
To demonstrate the impact of IDF, I added several documents that do not contain any of the apples I'm searching for.
const fruits = [ "ğŸ","ğŸŠ","ğŸ‹","ğŸŒ","ğŸ‰","ğŸ‡","ğŸ“","ğŸ«",
"ğŸ¥","ğŸ¥­","ğŸ","ğŸ¥¥","ğŸˆ","ğŸ…","ğŸ¥‘","ğŸ†",
"ğŸ‹","ğŸ","ğŸ“","ğŸ‡","ğŸˆ","ğŸ¥­","ğŸ","ğŸ‘",
"ğŸ¥","ğŸ«","ğŸŒ","ğŸ‰","ğŸ¥¥","ğŸ¥‘","ğŸ¥¥","ğŸ" ];
function randomFruitSentence(min=3, max=8) {
const len = Math.floor(Math.random() * (max - min + 1)) + min;
return Array.from({length: len}, () => fruits[Math.floor(Math.random()*fruits.length)]).join(" ");
}
db.articles.insertMany(
Array.from({length: 500}, () => ({ description: randomFruitSentence() }))
);
db.articles.aggregate([
{ $search: { text: { query: ["ğŸ", "ğŸ"], path: "description" }, index: "default" } },
{ $project: { _id: 0, score: { $meta: "searchScore" }, description: 1 } },
{ $sort: { score: -1 } }
]).forEach( i=> print(i.score.toFixed(3).padStart(5, " "),i.description) )
3.365 ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ
3.238 ğŸ ğŸŒ ğŸŠ
2.760 ğŸ ğŸŒ ğŸŠ ğŸ
2.613 ğŸ ğŸ ğŸŒ ğŸŒ ğŸŒ
2.506 ğŸ ğŸŒ
2.274 ğŸ ğŸŒ ğŸŠ
1.919 ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ
1.554 ğŸ ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ°
1.554 ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ° ğŸ
Enter fullscreen mode
Exit fullscreen mode
Although the result set is unchanged, the score has increased and the frequency gap between ğŸ and ğŸ has narrowed. As a result, ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ now ranks higher than ğŸ ğŸŒ ğŸŠ, since the inverse document frequency (IDF) of ğŸ does not fully offset its term frequency (TF) within a single document. Crucially, changes made in other documents can influence the score of any given document, unlike in traditional indexes where changes in one document do not impact others' index entries.
PostgreSQL Text Search (TF only):
Here is the result in PostgreSQL:
SELECT ts_rank_cd(
to_tsvector('simple', description)
,
to_tsquery('simple', 'ğŸ | ğŸ')
) AS score, description
FROM articles
WHERE
to_tsvector('simple', description)
@@
to_tsquery('simple', 'ğŸ | ğŸ')
ORDER BY score DESC;
Enter fullscreen mode
Exit fullscreen mode
It retrieves the same documents, but with many having the same score, even with different patterns:
score |
description
-------+-------------------------
0.6 | ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ
0.2 | ğŸ ğŸŒ ğŸŠ ğŸ
0.2 | ğŸ ğŸ ğŸŒ ğŸŒ ğŸŒ
0.1 | ğŸ ğŸŒ ğŸŠ
0.1 | ğŸ ğŸŒ
0.1 | ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ° ğŸ
0.1 | ğŸ ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ°
0.1 | ğŸ ğŸŒ ğŸŠ
0.1 | ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ
(9 rows)
Enter fullscreen mode
Exit fullscreen mode
With PostgreSQL text search, only the term frequency (TF) matters, and is a direct multiplicator of the score: 6 apples ranks 3x higher than two, and 6x than one.
There's some possible normalization available with additiona flags:
SELECT ts_rank_cd(
to_tsvector('simple', description),
to_tsquery('simple', 'ğŸ | ğŸ')
,
0 -- (the default) ignores the document length
|
1 -- divides the rank by 1 + the logarithm of the document length
--
|
2 -- divides the rank by the document length
--
|
4 -- divides the rank by the mean harmonic distance between extents (this is implemented only by ts_rank_cd)
|
8 -- divides the rank by the number of unique words in document
--
| 16 -- divides the rank by 1 + the logarithm of the number of unique words in document
--
| 32 -- divides the rank by itself + 1
) AS score,
description
FROM articles
WHERE to_tsvector('simple', description) @@ to_tsquery('simple', 'ğŸ | ğŸ')
ORDER BY score DESC
;
score
|
description
-------------+-------------------------
0.308339 | ğŸ ğŸ ğŸ ğŸ ğŸ ğŸ
0.055811062 | ğŸ ğŸ ğŸŒ ğŸŒ ğŸŒ
0.04551196 | ğŸ ğŸŒ
0.04142233 | ğŸ ğŸŒ ğŸŠ ğŸ
0.024044918 | ğŸ ğŸŒ ğŸŠ
0.024044918 | ğŸ ğŸŒ ğŸŠ
0.018603688 | ğŸ ğŸŒ ğŸŠ ğŸŠ ğŸŠ
0.005688995 | ğŸ ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ°
0.005688995 | ğŸŒ ğŸŠ ğŸŒ´ ğŸ« ğŸˆ ğŸ‡ ğŸŒ° ğŸ
(9 rows)
Enter fullscreen mode
Exit fullscreen mode
This penalizes longer documents and those with more unique terms. Still, it doesn't consider other documents like IDF.
PostgreSQL Full Text Search scoring with ts_rank_cd is based on term frequency and proximity. It does not compute inverse document frequency, so scores do not change as the corpus changes. Normalization flags can penalize long documents or those with many unique terms, but they are length-based adjustments, not true IDF, like we have in TFâ€‘IDF or BM25â€‘style search engine.
ParadeDB with pg_search (Tantivy BM25)
PostgreSQL popularity is not only due to its features but also its extensibility and ecosystem. The pg_search extension adds functions and operators that use BM25 indexes (Tantivy, a Rust-based search library inspired by Lucene). It is easy to test with ParadeDB:
docker run --rm -it paradedb/paradedb bash
POSTGRES_PASSWORD=x docker-entrypoint.sh postgres &
psql -U postgres
Enter fullscreen mode
Exit fullscreen mode
The extension is installed in version 0.18.4:
postgres=# \dx
List of installed extensions
Name
| Version |
Schema
|
Description
------------------------+---------+------------+------------------------------------------------------------
fuzzystrmatch
| 1.2
| public
| determine similarities and distance between strings
pg_cron
| 1.6
| pg_catalog | Job scheduler for PostgreSQL
pg_ivm
| 1.9
| pg_catalog | incremental view maintenance on PostgreSQL
pg_search
| 0.18.4
| paradedb
| pg_search: Full text search for PostgreSQL using BM25
plpgsql
| 1.0
| pg_catalog | PL/pgSQL procedural language
postgis
| 3.6.0
| public
| PostGIS geometry and geography spatial types and functions
postgis_tiger_geocoder | 3.6.0
| tiger
| PostGIS tiger geocoder and reverse geocoder
postgis_topology
| 3.6.0
| topology
| PostGIS topology spatial types and functions
vector
| 0.8.0
| public
| vector data type and ivfflat and hnsw access methods
(9 rows)
Enter fullscreen mode
Exit fullscreen mode
I created and inserted the same as I did above on PostgreSQL and created the BM25 index:
CREATE INDEX search_idx ON articles
USING bm25 (id, description)
WITH (key_field='id')
;
Enter fullscreen mode
Exit fullscreen mode
We can query using the @@@ operator and rank with paradedb.score(id). Unlike PostgreSQLâ€™s builtâ€‘in @@, which uses queryâ€‘local statistics, @@@ computes scores using global IDF and Luceneâ€™s BM25 length normalization â€” so adding unrelated documents can still change the scores.
SELECT description, paradedb.score(id) AS score
FROM articles
WHERE description @@@ 'ğŸ' OR description @@@ 'ğŸ'
ORDER BY score DESC, description;
description | score
-------------+-------
(0 rows)
Enter fullscreen mode
Exit fullscreen mode
The result is empty. Using emoji as terms can lead to inconsistent tokenization results, so I replaced them with text labels instead:
UPDATE articles SET description
= replace(description, 'ğŸ', 'Gala');
UPDATE articles SET description
= replace(description, 'ğŸ', 'Granny Smith');
UPDATE articles SET description
= replace(description, 'ğŸŠ', 'Orange');
Enter fullscreen mode
Exit fullscreen mode
This time, the scoring is more precise and takes into account the term frequency within the document (TF), the termâ€™s rarity across the entire indexed corpus (IDF), along with a length normalization factor to prevent longer documents from having an unfair advantage:
SELECT description, paradedb.score(id) AS score
FROM articles
WHERE description @@@ 'Gala' OR description @@@ 'Granny Smith'
ORDER BY score DESC, description;
description
|
score
-------------------------------+------------
Granny Smith ğŸŒ Orange
|
3.1043208
Gala Gala Gala Gala Gala Gala | 0.79529095
Gala Gala ğŸŒ ğŸŒ ğŸŒ
|
0.7512194
Gala ğŸŒ
| 0.69356775
Gala ğŸŒ Orange Gala
| 0.63589364
Gala ğŸŒ Orange
|
0.5195716
Gala ğŸŒ Orange ğŸŒ´ ğŸ« ğŸˆ ğŸ‡
|
0.5195716
ğŸŒ Orange ğŸŒ´ ğŸ« ğŸˆ ğŸ‡
Gala |
0.5195716
Gala ğŸŒ Orange Orange Orange
| 0.34597924
(9 rows)
Enter fullscreen mode
Exit fullscreen mode
PostgreSQLâ€™s built-in search only provides basic, local term frequency scoring. To get a full-feature text search that can be used in application's search boxes, it can be extended with third-party tools like ParadeDB's pg_search.
Conclusion
Relevance scoring in text search can differ widely between systems because each uses its own ranking algorithms and analyzers. To better visualize my results in these tests, I used emojis and opted for the simplest definitions. I selected PostgreSQL's to_tsvector('simple') configuration to prevent language-specific processing, while for MongoDB Atlas Search, I used the default dynamic mapping.
MongoDB Atlas Search (and now in MongoDB Community Edition) uses Luceneâ€™s BM25 algorithm, combining:
Term Frequency (TF): Frequent terms in a document boost scores, but with diminishing returns
Inverse Document Frequency (IDF): Rare terms across the corpus get higher weight
Length normalization: Matches in shorter documents are weighted more than the same matches in longer ones
PostgreSQLâ€™s full-text search (ts_rank_cd()) evaluates only term frequency and position, overlooking other metrics like IDF. For more advanced features such as BM25, extensions like ParadeDBâ€™s pg_search are needed, which require extra configuration and are not always available on managed platforms. PostgreSQL offers a modular approach, where extensions can add advanced ranking algorithms like BM25. MongoDB provides builtâ€‘in BM25â€‘based fullâ€‘text search in both Atlas and the Community Edition.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
â€¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Franck Pachot
Follow
ğŸ¥‘ Developer Advocate at ğŸƒÂ MongoDB, ğŸ”¶Â AWS Data Hero, ğŸ˜Â PostgreSQL fan,â–â–Â YugabyteDB expert, ğŸ…¾ï¸Â Oracle Certified Master, and ğŸ’šÂ loving all databases ğŸ›¢ï¸
Location
Lausanne, Switzerland
Education
Master MIAGE, UniversitÃ© Paris-Sud, France
Work
Developer Advocate at MongoDB
Joined
Nov 12, 2018
More from Franck Pachot
Combine Two JSON Collections with Nested Arrays: MongoDB and PostgreSQL Aggregations
#mongodb
#postgres
#sql
#json
MongoDB Multikey Indexes and Index Bound Optimization
#database
#mongodb
#performance
MongoDB Internals: How Collections and Indexes Are Stored in WiredTiger
#mongodb
#database
#wiredtiger
#internals
ğŸ’ DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community â€” A space to discuss and keep up software development and manage your software career
Home
DEV++
Reading List
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem â€” the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community Â© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account