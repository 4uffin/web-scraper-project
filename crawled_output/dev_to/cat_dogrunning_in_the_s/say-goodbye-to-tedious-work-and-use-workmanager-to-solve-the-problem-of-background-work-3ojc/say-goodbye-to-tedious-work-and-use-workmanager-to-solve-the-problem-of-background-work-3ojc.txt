Say goodbye to tedious work and use WorkManager to solve the problem of background work - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Crypto Forem
Follow
A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis.
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
cat dog (running_in_the_storm)
Posted on Sep 13
Say goodbye to tedious work and use WorkManager to solve the problem of background work
#android
#opensource
Say goodbye to tedious work and use WorkManager to solve the problem of background work
Preface
Executing background tasks is a complex part of Android development, requiring numerous considerations. First and foremost is battery life. Frequent background tasks consume a significant amount of battery life, a problem unbearable for both users and the system. To combat the rampant and surreptitious background work of Android apps, Google has introduced various background restriction mechanisms (Doze Mode, App Standby, and Background Execution Limits). Newer versions of Android have tightened background management, creating compatibility challenges for developers. Most importantly, developers struggle to ensure the reliability of their apps' background tasks, as the system often pauses or kills them for various reasons.
WorkManager, a background task manager within the Android Jetpack family, is the officially recommended API for persistent work and general background processing. This article will demonstrate the use of WorkManager using the example of developing a downloader. The downloader code can be found in the following repository: https://github.com/Ilovecat1949/AndroidApps.
You are also welcome to check out my audio and video development project: https://github.com/Ilovecat1949/AudioAndVideoEditor. This is an open source Android audio and video editor that supports ffmpeg command line, video encoding compression and format conversion, video cropping and speed change, and other audio and video functions.
Why WorkManager is the best choice
Officially Endorsed and Reliable: As Google's officially recommended background task solution, WorkManager continues to receive support and optimization, with a simple and consistent API.
Persistent and Reliable Execution: This is WorkManager's greatest strength. Work execution is maintained even if the user navigates away from the screen, exits the app, or reboots the device. For failed tasks, WorkManager provides flexible retry policies, including a configurable exponential backoff policy.
Energy Efficiency: WorkManager adheres to power-saving features and best practices like Doze and offers powerful scheduling capabilities.
Flexible Constraints: Developers can set various constraints for tasks, allowing them to execute at the most appropriate time, saving battery and data usage.
For example:
Network Status: Execute only when connected to Wi-Fi.
Charging Status: Execute only when the device is charging.
Storage Space: Execute only when sufficient storage space is available.
Diverse Task Types: Supports one-time, periodic, and chained tasks to meet the diverse needs of developers.
Core Concepts and Practices: How does WorkManager work?
WorkManager's design philosophy is very clear, breaking down background tasks into three core components:
Worker: Unit of Work
Concept: WorkManager abstracts background tasks into independent Workers. Each Worker is responsible for performing a specific task, such as uploading logs, synchronizing data, or downloading files.
Implementation: Inherit the Worker class and override the doWork() method. Implement your background task logic in this method.
Task Request: WorkRequest
Concept: A WorkRequest describes how a task should be executed, including constraints, execution delay, and other information.
Practice: Create a task request using OneTimeWorkRequest (for one-time tasks) or PeriodicWorkRequest (for periodic tasks) and set constraints using the Constraints builder.
Task Scheduling: WorkManager
Concept: WorkManager is the scheduling center for background tasks. It receives WorkRequests and decides when to execute a Worker based on constraints and system status.
Practice: Submit tasks to the WorkManager using WorkManager.getInstance(context).enqueue(workRequest) .
Talking with code: Developing a downloader using WorkManager
design
Before developing, we need to first consider the nature of our application.
Develop it in Kotlin and develop the UI using Jetpack Compose.
Be able to request the necessary permissions for downloads, such as network permissions and file read/write permissions.
The interface should allow users to enter a download link and initiate the download.
Provide a download task list to display download progress and status.
Support download progress notifications.
The importance of notifications is crucial. Long-running tasks that require continuous network or CPU access require a "pass" to inform the system of their importance. To address this, we need to upgrade the download task to a "foreground service." A foreground service notifies the system that the task is in progress and is visible to the user (via notifications), preventing the system from easily terminating it.
### Code Implementation
We first need to declare the required permissions in AndroidManifest.xml. For Android 13 and later Android versions, we need to explicitly declare the notification permission.
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<!-- Â£∞ÊòéÁΩëÁªúÊùÉÈôêÔºåËøôÊòØ‰∏ãËΩΩÂäüËÉΩÊâÄÂøÖÈúÄÁöÑ -->
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
Enter fullscreen mode
Exit fullscreen mode
We also need to check and request permissions at runtime, and create a notification channel.
private val requestPermissionLauncher =
registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
if (isGranted) {
// Permission granted. Continue with the app flow.
} else {
Toast.makeText(this, "ÈúÄË¶ÅÈÄöÁü•ÊùÉÈôêÊâçËÉΩÊòæÁ§∫‰∏ãËΩΩËøõÂ∫¶", Toast.LENGTH_LONG).show()
}
}
private fun createNotificationChannel() {
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
val name = "‰∏ãËΩΩÈÄöÁü•"
val descriptionText = "ÊòæÁ§∫‰∏ãËΩΩÊñá‰ª∂ÁöÑËøõÂ∫¶ÂíåÁä∂ÊÄÅ"
val importance = NotificationManagerCompat.IMPORTANCE_LOW
val channel = android.app.NotificationChannel(DOWNLOAD_NOTIFICATION_CHANNEL_ID, name, importance).apply {
description = descriptionText
}
val notificationManager: android.app.NotificationManager =
getSystemService(Context.NOTIFICATION_SERVICE) as android.app.NotificationManager
notificationManager.createNotificationChannel(channel)
}
}
override fun onCreate(savedInstanceState: Bundle?) {
...
if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R){
val permission = arrayOf(
Manifest.permission.WRITE_EXTERNAL_STORAGE,
Manifest.permission.READ_EXTERNAL_STORAGE
)
val requestPermissionLauncher =
this.registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
}
permission.forEach {
if(! (this.checkSelfPermission(it) == PackageManager.PERMISSION_GRANTED)){
requestPermissionLauncher.launch(it)
}
}
}
else{
if(!Environment.isExternalStorageManager()){
val builder = android.app.AlertDialog.Builder(this)
.setMessage("ÈúÄË¶ÅËé∑ÂèñÊñá‰ª∂ËØªÂÜôÊùÉÈôê")
.setPositiveButton("ok") { _, _ ->
val packageName = this.packageName
val intent = Intent()
intent.action = Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION
intent.data = Uri.fromParts("package", packageName, null)
ContextCompat.startActivity( this, intent, null)
}
.setNeutralButton("Á®çÂêéÂÜçÈóÆ"){ _, _ ->
}
builder.show()
}
}
// ËØ∑Ê±ÇÈÄöÁü•ÊùÉÈôê (ÈÄÇÁî®‰∫é Android 13 Âèä‰ª•‰∏äÁâàÊú¨)
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
if (ActivityCompat.checkSelfPermission(
this,
Manifest.permission.POST_NOTIFICATIONS
) != PackageManager.PERMISSION_GRANTED
) {
requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
}
}
// ÂàõÂª∫ÈÄöÁü•Ê∏†ÈÅì
createNotificationChannel()
...
}
Enter fullscreen mode
Exit fullscreen mode
Define a work class based on your own needs, and write the specific logic of executing the task in this work class.
class DownloadWorker(
appContext: Context,
workerParams: WorkerParameters
) : CoroutineWorker(appContext, workerParams) {
private val notificationManager = NotificationManagerCompat.from(appContext)
private val notificationBuilder = NotificationCompat.Builder(applicationContext, DOWNLOAD_NOTIFICATION_CHANNEL_ID)
.setContentTitle("‰∏ãËΩΩ‰∏≠")
.setSmallIcon(android.R.drawable.stat_sys_download)
.setPriority(NotificationCompat.PRIORITY_LOW)
.setOngoing(true)
// ÊúÄÂ§ßÊñá‰ª∂ÂêçÈïøÂ∫¶
private val MAX_FILENAME_LENGTH = 50
// ÈáçÂÜô getForegroundInfo() ‰ª•Êèê‰æõÂâçÂè∞ÊúçÂä°ÈÄöÁü•‰ø°ÊÅØ
override suspend fun getForegroundInfo(): ForegroundInfo {
return ForegroundInfo(
DOWNLOAD_NOTIFICATION_ID,
notificationBuilder.setContentText("ÂºÄÂßã‰∏ãËΩΩ...").build()
)
}
override suspend fun doWork(): Result {
//Êñá‰ª∂‰∏ãËΩΩÁöÑÂÖ∑‰ΩìÈÄªËæëÂÜôÂú®ËøôÈáåÈù¢
...
}
// Helper function to set progress for the UI
private fun setProgress(progress: Int) {
val progressData = workDataOf("progress" to progress)
setProgressAsync(progressData)
}
}
Enter fullscreen mode
Exit fullscreen mode
We obtain a WorkManager instance through the context, which directly handles all tasks related to the task database and scheduling system. WorkManager uses a Room database (an abstraction layer for SQLite databases) in the application's private storage space to achieve task persistence and state management. We can directly access all task information from the WorkManager instance. Combined with LiveData, the application interface can observe and display task status and progress in real time, achieving synchronization between background tasks and the UI.
val workManager = WorkManager.getInstance(context)
...
val workInfos: LiveData<List<WorkInfo>> = remember {
workManager.getWorkInfosByTagLiveData(DOWNLOAD_WORK_TAG)
}
val downloadTasks by workInfos.observeAsState(initial = emptyList())
...
LazyColumn(
modifier = Modifier.fillMaxSize()
) {
items(downloadTasks) { workInfo ->
DownloadTaskItem(workInfo)
}
}
Enter fullscreen mode
Exit fullscreen mode
Define a download start method to encapsulate the process of submitting tasks to WorkManager.
fun startDownload(context: Context, url: String) {
// 1. ÂàõÂª∫ WorkRequestÔºåÊåáÂÆöË¶ÅÊâßË°åÁöÑ Worker
val downloadRequest = OneTimeWorkRequestBuilder<DownloadWorker>()
.setInputData(workDataOf(DOWNLOAD_WORK_URL to url)) // 2. ‰º†ÈÄíËæìÂÖ•Êï∞ÊçÆ
.addTag(DOWNLOAD_WORK_TAG) // 3. Ê∑ªÂä†Ê†áÁ≠æ‰ª•‰æøË∑üË∏™
.build()
// 4. Â∞Ü‰ªªÂä°Âä†ÂÖ•ÈòüÂàó
WorkManager.getInstance(context).enqueue(downloadRequest)
}
Enter fullscreen mode
Exit fullscreen mode
The above is the idea of ‚Äã‚Äãusing WorkManager to develop a downloader.
Looking ahead: New trends in Android background tasks and Google policies
Google has been tightening the permissions for background tasks to protect user privacy and device battery life. Future Android versions may introduce even stricter background execution restrictions, making traditional approaches like Services and BroadcastReceivers increasingly difficult to use.
Against this backdrop, WorkManager, as the officially recommended solution, will become increasingly important. It helps us comply with Google's policies while ensuring reliable task execution.
Summarize
Let's review the advantages of WorkManager: reliability, compatibility, durability, and flexibility. It frees developers to focus on business logic without having to worry about complex background task adaptation and compatibility issues.
If you're still struggling with background tasks, it's time to embrace WorkManager. It will not only make your app more stable but also your development more efficient.
The downloader code can be found in the following repository: https://github.com/Ilovecat1949/AndroidApps.
Please check out my audio and video development project: https://ilovecat1949.github.io/AudioAndVideoEditor/. This is an open-source Android audio and video editor that supports various audio and video functions, including ffmpeg command-line functionality, video encoding and compression, format conversion, video cropping, and speed changes.
References
Android Background Worker Official Guide
WorkManager Official Course
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
‚Ä¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
cat dog (running_in_the_storm)
Follow
Joined
Aug 30, 2025
More from cat dog (running_in_the_storm)
Create your own personal website for free ‚Äî A guide to using GitHub Pages
#productivity
#github
#webdev
#opensource
üíé DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community ‚Äî A space to discuss and keep up software development and manage your software career
Home
Tags
About
Contact
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community ¬© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account