Comparing transitive dependency version resolution in Rust and Java - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
DUMB DEV Community
Follow
Memes and software development shitposting
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Nicolas Fr√§nkel
Posted on Sep 18
‚Ä¢ Originally published at blog.frankel.ch
Comparing transitive dependency version resolution in Rust and Java
#rust
#java
#dependencyresolution
#maven
You learn by comparing to what you already know. I was recently bitten by assuming Rust worked as Java regarding transitive dependency version resolution. In this post, I want to compare the two.
Dependencies, transitivity, and version resolution
Before diving into the specifics of each stack, let's describe the domain and the problems that come with it.
When developing any project above Hello World level, chances are you'll face problems that others have faced before. If the problem is widespread, the probability is high that somebody was kind and civic-minded enough to have packaged the code that solves it, for others to re-use. Now you can use the package and focus on solving your core problem. It's how industry builds most projects today, even if it brings other problems: you sit on the shoulders of giants.
Languages come with build tools that can add such packages to your project. Most of them refer to packages you add to your project as dependencies. In turn, projects' dependencies can have their own dependencies: the latter are called transitive dependencies.
In the above diagram, C and D are transitive dependencies.
Transitive dependencies have issues on their own. The biggest one is when a transitive dependency is required from different paths, but in different versions. In the diagram below, A and B both depend on C, but on different versions of it.
Which version of C should the build tool include in your project? Java and Rust have different answers. Let's describe them in turn.
Java transitive dependency version resolution
Reminder: Java code compiles to bytecode, which is then interpreted at runtime (and sometimes compiled to native code, but this is outside of our current problem space). I'll first describe runtime dependency resolution and build time dependency resolution.
At runtime, the JVM offers the concept of a classpath. When having to load a class, the runtime searches through the configured classpath in order. Imagine the following class:
public static Main {
public static void main(String[] args) {
Class.forName("ch.frankel.Dep");
}
}
Enter fullscreen mode
Exit fullscreen mode
Let's compile it and execute it:
java -cp ./foo.jar:./bar.jar Main
Enter fullscreen mode
Exit fullscreen mode
The above will first look in the foo.jar for the ch.frankel.Dep class. If found, it stops there and loads the class, regardless of whether it might also be present in the bar.jar; if not, it looks further in the bar.jar class. If still not found, it fails with a ClassNotFoundException.
Java's runtime dependency resolution mechanism is ordered and has a per class granularity. It applies whether you run a Java class and define the classpath on the command line as above, or whether you run a JAR that defines the classpath in its manifest.
Let's change the above code to the following:
public static Main {
public static void main(String[] args) {
var dep = new ch.frankel.Dep();
}
}
Enter fullscreen mode
Exit fullscreen mode
Because the new code references Dep directly, new code requires class resolution at compile-time. Classpath resolution works in the same way:
javac -cp ./foo.jar:./bar.jar Main
Enter fullscreen mode
Exit fullscreen mode
The compiler looks for Dep in foo.jar, then in bar.jar if not found. The above is what you learn at the beginning of your Java learning journey.
Afterwards, your unit of work is the Java Archive, known as the JAR, instead of the class. A JAR is a glorified ZIP archive, with an internal manifest that specifies its version.
Now, imagine that you're a user of foo.jar. Developers of foo.jar set a specific classpath when compiling, possibly including other JARs. You'll need this information to run your own command. How does a library developer pass this knowledge to downstream users?
The community came up with a few ideas to answer this question: The first response that stuck was Maven. Maven has the concept of POM, where you set your project's metadata, as well as dependencies. Maven can easily resolve transitive dependencies because they also publish their POM, with their own dependencies. Hence, Maven can trace each dependency's dependencies down to the leaf dependencies.
Now back to the problem statement: how does Maven resolve version conflicts? Which dependency version will Maven resolve for C, 1.0 or 2.0?
The documentation is clear: the nearest.
In the above diagram, the path to v1 has a distance of two, one to B, then one to C; meanwhile, the path to v2 has a distance of three, one to A, then one to D, then finally one to C. Thus, the shortest path points to v1.
However, in the initial diagram, both C versions are at the same distance from the root artifact. The documentation provides no answer. If you're interested in it, it depends on the order of declaration of A and B in the POM! In summary, Maven returns a single version of a duplicated dependency to include it on the compile classpath.
If A can work with C v2.0 or B with C 1.0, great! If not, you'll probably need to upgrade your version of A or downgrade your version of B, so that the resolved C version works with both. It's a manual process that is painful‚Äìask me how I know. Worse, you might find out there's no C version that works with both A and B. Time to replace A or B.
Rust transitive dependency version resolution
Rust differs from Java in several aspects, but I think the following are the most relevant for the sake of our discussion:
Rust has the same dependency tree at compile-time and at runtime
It provides a build tool out of the box, Cargo
Dependencies are resolved from source
Let's examine them one by one.
Java compiles to _bytecode, then you run the latter. You need to set the classpath both at compilation time and at runtime. Compiling with a specific classpath and running with a different one can lead to errors. For example, imagine you compile with a class you depend on, but the class is absent at runtime. Or alternatively, it's present, but in an incompatible version.
Contrary to this modular approach, Rust compiles to a unique native package the crate's code and every dependency. Moreover, Rust provides its own build too, thus avoiding having to remember the quirks of different tools. I mentioned Maven, but other build tools likely have different rules to resolve the version in the use case above.
Finally, Java resolves dependencies from binaries: JARs. On the contrary, Rust resolves dependencies from sources. At build time, Cargo resolves the entire dependency tree, downloads all required sources, and compiles them in the correct order.
With this in mind, how does Rust resolve the version of the C dependency in the initial problem? The answer may seem strange if you come from a Java background, but Rust includes both. Indeed, in the above diagram, Rust will compile A with C v1.0 and compile B with C v2.0. Problem solved.
Conclusion
JVM languages, and Java in particular, offer both a compile-time classpath and a runtime classpath. It allows modularity and reusability, but opens the door to issues regarding classpath resolution. On the other hand, Rust builds your crate into a single self-contained binary, whether a library or an executable.
To go further:
Maven - Introduction to the Dependency Mechanism
Effective Rust - Item 25: Manage your dependency graph
Originally published at A Java Geek on September 14th, 2025
Top comments (1)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Collapse
Expand
Guy
Guy
Guy
Follow
CEO and CTO at https://scrumbuddy.com/
Expert in AI orchestration and software delivery. Building something great for solo developers. Register now to test it out for free!
Email
hello@pinavida.co.uk
Location
Isle of Man
Work
CEO and CTO at ScrumBuddy
Joined
Sep 1, 2025
‚Ä¢
Sep 25
Dropdown menu
Copy link
Hide
Really good article. The comparison between Rust‚Äôs and Java‚Äôs transitive dependency resolution shone a light on something that trips up many devs once they scale. Having built orchestration around Claude, and even using it to build my own AI product, I‚Äôve wrestled with dependency drift, mismatch, and surprise version conflicts more times than I‚Äôd like to count.
This might be a strong opion, but Rust‚Äôs model here is way more forgiving when it comes to transitive version conflicts, especially because Cargo resolves dependencies from source and allows multiple versions of a crate if needed. That gives you a lot more leeway when libraries are evolving separately. But forgiving doesn‚Äôt mean free. Managing your public interfaces, re-exports, ensuring types align, that still becomes a mess if you ignore version constraints. Java‚Äôs ‚Äúnearest path wins‚Äù approach can mask mismatch until runtime, and by then the debugging costs are huge.
In my orchestration setup, I make it a rule that agents and prompts are always aware of what version constraints are in place; the version of libraries, the semver compatibility, the crate-features exposed, and I bake checks into the pipeline so when a prompt requests code touching a dependency, the system ensures it‚Äôs using a compatible crate version. It‚Äôs about ownership of the dependency graph, not just adding libraries fast.
My takeaway here is that dependency resolution is a foundation of stability. If your project doesn't manage it with discipline early (schema versioning, semver, re-exports, constraints), your AI-assisted layers can write you lots of boilerplate fixes later. Tools are powerful, but mis-managed dependencies are the silent scale killer.
Like comment:
Like comment:
1¬†like
Like
Comment button
Reply
Code of Conduct
‚Ä¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Nicolas Fr√§nkel
Follow
Dev Advocate | Developer & architect | Love learning and passing on what I learned!
Location
Geneva
Work
Solutions Engineer
Joined
Apr 7, 2020
More from Nicolas Fr√§nkel
Pattern matching across different languages
#kotlin
#java
#rust
#python
Runtime-initialized variables in Rust
#rust
#lazylock
#oncelock
#programming
LangChain4J musings, six months after
#java
#langchain4j
#mcp
#llm
üíé DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community ‚Äî A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community ¬© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account