The 90-Day Coding Routine That Made Me Think Like An Architect - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Rohit Gavali
Posted on Sep 19
The 90-Day Coding Routine That Made Me Think Like An Architect
#webdev
#programming
#ai
#discuss
I used to code like I was playing Tetris. Drop a function here, squeeze a feature there, hope everything fits together without breaking. My GitHub was full of projects that worked but couldn't explain why. My code reviews were defensive battles where I'd rationalize decisions I'd made on autopilot.
Then I spent 90 days forcing myself to think before I typed, and everything changed.
Not the usual "learn a new framework in 30 days" challenge. Not another productivity hack promising 10x developer status. This was different: a deliberate practice routine that rewired how I approached problems at the system level.
The transformation wasn't about writing better code. It was about developing the mental models that make code inevitable—the kind of architectural thinking that separates developers who ship features from developers who design systems that last.
The Realization
The wake-up call came during a system design interview. The interviewer asked me to architect a URL shortener—something I'd built before, something I thought I understood. But when pressed to explain my database choices, caching strategy, and scaling decisions, I fumbled.
I could implement the feature. I couldn't explain the system.
"Walk me through your thought process," they said. But there was no process to walk through. I'd been coding by pattern matching and intuition, copying solutions that worked without understanding why they worked.
That night, I realized the gap between knowing how to code and knowing how to architect wasn't just experience—it was the difference between tactical execution and strategic thinking. Senior engineers don't just solve problems. They anticipate problems that haven't happened yet.
I needed to develop architectural intuition. But how do you practice something as abstract as system design?
The 90-Day Framework
I designed a routine around one core principle: before writing any code, spend time thinking about the system it will live in.
Every day, for 90 days, I followed the same pattern:
Phase 1: Problem Definition (10 minutes)
Before touching the keyboard, I'd write down what I was trying to build and why. Not user stories or feature specs—system-level questions. What are the data flows? What are the failure modes? What assumptions am I making about scale, consistency, and performance?
Phase 2: Architecture First (20 minutes)
I'd sketch the system on paper before implementing anything. Data models, API boundaries, service interactions. No code, no frameworks—just boxes, arrows, and questions about how information flows through the system.
Phase 3: Implementation With Justification (30 minutes)
Only then would I start coding. But every significant decision—database choice, data structure, API design—had to have a written justification. Not just "this works" but "this works because of X, and here's how it handles Y edge case."
Phase 4: Review and Refactor (10 minutes)
At the end, I'd look at what I built and ask: What would break first if this needed to scale 10x? What assumptions would fail under different conditions? What would a senior engineer change about this approach?
One hour total. Every day. No exceptions.
The Mental Shift
The first week was brutal. Thinking before coding felt like swimming upstream. My brain wanted to jump straight into implementation, to feel the dopamine hit of working features. Forcing myself to slow down and think architecturally felt like artificial constraint.
But by week three, something clicked.
I started seeing patterns I'd missed before. The way authentication flows create single points of failure. How eager loading solves one performance problem while creating others. Why microservices can make simple problems complex and complex problems simple.
More importantly, I started asking different questions. Instead of "How do I implement this feature?" I was asking "What does this feature assume about the system?" Instead of "What's the fastest way to get this working?" I was asking "What's the most maintainable way to solve this problem?"
The code I wrote during these sessions wasn't necessarily better in isolation. But it fit better into larger systems. It anticipated edge cases. It handled failure gracefully. It could be extended without being rewritten.
The Tools That Accelerated Learning
Around day 30, I started incorporating AI tools to enhance the thinking process—not to generate code, but to pressure-test my architectural decisions.
I'd use Claude 3.7 Sonnet to play devil's advocate with my system designs. "Here's my approach to caching user sessions," I'd write. "What edge cases am I missing? What happens under high load? How would you modify this for multi-region deployment?"
The AI wouldn't just validate my thinking—it would expose assumptions I hadn't even realized I was making. It would ask follow-up questions that forced me to think through scenarios I'd overlooked.
When working through complex data flows, I'd use GPT-4o mini to help map out all the possible state transitions in my system. "If user A does X while user B does Y, and the database is under heavy load, what are all the possible outcomes?"
The Mind Mapping Tool became invaluable for visualizing system dependencies. Instead of keeping everything in my head, I could create visual representations of how different components interacted, making it easier to spot potential bottlenecks or circular dependencies.
These tools didn't replace architectural thinking—they amplified it. They helped me think more systematically about problems I was trying to solve.
The Breakthrough Moments
Week 6: I was building a simple chat application and realized that my initial database design couldn't handle message history efficiently at scale. Before the routine, I would have implemented the obvious solution and dealt with performance later. Instead, I redesigned the schema upfront to partition messages by time ranges, anticipating the scaling challenge before it became a problem.
Week 8: While working on an e-commerce checkout flow, I caught myself designing a system that could fail in seventeen different ways during payment processing. The old me would have built the happy path and debugged failures in production. The new me spent extra time designing for failure scenarios upfront, implementing circuit breakers and retry logic from the beginning.
Week 11: I was asked to add a "simple" real-time notification feature to an existing app. My initial response was to reach for WebSockets and call it done. But the routine forced me to think systemically. What happens when users have multiple devices? How do we handle offline scenarios? What about notification delivery guarantees? The "simple" feature became a thoughtful system design exercise.
By week 12, I wasn't just implementing features differently—I was seeing problems differently.
The Architecture Mindset
The routine taught me that architectural thinking isn't about knowing more patterns or frameworks. It's about developing a systematic approach to problem-solving that considers multiple dimensions simultaneously.
You start thinking in tradeoffs, not solutions. Every technical decision becomes a conscious choice between different types of complexity, different failure modes, different maintenance burdens. You stop looking for the "right" answer and start looking for the right tradeoffs for your specific context.
You develop failure imagination. Instead of building for the happy path, you start building for the ways things break. You think about network partitions, database failures, traffic spikes, and user behavior that doesn't match your assumptions.
You design for change. You stop building systems that work today and start building systems that can evolve tomorrow. You think about what requirements might change, what scale might look like, what new features might need to be added.
You see the system, not just the code. You start thinking about how your component fits into the larger architecture, how it affects other services, how it changes the operational burden, how it impacts the team that will maintain it.
The Practical Impact
Three months later, I could hold my own in system design discussions. Not because I'd memorized more patterns, but because I'd developed the thinking process that generates patterns.
My code reviews changed from defending implementation choices to discussing architectural tradeoffs. My estimates became more accurate because I was anticipating complexity upfront instead of discovering it during implementation.
Most importantly, I started contributing to architectural decisions instead of just implementing them. I could see problems coming before they hit production. I could suggest alternatives that other team members hadn't considered. I could explain not just what I was building, but why I was building it that way.
The routine had done what years of coding experience hadn't: it taught me to think like someone who designs systems, not just someone who implements them.
The Maintenance Phase
After 90 days, the routine became second nature. I no longer needed to force myself to think architecturally—it became the default mode. The structured time blocks evolved into a more fluid process of continuous architectural awareness.
But the core principle remained: think before you build, design before you implement, anticipate before you optimize.
Now when I approach any technical problem, I automatically ask the architectural questions. What are the data flows? What are the failure modes? What assumptions am I making? How will this evolve over time?
These questions don't slow down development—they accelerate it. They help me avoid architectural dead-ends, anticipate scaling challenges, and build systems that can evolve gracefully.
The Real Teaching
The 90-day routine wasn't really about coding. It was about rewiring my default approach to problem-solving. It taught me that architectural thinking is a learnable skill, not an innate talent.
Most developers wait for architectural thinking to emerge naturally from experience. But experience without reflection is just repetition. The routine forced the reflection that turns experience into wisdom.
You don't need years of experience to think architecturally. You need the discipline to pause before you build, to question your assumptions, and to think systematically about the problems you're solving.
The best part? Once you develop this mindset, it transfers to everything. Product planning, team organization, business strategy—all benefit from the same systematic, anticipatory thinking that makes great system architects.
Start with one hour a day. Think before you build. Question your assumptions. Design for failure. Anticipate change.
In 90 days, you won't just write different code. You'll think differently about problems.
-ROHIT V.
Top comments (3)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Collapse
Expand
Patrick R
Patrick R
Patrick R
Follow
Software Developer, 501st Canadian Garrison ST-38265, maker, cosplayer, fatbiker, MX keyboard enthusiast, and fake musician.
Education
B.CoSC from Laurentian University
Work
Software Developer
Joined
Aug 10, 2018
•
Sep 19
Dropdown menu
Copy link
Hide
Great read and a great technique. I'm generalizing here but I think that as developers we "think" in code so reflexively that reaching for the keyboard feels like the natural thing to do. I'm recognizing more and more how this tends towards a code first solution rather than a problem first solution which is what we really should be trying to do, isn't it?
Like comment:
Like comment:
Like
Comment button
Reply
Collapse
Expand
Borzoo Moazami
Borzoo Moazami
Borzoo Moazami
Follow
Work
Front-end Developer
Joined
Nov 1, 2022
•
Sep 21
Dropdown menu
Copy link
Hide
Thank you for sharing this great post. I'll write those steps down and put them in front of me to keep myself aware of the procedure I should follow to develop a good piece of software.
Like comment:
Like comment:
1 like
Like
Comment button
Reply
Collapse
Expand
Lee Carver
Lee Carver
Lee Carver
Follow
I'm a senior software developer, with a broad range of development skills and experience.
Location
USA
Joined
Jul 14, 2025
•
Sep 20
Dropdown menu
Copy link
Hide
I have often noticed that the longer I can keep my fingers out of the code, the better it is when I do start to implement.
Like comment:
Like comment:
Like
Comment button
Reply
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Rohit Gavali
Follow
Joined
Aug 11, 2025
More from Rohit Gavali
Your Favorite Framework Won't Matter in 5 Years
#webdev
#programming
#ai
#discuss
The Bug That Taught Me More Than Any Tutorial
#webdev
#programming
#ai
#discuss
The Single Coding Habit That Separates Seniors From Juniors
#programming
#ai
#discuss
#career
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Home
Welcome Thread
Reading List
Tags
About
Contact
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account