üó∫Ô∏è Go Maps Deep Dive (no_swiss) ‚Äî Part 1: The Secrets Behind O(1) Performance, Overflows, and Growth - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
arshia_rgh
Posted on Sep 17
‚Ä¢ Edited on Sep 25
üó∫Ô∏è Go Maps Deep Dive (no_swiss) ‚Äî Part 1: The Secrets Behind O(1) Performance, Overflows, and Growth
#go
#programming
#maps
#tutorial
Note: This article focuses on the old Go map implementation (map_noswiss). In later parts of this series, we will also cover the Swiss map (map_swiss).
Welcome back to our deep dive into Go maps! üëã In the first part of this series, we covered the basics of what Go maps are, their properties, and how to use them. Now, it's time to go deeper and uncover the magic that makes maps so efficient. üó∫Ô∏è‚ú®
In this article, we'll explore the inner workings of Go maps to understand:
Why map operations are usually O(1) and what can affect this performance. ‚è±Ô∏è
How Go handles hash collisions with "overflow" buckets. üì¶‚û°Ô∏èüì¶
The clever way maps grow without bringing your application to a halt. üå±
The role of a unique "seed" in the hashing process. üé≤
Let's get started!
The O(1) Magic: It's All About Hashing
You've probably heard that map lookups, insertions, and deletions are O(1) operations, meaning they take constant time on average, regardless of the number of elements in the map. But how is this possible? The secret lies in hashing. üîë‚û°Ô∏èüî¢
When you add a key-value pair to a map, Go uses a hash function to convert the key into a number. This number, or "hash," is then used to determine which "bucket" the key-value pair should be stored in. A bucket is essentially a small, fixed-size array that can hold a few key-value pairs.
Because the hash function is designed to be very fast and to distribute keys evenly across the available buckets, Go can quickly locate the correct bucket for a given key without having to check every element in the map. This is what gives maps their O(1) performance. üí™
However, I said usually O(1). What happens when two different keys generate the same hash? This is called a hash collision, and it can slightly degrade performance. We'll explore this more in the section on overflows. üí•
The Unique Seed: Why the Same Key Can Live in Different Places
Here's a fun fact that might surprise you: if you create two different maps and insert the same key into both, that key might end up in different buckets in each map. ü§Ø
Why? Because every new map in Go is created with a unique random seed. This seed is used in the hashing algorithm, which means that the hash generated for a key is unique to that specific map instance.
Let's look at an example:
package main
import "fmt"
func main() {
map1 := make(map[string]int)
map2 := make(map[string]int)
map1["a"] = 1
map2["a"] = 1
// The internal location of "a" in map1 and map2
// will likely be different!
}
Enter fullscreen mode
Exit fullscreen mode
This randomization is a security feature that helps prevent a type of attack called "hash-flooding," where an attacker could craft keys that all hash to the same bucket, effectively turning the map's O(1) operations into O(n) and slowing down your application. üõ°Ô∏è
When Buckets Get Full: The Role of Overflows
Each bucket in a Go map can hold up to 8 key-value pairs. But what happens when more than 8 keys hash to the same bucket? Go doesn't just give up. Instead, it creates an overflow bucket and links it to the original bucket. üîó
A simplified visualization of a hash table bucket with an overflow bucket attached, showing keys spilling into the overflow when the primary bucket is full.
If you have many keys that hash to the same bucket, you can end up with a chain of overflow buckets. When looking up a key in this scenario, Go first checks the main bucket and then has to traverse the chain of overflow buckets. This is one of the reasons why map operations are not always O(1). In the worst-case scenario (many collisions), a lookup could degrade to O(n) performance, where 'n' is the number of items in the bucket and its overflows. üê¢
The Growing Map: An Incremental Approach
As you add more and more elements to a map, it will eventually need to grow to accommodate the new data and maintain its performance. A map in Go will trigger a growth cycle in one of two situations:
The load factor is too high:
If the average number of elements per bucket exceeds a certain threshold (currently around 6.5), the map will grow. üìà
Too many overflow buckets:
If the map has too many overflow buckets, it's a sign that the keys are not well-distributed, and a resize is needed to spread them out more evenly. üßπ
But how does this growth happen? If you have a map with thousands or even millions of key-value pairs, resizing it all at once could cause a noticeable pause in your application. To avoid this, Go employs a clever strategy: incremental growth. üöÄ
When a map needs to grow, Go allocates a new, larger array of buckets (usually double the size of the old one). However, it doesn't copy all the data over at once. Instead, the copying happens gradually. Each time you write to or delete from the map, Go moves a few buckets from the old array to the new one. ‚û°Ô∏è‚û°Ô∏è‚û°Ô∏è
This incremental approach spreads the work of resizing over time, ensuring that no single map operation takes too long. It's a fantastic example of how Go is designed for building responsive, low-latency applications. üíñ
üóùÔ∏èAbout the hint in make(map[K]V, hint)
When you write something like:
x := make(map[int]int, 13)
Enter fullscreen mode
Exit fullscreen mode
the second argument (13 in this case) is not the length, size, or capacity of the map. It is just a hint to the runtime about how many elements you expect to insert.
Go maps use buckets internally, and the runtime uses the hint to decide how many buckets to preallocate. Each bucket can hold up to 8 key/value pairs. Go tries to keep the average load factor around 6.5 elements per bucket before growing.
For example,
With a hint of 13, the runtime will start with 2 buckets (capacity for 16 slots). Since 13 / 2 = 6.5, this is right at the threshold.
If the hint were 14, the runtime would start with 4 buckets (capacity for 32 slots). That‚Äôs because 14 / 2 = 7 would exceed the load factor limit, so it doubles the bucket count.
This is why the hint value causes jumps in allocation instead of scaling smoothly.
take a look at this table:
Hint Range
Bucket Count
Capacity
0 ‚Äì 8
1
8
9 ‚Äì 13
2
16
14 ‚Äì 26
4
32
27 ‚Äì 52
8
64
53 ‚Äì 104
16
128
105 ‚Äì 208
32
256
209 ‚Äì 416
64
512
417 ‚Äì 832
128
1024
833 ‚Äì 1664
256
2048
What's Next?
We've covered a lot of ground in this article, from hashing and overflows to the incremental growth of maps. I hope you now have a better appreciation for the sophisticated engineering that makes Go maps so powerful and efficient. üß†üí°
But we're not done yet! In the next part of this series, we'll get our hands dirty and dive into the Go source code to see exactly how all of these concepts are implemented. It's going to be a fun and enlightening journey, so stay tuned! üíªüîç
Top comments (5)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Collapse
Expand
Alireza Ahmadi
Alireza Ahmadi
Alireza Ahmadi
Follow
Joined
Sep 21, 2025
‚Ä¢
Sep 21
Dropdown menu
Copy link
Hide
This is a fantastic deep dive into Go maps! The explanation of how hashing works behind the scenes, the management of overflow buckets, and the gradual growth strategy of maps is incredibly insightful. I especially appreciate the point on using random seeds in the hashing algorithm for security purposes to prevent hash-flooding attacks. For Go developers and anyone interested in performance optimization, this article is a must-read. Looking forward to part 2!
Like comment:
Like comment:
2¬†likes
Like
Comment button
Reply
Collapse
Expand
arshia_rgh
arshia_rgh
arshia_rgh
Follow
Joined
Sep 9, 2025
‚Ä¢
Sep 22
Dropdown menu
Copy link
Hide
Thank you so much for your thoughtful comment, Alireza! I really appreciate it, and I‚Äôm very happy to hear the article was useful for you. I truly enjoy working with Go and its internals, and I hope you enjoy exploring it as much as I do. Your encouragement means a lot‚ÄîI‚Äôll do my best to make part 2 just as insightful!
Like comment:
Like comment:
1¬†like
Like
Comment button
Reply
Collapse
Expand
Ryan B
Ryan B
Ryan B
Follow
Just a salty old programmer.
Location
Southern Gulf Islands, BC Canada
Work
Backend Developer
Joined
Jul 15, 2023
‚Ä¢
Sep 17
Dropdown menu
Copy link
Hide
Love these kinds of deep dives. Keep them coming, more folks should know the inner workings of Go!
Like comment:
Like comment:
3¬†likes
Like
Comment button
Reply
Collapse
Expand
arshia_rgh
arshia_rgh
arshia_rgh
Follow
Joined
Sep 9, 2025
‚Ä¢
Sep 18
Dropdown menu
Copy link
Hide
Thank you so much for your comment!
Golang internals are my favorite as well, and I really enjoy exploring them. Stay tuned for the next part on map internals‚Äîwe‚Äôll dive deep into the source code behind everything I covered in the first two parts.
Like comment:
Like comment:
2¬†likes
Like
Comment button
Reply
Collapse
Expand
Andrei Simionescu
Andrei Simionescu
Andrei Simionescu
Follow
Location
Manchester
Work
Janitor at Karat
Joined
Jan 25, 2020
‚Ä¢
Sep 21
Dropdown menu
Copy link
Hide
The language is called Go, not Golang, which the AI slop article got right, but its author apparently doesn't.
Like comment:
Like comment:
3¬†likes
Like
Comment button
Reply
Code of Conduct
‚Ä¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
arshia_rgh
Follow
Joined
Sep 9, 2025
More from arshia_rgh
üõ†Ô∏èGolang Source Code Essentials, Part 0: Compiler Directives & Build Tags‚ö°
#programming
#go
#compiler
üó∫Ô∏è Go Maps Deep Dive ‚Äî Part 0: Understanding the Basics
#go
#programming
#hashmap
#map
üíé DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community ‚Äî A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community ¬© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account