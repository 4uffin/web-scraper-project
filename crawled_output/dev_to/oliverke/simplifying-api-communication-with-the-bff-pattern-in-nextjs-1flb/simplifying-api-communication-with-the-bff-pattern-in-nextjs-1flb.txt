Simplifying API Communication with the BFF Pattern in NextJS - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
DUMB DEV Community
Follow
Memes and software development shitposting
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Kelechi Oliver A.
Posted on Sep 22
Simplifying API Communication with the BFF Pattern in NextJS
#nestjs
#react
#nextjs
#api
In one of my recent projects, the frontend had to juggle 5 different APIs, each having a different response schema. This issue of multiple backends has now become a common struggle as modern web applications often rely on multiple APIs, microservices, and third-party integrations. While this architecture is powerful, it can introduce complexity for the frontend, such as handling multiple data sources, managing authentication, and dealing with inconsistent response formats.
This is where the Backend-for-Frontend (BFF) pattern comes in. Instead of letting the frontend talk to all APIs directly, you place a thin backend layer between them. With Next.js, this pattern fits naturally, thanks to its API routes and server-side rendering (SSR) capabilities. If you’ve ever struggled with messy API responses or token handling on the client, you’ve already felt the need for a BFF layer.
In this article, we’ll explore what the BFF pattern is, why it matters, and how you can implement it effectively using Next.js.
What is the Backend-for-Frontend (BFF) Pattern?
The Backend-for-Frontend (BFF) pattern is an architectural approach where a dedicated backend layer is created specifically for a frontend application (e.g., web, mobile, or desktop).
Instead of having the frontend communicate directly with multiple microservices, APIs, or databases, the BFF acts as an adapter that:
Orchestrates data from multiple sources.
Shapes the responses to suit frontend requirements.
Manages authentication and authorization.
In short, the BFF provides a single, tailored API surface that makes frontend development faster and simpler.
What are the benefits of this pattern?
Simplified frontend logic: Since the BFF layer acts like a proxy, the UI only needs to interact with one API.
Optimized payloads: Only the necessary data is returned.
Improved security: Tokens and credentials are handled on the server, not the client.
Flexibility: Each frontend (web, mobile, IoT) can have its own tailored BFF.
Consistency: The BFF ensures a unified response format across diverse backend services.
Enough of the theory, I believe we now have some understanding of what the BFF pattern is and what benefits it provides. Next, let’s look through some code samples to see how we can implement this pattern using Nextjs.
Implementing the BFF Pattern with Next.js and NestJS
Architecture
Frontend (Next): Renders UI and interacts only with the BFF layer.
BFF Layer Next API Routes: Acts as a proxy between the frontend and backend.
Backend Nest: Provides domain logic, connects to databases, and exposes microservices.
For the backend, we can have different services running as multiple instances of Nest application, each backend service handles different business domains such as auth, inventory, notification, etc.
Sample NestJS controller
// auth.controller.ts
import { Controller, Get, Param } from '@nestjs/common';
import { AuthService } from './auth.service';
@Controller('auth')
export class AuthController {
constructor(private readonly authService: authService) {}
@Get('user/:id')
async findUserById(@Param('id') id: string) {
return this.authService.findUserById(id);
}
}
Enter fullscreen mode
Exit fullscreen mode
A service would be:
import { Injectable } from '@nestjs/common';
@Injectable()
export class AuthService {
async findUserById(id: string) {
// Mocked DB call
return { id, name: 'Alice', email: 'alice@example.com' };
}
}
Enter fullscreen mode
Exit fullscreen mode
Backend runs at http://localhost:4000/auth/user/:id.
Frontend
Next.js BFF API Route
// api/profile.ts
import type { NextApiRequest, NextApiResponse } from 'next';
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
const { id } = req.query;
const response = await fetch(`http://localhost:4000/auth/users/${id}`);
const user = await response.json();
// Define a response structure independent of the backend.
// You can also provide client-side fallbacks or mock responses based on contracts.
// This allows you to implement client-specific logic and maintain flexibility.
// Shape response for the frontend
res.status(200).json({
id: user.id,
displayName: user.name,
contact: user.email
});
}
Enter fullscreen mode
Exit fullscreen mode
Call BFF inside a component
// pages/dashboard.tsx
import { useEffect, useState } from 'react';
export default function Dashboard() {
const [profile, setProfile] = useState<any>(null);
useEffect(() => {
async function loadProfile() {
const res = await fetch('/api/profile?id=123'); // single API
const data = await res.json();
setProfile(data);
}
loadProfile();
}, []);
if (!profile) return <p>Loading...</p>;
return (
<div>
<h1>Welcome, {profile.displayName}</h1>
<p>Email: {profile.contact}</p>
</div>
);
}
Enter fullscreen mode
Exit fullscreen mode
Frontend is now no longer coupled with backend, we have the ability to enhance the BFF layer as well as connect to different backend source in order to fulfil any frontend UI requirements.
The real win here is that your frontend team stays focused on UI, while the BFF quietly handles API messiness, security, and data shaping in the background.
Key Takeaways
Reduces Coupling Between Frontend and Backend
The frontend only talks to the BFF, not to multiple microservices directly.
If backend APIs change, only the BFF layer is updated — the frontend remains untouched.
This reduces the risk of frontend breakage and makes backend evolution safer.
Manages Frontend Complexity
Instead of each component juggling multiple API calls, the BFF aggregates responses into a single, tailored endpoint.
Frontend developers can focus purely on UI/UX logic without worrying about data orchestration, token handling, or payload shaping.
Results in cleaner, more maintainable React/Next.js codebases.
Adds Flexibility Across Platforms
Each frontend (web, mobile, IoT) can have its own BFF, optimized for its unique needs.
A mobile app might get lightweight, compressed data while the web app receives richer, more detailed payloads — all from separate BFFs pointing to the same backend.
The backend services remain consistent, while the BFF adapts to each frontend’s context.
Enables Better Security and Governance
API keys, tokens, and sensitive logic stay in the BFF layer, never exposed to the client.
Centralized place for applying rate-limiting, logging, and caching policies.
Some use cases of the BFF Pattern
E-commerce app: Imagine a product page that needs to pull in details, reviews, recommendations, and pricing. Without a BFF, your frontend would make four different API calls and stitch everything together. With a BFF, you ask one endpoint, and it delivers exactly what the UI needs in one go.
SaaS dashboards: Dashboards are notorious for pulling data from everywhere, analytics, billing, user profiles, notifications. A BFF acts like the middle manager that gathers all the information, so your frontend doesn’t have to chase after five different services every time a page loads.
Multi-channel apps (web + mobile): A web app might want the full dataset, while the mobile version only needs a trimmed-down payload for performance. With separate BFFs, you can shape responses differently for each client without touching the backend services.
Microservices environments: If your system is split into many microservices like in my case, exposing them all directly to the frontend can get messy fast. A BFF hides that sprawl and presents a single, clean API to the UI.
Third-party integrations: Ever had to deal with APIs like Stripe, Twilio, or Salesforce? They all come with different formats and authentication quirks. A BFF can normalize these responses and handle token management behind the scenes, so your frontend team doesn’t need to worry about it.
Conclusion
The Backend-for-Frontend (BFF) pattern provides a practical way to reduce complexity, improve security, and decouple frontend teams from backend changes. By introducing a thin adapter layer, the frontend gets exactly the data it needs in the right format, while backend services remain clean and independent.
As seen above, Next.js handles UI rendering and API orchestration, while NestJS focuses on core business logic and scalability, together striking a balance between developer productivity and system robustness.
If we were to push this setup further, we can consider doing
Contract-First API Development with ts-rest
Ensures both frontend and backend share a strongly-typed contract.
Prevents mismatched API payloads and improves developer experience.
Example: Define your API in ts-rest once and generate client + server types.
Authentication & Authorization with Cognito or Auth0
Offload user management, login flows, and token handling to battle-tested identity providers.
The BFF validates and refreshes tokens securely on behalf of the frontend.
Keeps sensitive credentials away from the client.
Caching & Performance Enhancements
Add caching (e.g., Redis, edge caching with Vercel) to reduce API round-trips.
Improves frontend performance and backend scalability.
Observability and Logging
The BFF is a perfect place to centralize logging, monitoring, and error reporting for frontend requests.
Top comments (1)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Collapse
Expand
Navidreza Abbaszadeh
Navidreza Abbaszadeh
Navidreza Abbaszadeh
Follow
Fullstack developer | NextJS | NestJS | ExpressJS | MongoDB | PostgressSQL
Email
navidrezaabbaszadeh80@gmail.com
Education
National Organization of Exceptional Talents (SAMPAD)
Pronouns
He/Him
Work
Frontend developer at Hexorix
Joined
Aug 22, 2025
•
Sep 25
Dropdown menu
Copy link
Hide
My question is doesn't that decrease performance? because now instead of 1 we're making 2 requests. What's your opinion on this?
Like comment:
Like comment:
1 like
Like
Comment button
Reply
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Kelechi Oliver A.
Follow
A highly creative individual with extensive knowledge of web and cloud infrastructure, constantly building on AWS. Fascinated by how large-scale systems are built, deployed and manaeged.
Location
Port Harcourt, Nigeria
Pronouns
He/Him
Work
Software Engineer
Joined
May 14, 2019
More from Kelechi Oliver A.
Deploying a React Application to AWS Cloudfront
#react
#aws
#javascript
#webdev
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account