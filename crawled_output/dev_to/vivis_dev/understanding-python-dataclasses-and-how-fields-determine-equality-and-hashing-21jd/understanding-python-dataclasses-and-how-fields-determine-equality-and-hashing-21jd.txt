Understanding Python dataclasses and how fields determine equality and hashing. - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
DUMB DEV Community
Follow
Memes and software development shitposting
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SREâ€”the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project â€” features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Cryptoâ€”from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Vivis Dev
Posted on Sep 24
â€¢ Originally published at pythonkoans.substack.com
Understanding Python dataclasses and how fields determine equality and hashing.
#python
#programming
Python Koans (12 Part Series)
1
Understanding truthiness, falsiness, and the quiet meaning of emptiness in Python
2
Understanding the difference between identity and equality, and why it matters more than it seems.
...
8 more parts...
3
Understanding how Python evaluates default arguments and why mutable defaults can carry unintended memory
4
Exploring how functions in Python are treated as first-class citizens, and the untapped potential they hold.
5
Understanding Late Binding in Python Closures
6
Understanding Pythonâ€™s LEGB rule, closures, and why variables sometimes behave like shadows.
7
Navigating Python's import system and namespace packages
8
Understanding Pythonâ€™s rules for hashing
9
Exploring chained operations and order of evaluation in python expressions
10
Understanding how Python's list comprehensions work under the hood
11
Exploring the dangerous power of unquoted Python strings, and how they caused CVE-2024-9287
12
Understanding Python dataclasses and how fields determine equality and hashing.
In monasteries bowls are often used for meditation rituals. Some are empty, others hold offerings: coins, water, and small tokens of care. In Python, dataclasses behave much like these bowls.
Each dataclass instance is a bowl; the data it carries are the offerings inside. How Python evaluates equality and hashing depends on both the contents and the form of the bowl itself.
Part 1: What is a Dataclass?
Dataclasses, introduced in Python 3.7, are a convenience feature. They save you from writing boilerplate code when you need simple classes that hold data.
For example, without dataclasses you might write:
And with a dataclass it becomes:
Python automatically creates the __init__, __eq__, and __repr__ functions for you when you use the dataclass decorator.
Part 2: The Empty Bowl
Consider a bowl with no marked offerings:
Although values are assigned on the class, there are no annotated fields. When Python evaluates this bowl:
Only attributes declared with annotations are considered the recognized contents of the bowl, contributing to equality and hash calculations. Adding type annotations transforms the bowl:
Now the offerings are acknowledged, and hashing reflects their presence. Two bowls with identical annotated fields are equal, and their hashes correspond to their contents.
Part 2: Comparing Different Bowls
Next, imagine two bowls, each holding the same offerings:
The bowls may contain identical coins and water, yet they differ in form. Python compares both the contents and the type of the object:
Equality requires both the offerings and the vessel to match. Hashing, on the other hand, considers only the annotated fields.
Part 3: Fields vs Class Variables
The distinction between annotated fields and class variables is crucial. Only annotated fields are considered offerings within the bowl. Class variables exist on the outside: they do not contribute to equality or hashing.
Part 4: Mutable vs Frozen Dataclasses
You may have noticed that we are delcaring classes with frozen=True.Dataclasses can be created mutable or frozen :
Mutable dataclasses allow their contents to change after creation. This is the default.
Frozen dataclasses make the contents immutable, like sealing the offerings inside a bowl.
Frozenness also affects hashability. Only frozen dataclasses are hashable by default, because mutable bowls could change after being placed in a set or used as dict keys.
In Koan 8 we learnt that the hashability of a class is determined by the implementation of the __hash__function. When a dataclass is declared frozen, Python automatically creates a __hash__function for you.
Part 5: Default Values and Factories
Default values make bowls easier to create without specifying every offering:
For mutable fields like lists or dictionaries, a default factory is necessary. Using a default argument with a mutable object can lead to shared state between instances:
This is because default arguments are evaluated once at definition time, not execution time, as we learnt in Koan 3.
Instead, a default_factory creates a new object for each instance :
Now each bowl has its own independent list of offerings. Python calls the factory function at the time the instance is created, ensuring the contents of each bowl remain separate.
This distinction prevents subtle bugs and preserves the integrity of each bowlâ€™s contents.
Offering the Bowl
A bowl without marked offerings is indistinguishable from another empty bowl of the same type. Two bowls may contain identical offerings, yet remain separate if their forms differ. Hashing depends only on the contents, while equality considers both the contents and the form.
Through careful attention to fields, mutability, defaults, and the auto-generated methods, dataclasses provide a simple, predictable structure for Python data objects.
Python Koans | Vivis Dev | Substack
Python lessons wrapped in koans. Small puzzles, deep truths. Not your usual tutorial thread. Click to read Python Koans, by Vivis Dev, a Substack publication with hundreds of subscribers.
pythonkoans.substack.com
Python Koans (12 Part Series)
1
Understanding truthiness, falsiness, and the quiet meaning of emptiness in Python
2
Understanding the difference between identity and equality, and why it matters more than it seems.
...
8 more parts...
3
Understanding how Python evaluates default arguments and why mutable defaults can carry unintended memory
4
Exploring how functions in Python are treated as first-class citizens, and the untapped potential they hold.
5
Understanding Late Binding in Python Closures
6
Understanding Pythonâ€™s LEGB rule, closures, and why variables sometimes behave like shadows.
7
Navigating Python's import system and namespace packages
8
Understanding Pythonâ€™s rules for hashing
9
Exploring chained operations and order of evaluation in python expressions
10
Understanding how Python's list comprehensions work under the hood
11
Exploring the dangerous power of unquoted Python strings, and how they caused CVE-2024-9287
12
Understanding Python dataclasses and how fields determine equality and hashing.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
â€¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Vivis Dev
Follow
AI Tinkerer | Pythoneer
Subscribe to my free Python newsletter: https://pythonkoans.substack.com
Joined
Sep 10, 2025
More from Vivis Dev
Exploring the dangerous power of unquoted Python strings, and how they caused CVE-2024-9287
#python
#programming
#shell
#cve
Understanding how Python's list comprehensions work under the hood
#python
#programming
#koan
Exploring chained operations and order of evaluation in python expressions
#python
#programming
ðŸ’Ž DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community â€” A space to discuss and keep up software development and manage your software career
Home
Welcome Thread
Reading List
Tags
About
Contact
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem â€” the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community Â© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account