C++ References Tutorial: Complete Guide to Aliases, Performance, and Modern C++ (2025) - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Basil Abu-Al-Nasr
Posted on Sep 25
C++ References Tutorial: Complete Guide to Aliases, Performance, and Modern C++ (2025)
#cpp
#programming
#tutorial
#performance
C++ Advanced Concepts (2 Part Series)
1
C++ Templates Tutorial: Complete Guide to Generic Programming (2025) (With Examples)
2
C++ References Tutorial: Complete Guide to Aliases, Performance, and Modern C++ (2025)
Article Overview
Programming Language: C++
Difficulty Level: Beginner to Advanced
Topics Covered: References, Pass-by-Reference, Const References, Move Semantics, Performance Optimization
Estimated Reading Time: 15 minutes
Prerequisites: Basic C++ knowledge, understanding of variables, functions, and basic memory concepts, basic OOP
What You'll Learn: How to use references efficiently, avoid common pitfalls, and apply modern C++ reference techniques
Imagine you're writing a function to process a large video file object in C++:
struct VideoFile {
vector<byte> data;
// Could be gigabytes!
string metadata;
// ... more fields
};
void processVideo(VideoFile video) {
// Problem: copies entire object!
// Process the video...
}
Enter fullscreen mode
Exit fullscreen mode
Every time you call this function, C++ makes a complete copy of your multi-gigabyte video object. That's slow, memory-intensive, and unnecessary if you just want to read the data.
You could use pointers, but they bring complexity: null checks, dereferencing syntax, and cognitive overhead.
Enter references — C++'s elegant solution that gives you the efficiency of pointers with the simplicity of regular variables:
void processVideo(VideoFile& video) {
video.metadata = "processed";
// Direct access, no copies, no null checks!
}
Enter fullscreen mode
Exit fullscreen mode
This guide will take you from reference basics to advanced techniques, showing you how references are not just a convenience feature but a cornerstone of modern C++ design.
Table of Contents
Understanding References: Your First Alias
The Three Fundamental Rules
Pass by Value vs Pass by Reference
Const References: The Performance Sweet Spot
References vs Pointers: Choosing Your Tool
Common Pitfalls and How to Avoid Them
Modern C++ and References
Best Practices and Conclusion
Understanding References: Your First Alias
What Exactly Is a Reference?
A reference is an alias — another name for an existing variable. It's not a copy, not a pointer, but literally another name for the same object in memory.
Think of it like a nickname:
When your friends call you by your nickname, they're still talking to you
Any changes they make to "the person with that nickname" affect the real you
You can't have a nickname without a person to attach it to
#include <iostream>
using namespace std;
int main() {
int originalValue = 42;
int& alias = originalValue;
// alias is now another name for originalValue
cout << "Original: " << originalValue << endl;
// 42
cout << "Alias: " << alias << endl;
// 42
alias = 100;
// Changing through alias...
cout << "Original after change: " << originalValue << endl;
// 100!
// They even have the same memory address
cout << "Address of original: " << &originalValue << endl;
cout << "Address of alias: " << &alias << endl;
// Same address!
}
Enter fullscreen mode
Exit fullscreen mode
Why References Matter in C++ Philosophy
References embody three core C++ principles:
"You don't pay for what you don't use" — No unnecessary copies
"Make interfaces easy to use correctly and hard to use incorrectly" — Cleaner than pointers
"Trust the programmer" — Direct memory access without safety wheels
References enable features like operator overloading that feels natural, STL containers that are both safe and fast, and move semantics in modern C++.
The Three Fundamental Rules
Every reference follows three unbreakable rules. Master these, and you'll avoid 90% of reference-related bugs.
Rule 1: References Must Be Initialized
Unlike pointers, you can't create an "empty" reference and fill it later:
// ❌ ILLEGAL - Won't compile
int& ref;
// Error: references must be initialized
// ✅ CORRECT
int value = 10;
int& ref = value;
// ref is now bound to value forever
Enter fullscreen mode
Exit fullscreen mode
This constraint makes references safer — there's no such thing as a "null reference" in valid C++ code.
Rule 2: References Cannot Be Reseated
Once bound to an object, a reference cannot be changed to refer to another object:
int first = 5, second = 10;
int& ref = first;
// ref is now an alias for first
ref = second;
// What happens here?
// This does NOT make ref refer to second!
// Instead, it assigns second's value (10) to first
cout << first;
// 10 - first's value changed
cout << second;
// 10 - second unchanged
cout << ref;
// 10 - ref still refers to first
Enter fullscreen mode
Exit fullscreen mode
This behavior often surprises newcomers but makes perfect sense: if ref is truly an alias for first, then ref = second is exactly the same as first = second.
Rule 3: Type Compatibility Rules
Non-const references require exact type matches:
int x = 42;
int& ref = x;
// ✅ OK - exact match
int& ref2 = 42;
// ❌ Error - can't bind to literal
double d = 3.14;
int& ref3 = d;
// ❌ Error - type mismatch
Enter fullscreen mode
Exit fullscreen mode
But const references have a superpower — they can bind to temporaries:
const int& ref = 42;
// ✅ OK - binds to temporary
const int& ref2 = 3.14;
// ✅ OK - creates temporary int(3)
// This enables elegant function interfaces:
void print(const string& s);
print("Hello");
// Works! Temporary string created
Enter fullscreen mode
Exit fullscreen mode
The compiler creates a temporary object and extends its lifetime to match the const reference. This is why const& parameters are so common in C++ — they accept both variables and temporaries efficiently.
Pass by Value vs Pass by Reference
Understanding the Cost of Copies
Let's visualize what happens with different passing mechanisms:
class ExpensiveObject {
vector<int> data;
public:
ExpensiveObject() : data(1000000) {
// 1 million integers
cout << "Constructor called\n";
}
ExpensiveObject(const ExpensiveObject& other) : data(other.data) {
cout << "COPY Constructor called - Expensive!\n";
}
};
// Pass by value - makes a copy
void byValue(ExpensiveObject obj) {
// obj is a complete copy - ~4MB duplicated!
}
// Pass by reference - no copy
void byReference(ExpensiveObject& obj) {
// obj is an alias - no memory overhead
}
// Pass by const reference - no copy, can't modify
void byConstReference(const ExpensiveObject& obj) {
// Best of both worlds for read-only access
}
Enter fullscreen mode
Exit fullscreen mode
When to Use Each Approach
Here's a practical decision tree:
// Small, cheap-to-copy types: pass by value
void processInt(int x);
void processChar(char c);
void processBool(bool flag);
// Large objects for read-only: pass by const reference
void printVector(const vector<int>& v);
void displayImage(const Image& img);
// Need to modify: pass by non-const reference
void sortVector(vector<int>& v);
void normalizeImage(Image& img);
// Optional/nullable: use pointer
void processIfAvailable(Data* data) {
if (data) {
// Process data
}
}
Enter fullscreen mode
Exit fullscreen mode
The Power of Return by Reference
References enable elegant APIs, especially for operators:
class Matrix {
vector<vector<double>> data;
public:
// Return reference allows: matrix[i][j] = value
vector<double>& operator[](size_t row) {
return data[row];
}
// Const version for const matrices
const vector<double>& operator[](size_t row) const {
return data[row];
}
};
int main() {
Matrix m(3, 3);
m[1][2] = 5.0;
// Natural syntax thanks to reference return
}
Enter fullscreen mode
Exit fullscreen mode
Const References: The Performance Sweet Spot
Why Const References Are Everywhere
Const references solve a fundamental dilemma in C++: how to pass objects efficiently while preventing accidental modification.
// Problem: Expensive copy
string concatenate_bad(string s1, string s2) {
// Copies both strings!
return s1 + s2;
}
// Problem: Can modify arguments
string concatenate_dangerous(string& s1, string& s2) {
s1 += "oops";
// Accidentally modified caller's string!
return s1 + s2;
}
// Solution: Const references
string concatenate_good(const string& s1, const string& s2) {
// ✅ No copies
// ✅ Can't modify arguments
// ✅ Can accept temporaries
return s1 + s2;
}
// Usage
string result = concatenate_good("Hello, ", "World!");
// Works with temporaries!
Enter fullscreen mode
Exit fullscreen mode
The Temporary Lifetime Extension Magic
One of const references' most powerful features is extending temporary lifetimes:
// Without const reference - temporary destroyed immediately
string getString() { return "temporary"; }
// ❌ Dangling reference - undefined behavior!
// string& bad = getString();
// Error: can't bind non-const ref to temporary
// ✅ Const reference extends temporary's lifetime
const string& good = getString();
// Temporary lives as long as 'good'
cout << good;
// Safe to use!
// Practical example: avoiding copies in loops
vector<string> getNames() {
return {"Alice", "Bob", "Charlie"};
}
// Efficient iteration without copies
for (const string& name : getNames()) {
cout << name << " ";
}
Enter fullscreen mode
Exit fullscreen mode
References vs Pointers: Choosing Your Tool
The Complete Comparison
Let's settle the references vs pointers debate with a comprehensive comparison:
void demonstrateReferences() {
int x = 42;
int& ref = x;
// Natural syntax
ref = 100;
int y = ref + 10;
// No null checks needed
processValue(ref);
// No arithmetic
// ref++;
// Increments value, not reference
// Single level only
int& ref2 = ref;
// Just another alias to x
}
void demonstratePointers() {
int x = 42;
int* ptr = &x;
// Explicit dereferencing
*ptr = 100;
int y = *ptr + 10;
// Null checks required
if (ptr) {
processValue(*ptr);
}
// Arithmetic allowed
int arr[] = {1, 2, 3};
int* p = arr;
p++;
// Points to arr[1]
// Multiple levels
int** ptr2 = &ptr;
// Pointer to pointer
}
Enter fullscreen mode
Exit fullscreen mode
Decision Matrix
Scenario
Use Reference
Use Pointer
Example
Function parameter (non-null)
✅
❌
void process(Data& d)
Optional parameter
❌
✅
void process(Data* d)
Class member (always valid)
✅
❌
class A { B& b; }
Polymorphic member
❌
✅
class A { Base* ptr; }
Container element
❌
✅
vector<int*> ptrs
Operator overloading
✅
❌
T& operator[]
Dynamic allocation
❌
✅
new, delete
Array iteration
❌
✅
Pointer arithmetic
Common Pitfalls and How to Avoid Them
Pitfall 1: The Dangling Reference
The most dangerous reference mistake is returning a reference to a local variable:
// ❌ NEVER DO THIS
const string& getDangerous() {
string local = "I'm temporary!";
return local;
// local is destroyed when function ends!
}
// ✅ SAFE ALTERNATIVES
// Option 1: Return by value
string getSafe() {
return "I'm a copy!";
}
// Option 2: Return reference to static
const string& getStatic() {
static string persistent = "I live forever!";
return persistent;
}
// Option 3: Return reference to member
class SafeContainer {
string data = "I'm a member!";
public:
const string& getData() const { return data; }
};
Enter fullscreen mode
Exit fullscreen mode
Pitfall 2: The Reseating Misconception
Many beginners expect this to work:
int a = 5, b = 10;
int& ref = a;
// Expectation: ref now refers to b
// Reality: a now has the value 10
ref = b;
// Proof that ref still refers to a:
b = 20;
cout << ref;
// Still 10, not 20!
// If you need to switch what you're referencing, use a pointer:
int* ptr = &a;
ptr = &b;
// Now ptr points to b
Enter fullscreen mode
Exit fullscreen mode
Pitfall 3: Range-Based Loop Mishaps
vector<string> words = {"hello", "world"};
// ❌ Inefficient - copies each string
for (string word : words) {
word += "!";
// Modifies copy only
}
// ✅ Efficient modification
for (string& word : words) {
word += "!";
// Modifies original
}
// ✅ Efficient read-only access
for (const string& word : words) {
cout << word;
// No copy
}
Enter fullscreen mode
Exit fullscreen mode
Modern C++ and References
Move Semantics and Rvalue References (C++11)
C++11 introduced rvalue references (&&) to enable move semantics:
class Buffer {
unique_ptr<char[]> data;
size_t size;
public:
// Copy constructor - expensive
Buffer(const Buffer& other)
: data(make_unique<char[]>(other.size)), size(other.size) {
memcpy(data.get(), other.data.get(), size);
}
// Move constructor - cheap
Buffer(Buffer&& other) noexcept
: data(std::move(other.data)), size(other.size) {
other.size = 0;
// other is now empty but valid
}
};
// Automatic move from temporary
Buffer createBuffer() {
Buffer temp(1024);
return temp;
// Moved, not copied!
}
Buffer b = createBuffer();
// No copy!
Enter fullscreen mode
Exit fullscreen mode
Structured Bindings (C++17)
C++17 made references even more convenient with structured bindings:
map<string, int> scores = {{"Alice", 95}, {"Bob", 87}};
// Old way
for (const auto& pair : scores) {
const string& name = pair.first;
int score = pair.second;
cout << name << ": " << score << "\n";
}
// C++17 way with structured bindings
for (const auto& [name, score] : scores) {
cout << name << ": " << score << "\n";
}
// Modifying through structured bindings
for (auto& [name, score] : scores) {
score += 5;
// Bonus points for everyone!
}
Enter fullscreen mode
Exit fullscreen mode
Best Practices and Conclusion
The Reference Best Practices Checklist
✅ DO:
Use const& for large read-only parameters
Return by const& when returning members
Initialize all references immediately
Use references for non-null parameters
Prefer references over pointers when null isn't needed
❌ DON'T:
Return references to local variables
Try to reseat references
Forget const when you don't need to modify
Use reference members unless necessary
Create containers of references (use pointers or reference_wrapper)
Performance Guidelines
// Small types (≤ 16 bytes typically): pass by value
void process(int x);
void process(double d);
void process(Point2D p);
// struct { float x, y; }
// Large types: pass by const reference
void process(const string& s);
void process(const vector<int>& v);
void process(const Matrix& m);
// Need to modify: non-const reference
void modify(string& s);
void sort(vector<int>& v);
// Factory functions: return by value (RVO/NRVO)
Widget createWidget() {
return Widget(...);
}
// Accessors: return by const reference
class Container {
Data data;
public:
const Data& getData() const { return data; }
};
Enter fullscreen mode
Exit fullscreen mode
The Mental Model
Think of references as permanent aliases:
Once created, they're welded to their target
They're not objects themselves, just alternate names
They make your code express intent clearly
Think of pointers as flexible arrows:
They can point anywhere (including nowhere)
They're actual objects that store addresses
They give you maximum control and flexibility
Conclusion
References are one of C++'s most elegant features, solving the fundamental problem of efficient parameter passing while maintaining clean syntax. They're not just syntactic sugar over pointers — they're a deliberate design choice that enables:
Performance without complexity
Operator overloading that feels natural
Modern C++ features like move semantics
Cleaner, safer APIs
Master references, and you'll write C++ that's both efficient and expressive. They're the bridge between low-level control and high-level abstractions — embodying the very essence of what makes C++ unique among programming languages.
Remember: When in doubt, use references for guaranteed-valid aliases and pointers for optional or dynamic relationships. This simple rule will guide you through most design decisions.
Frequently Asked Questions
Q: Can I create an array of references?
A: No, you can't create containers of references directly. Use std::reference_wrapper instead:
// ❌ Won't compile
vector<int&> refs;
// ✅ Use reference_wrapper
vector<reference_wrapper<int>> refs;
int a = 1, b = 2;
refs.push_back(ref(a));
refs.push_back(ref(b));
refs[0].get() = 10;
// Modifies 'a'
Enter fullscreen mode
Exit fullscreen mode
Q: What's the difference between T& and T&&?
A: T& is an lvalue reference (regular reference), T&& is an rvalue reference (for move semantics):
void func(string& s);
// Lvalue reference - binds to variables
void func(string&& s);
// Rvalue reference - binds to temporaries
Enter fullscreen mode
Exit fullscreen mode
Q: Why can't I return a reference to a local variable?
A: Local variables are destroyed when the function ends, leaving you with a dangling reference:
string& bad() {
string local = "temp";
return local;
// ❌ 'local' destroyed after return
}
// Any use of the returned reference is undefined behavior
Enter fullscreen mode
Exit fullscreen mode
Q: Are references faster than pointers?
A: Performance is typically identical. References are a compile-time abstraction - they often compile to the same assembly as pointers.
Q: Can references be null?
A: No, valid C++ references cannot be null. However, you can create dangling references through undefined behavior:
int& getRef() {
int x = 42;
return x;
// ❌ Undefined behavior - creates "dangling reference"
}
Enter fullscreen mode
Exit fullscreen mode
References vs Pointers: The Complete Comparison
Both references and pointers provide indirect access to objects, but they differ significantly in syntax, safety, and flexibility.
Think of it this way:
Pointer = A variable that stores an address (like a GPS coordinate)
Reference = An alias/nickname for an existing variable (like calling someone by their nickname)
Key Differences Overview
Feature
Reference
Pointer
Syntax
Clean (ref = 10)
Requires operators (*ptr = 10)
Initialization
Must be initialized
Can be uninitialized
Null value
Cannot be null
Can be null
Reassignment
Cannot be reseated
Can point to different objects
Arithmetic
No arithmetic allowed
Pointer arithmetic allowed
Memory overhead
No extra memory
Takes memory (size of address)
Indirection levels
Single level only
Multiple levels (int**)
1. Initialization Requirements
// References MUST be initialized
int x = 10;
int& ref = x;
// ✅ OK
int& ref2;
// ❌ ERROR: references must be initialized
// Pointers can be uninitialized (dangerous!)
int* ptr;
// ⚠️ Uninitialized pointer (garbage value)
int* ptr2 = nullptr;
// ✅ Explicitly null
int* ptr3 = &x;
// ✅ Points to x
Enter fullscreen mode
Exit fullscreen mode
2. Null Values
// References cannot be null
int& ref = nullptr;
// ❌ ERROR: invalid initialization
// Pointers can be null
int* ptr = nullptr;
// ✅ OK
if (ptr != nullptr) {
// Safe to use
}
Enter fullscreen mode
Exit fullscreen mode
This makes references inherently safer — no null reference checks needed!
3. Reassignment Behavior
int a = 5, b = 10;
// Reference: Cannot be reseated
int& ref = a;
ref = b;
// This assigns b's VALUE to a, doesn't make ref refer to b
cout << a;
// 10 (a's value changed)
cout << &ref;
// Still same address as &a
// Pointer: Can be reassigned
int* ptr = &a;
ptr = &b;
// Now ptr points to b
*ptr = 20;
// Changes b, not a
cout << a;
// 5 (unchanged)
cout << b;
// 20 (changed)
Enter fullscreen mode
Exit fullscreen mode
4. Syntax Comparison
void doubleValue_ref(int& x) {
x *= 2;
// Clean, looks like normal variable
}
void doubleValue_ptr(int* x) {
*x *= 2;
// Must dereference with *
}
int main() {
int val = 10;
doubleValue_ref(val);
// Clean syntax
doubleValue_ptr(&val);
// Explicit address-of
}
Enter fullscreen mode
Exit fullscreen mode
5. Pointer Arithmetic vs No Reference Arithmetic
int arr[] = {1, 2, 3, 4, 5};
// Pointer arithmetic is allowed
int* ptr = arr;
ptr++;
// Move to next element
cout << *ptr;
// 2
ptr += 2;
// Jump 2 elements
cout << *ptr;
// 4
// Reference arithmetic is NOT allowed
int& ref = arr[0];
ref++;
// ❌ This increments the VALUE, not the reference
Enter fullscreen mode
Exit fullscreen mode
6. Multiple Levels of Indirection
// Pointers can have multiple levels
int x = 10;
int* ptr = &x;
// Pointer to int
int** ptr2 = &ptr;
// Pointer to pointer to int
cout << **ptr2;
// 10 (double dereference)
// References only have one level
int& ref = x;
// Reference to int
// Cannot create reference to reference
Enter fullscreen mode
Exit fullscreen mode
When to Use Each
Use References When:
Function parameters that must exist: void process(Data& d)
Operator overloading: T& operator[](size_t index)
Clean, simple syntax needed
Range-based loops: for(auto& item : container)
Use Pointers When:
Optional parameters: void process(Data* d) (can be null)
Dynamic allocation: new, delete, smart pointers
Data structures: linked lists, trees (need null for "empty")
Pointer arithmetic: array traversal
Multiple indirection levels needed
Resources for Further Learning
Official Documentation
C++ Reference - Comprehensive reference documentation
ISO C++ Core Guidelines - Modern C++ best practices
Books
"Effective C++" by Scott Meyers - Essential reference techniques (Items 20-25)
"A Tour of C++" by Bjarne Stroustrup - Creator's guide to modern C++
"C++ Primer" by Lippman, Lajoie & Moo - In-depth coverage of references
Online Resources
C++ Weekly - Jason Turner's practical C++ tips
CppCon Talks - Conference presentations on advanced topics
Compiler Explorer - See how references compile to assembly
Practice Platforms
LeetCode C++ - Algorithm problems using C++
HackerRank C++ - Structured C++ challenges
Codewars C++ - Community-driven coding challenges
What's Next?
This article is part of my C++ Advanced Concepts series. Coming up next:
Deep Dive into Pointers
Deep Dive into Memory Management
Found this article helpful? Have questions about references or other C++ features? Let me know in the comments below!
C++ Advanced Concepts (2 Part Series)
1
C++ Templates Tutorial: Complete Guide to Generic Programming (2025) (With Examples)
2
C++ References Tutorial: Complete Guide to Aliases, Performance, and Modern C++ (2025)
Top comments (1)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Collapse
Expand
Ana Flávia
Ana Flávia
Ana Flávia
Follow
Joined
Sep 26, 2025
•
Sep 26
Dropdown menu
Copy link
Hide
I loved how you explained the difference between references and pointers! Even without understanding every technical detail, it’s clear how mastering these tools makes code more elegant and efficient. Great article, super clear and inspiring!
Like comment:
Like comment:
1 like
Like
Comment button
Reply
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Basil Abu-Al-Nasr
Follow
Competitive Programmer || Instructor
Pronouns
He / Him
Work
Instructor
Joined
Aug 31, 2025
More from Basil Abu-Al-Nasr
C++ Templates Tutorial: Complete Guide to Generic Programming (2025) (With Examples)
#cpp
#programming
#tutorial
#beginners
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account