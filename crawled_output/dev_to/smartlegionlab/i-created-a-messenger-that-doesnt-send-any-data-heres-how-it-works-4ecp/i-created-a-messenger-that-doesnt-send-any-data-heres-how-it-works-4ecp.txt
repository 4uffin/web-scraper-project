Chrono-Library Messenger: How to send a message without transmitting a single bit.💫 - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Alexander Suvorov
Posted on Sep 14
• Edited on Sep 18
Chrono-Library Messenger: How to send a message without transmitting a single bit.💫
#cryptography
#privacy
#security
#cybersecurity
What if I told you that you could send a message without transmitting a single bit of information? No encrypted packets, no metadata, nothing. It sounds like magic, but it's actually cryptography. Let me introduce you to Chrono-Library Messenger (CLM) — a Python CLI tool that rethinks secure communication from the ground up.
🤔 The Flaw in the Foundation
Our digital world is built on a simple premise: to communicate, we must send data.
Whether it's a WhatsApp message, an email, or a Signal call, the model is the same: data is packaged, encrypted, and transmitted from A to B. This has inherent weaknesses:
📡 Metadata Leaks: Even if the message is encrypted, everyone can see who is talking to whom, when, and how often.
🎯 It's a Target: The communication channel itself can be blocked, monitored, or attacked (e.g., DDoS).
⏳ It's Ephemeral: It relies on services, servers, and infrastructure that may not exist tomorrow.
What if we could remove the channel entirely?
💡 The Insight: What if We Send Nothing?
CLM is based on a radical idea: What if there is no data transmission? Instead, two parties synchronously extract the message from a shared, predetermined pseudorandom sequence — an "Eternal Library."
You don't send messages. You publish index. The recipient recreates the message locally using the same coordinates and a shared secret.
🧙‍♂️ The Magic Trick: How It Works
Let's use a simple metaphor. Imagine you and a friend have an identical, infinite book of random numbers (the Eternal Library).
To "send" a message: You agree on a specific page and line in this book. You take your message and combine it (using XOR) with the random numbers on that line. You then publicly tell your friend: "Look at page 1736854567, line 'general_chat'." You never send the message itself or the random numbers.
To "receive" a message: Your friend opens their identical copy of the book to the exact same page and line. They take the numbers from that line and combine them (XOR) with the data you posted. Like magic, the original message appears.
The message never left your device. Only the coordinates—the pointer—were shared. The message was "extracted" from a shared, pre-synchronized data structure.
⚙️ The Technical Spellbook
This magic is powered by a few key ingredients:
🗝️ The Shared Secret (master_seed): A pre-shared passphrase that seeds our entire "Library." Without it, the pointers are useless noise.
💬 Chat Realms (seed_suffix): Each chat has a unique suffix (e.g., general, secrets), creating separate sections within the Library.
⏰ Time as a Page Number (epoch_index): We use the current Unix time as the "page number" to ensure we're always looking at a new, unique page. This makes every message unique.
📘 HMAC_DRBG: A cryptographically strong Deterministic Random Bit Generator based on HMAC-SHA256. It generates a predictable, endless stream of random-looking data from our seed. This is our "book."
🔁 XOR Cipher: The humble XOR operation is used for "encryption." It's perfect because it's reversible: (message XOR key) XOR key = message.
Here's the core code that makes it happen:
Generating the "page" of the book (the key):
# The seed is a combination of master_seed, chat suffix, and current time
seed_material = f"{master_seed}_{chat_seed_suffix}_{epoch_index}".encode()
drbg = HMAC_DRBG(seed_material) # Initialize our generator
key_bytes = drbg.generate(len(message_bytes)) # Generate the key from this "page"
Enter fullscreen mode
Exit fullscreen mode
"Encrypting" and "decrypting" the message:
def encrypt_decrypt(data, key):
return bytes([d ^ k for d, k in zip(data, key)])
# Sender's side
ciphertext = encrypt_decrypt(message_bytes, key_bytes)
# Receiver's side
decrypted_bytes = encrypt_decrypt(ciphertext, key_bytes)
message = decrypted_bytes.decode('utf-8')
Enter fullscreen mode
Exit fullscreen mode
The public pointer is just a JSON object:
{
"c": "1",
"e": 1736854567,
"d": "8d3e12a45b..."
}
Enter fullscreen mode
Exit fullscreen mode
c: Chat ID (the bookshelf)
e: Epoch index (the page number)
d: Ciphertext (the result of XOR)
🌟 Why This is So Powerful (And a Little Crazy)
🌐 Does not depend on the Internet: You don't need the internet to "send" a message. You can communicate the pointer via SMS, a QR code, a post on social media, or a note in a tree hole. The channel doesn't matter.
👻 Plausible Deniability: The pointer {"c": "1", "e": 1736854567, "d": "a1b2c3..."} is indistinguishable from random junk. "This? It's just a JSON config for my coffee machine."
🖥️ No Server, No Provider: There is no middleman. Everything is stored locally on your device.
♾️ Eternal: If you have the shared secret and the pointer, you can decode the message 100 years from now. No servers required.
🌌 The Conceptual Implications
This is where the technical implementation becomes philosophically fascinating.
The Library, once seeded, is static and deterministic. From the moment you and your friend agree on the secret, every message you will ever exchange is already written. It has always existed.
You are not a sender; you are an explorer, uncovering a message that was always present at that exact location.
You are not creating information; you are accessing it.
The marker is not a coordinate; it is a reference point that allows two people to simultaneously access a pre-existing truth.
The message wasn't "sent" today. It was always present in the fabric of your shared reality. You simply agreed on when to access it.
In my next article, you can look at this idea from a completely different angle. The magic of messages that have always been with us
⚠️ The Inevitable Limitations
This is an experimental version and not a daily use product.
🔑 The Key Exchange Problem: You still need to share the master_seed securely (e.g., in person). It doesn't solve the initial key distribution.
📊 Metadata: While the message is hidden, the chat ID (c) and timestamp (e) in the pointer are public.
🔓 No Forward Secrecy: If the master_seed is compromised, all messages in all chats can be decrypted.
🎯 Conclusion: A Thought Experiment Come to Life
Chrono-Library Messenger (CLM) isn't here to replace other messengers. It's a thought experiment, a demonstration that we can look at the problem of private communication from a completely different angle. It shows that sometimes, the most secure way to send a message is not to send it at all.
If you find this concept as fascinating as I do, check out the project on GitHub, star it, and maybe even contribute! Let's discuss the future of private communication.
GitHub Repository: 👉 Alexander Suvorov / chrono-library-messenger
I was inspired by my other projects:
smartpasslib - A cross-platform Python library for generating deterministic, secure passwords that never need to be stored.
clipassman - Cross-platform console Smart Password manager and generator.
Smart Babylon Library - A Python library inspired by the Babylonian Library and my concept of smart passwords. It generates unique addresses for texts without physically storing them, allowing you to retrieve information using these addresses.
🔮 Open for Collaborations!
I'm passionate about crazy ideas, unconventional thinking, and fresh perspectives on complex problems. If you're working on something innovative and need a unique mindset, I'm always open to collaborating on exciting projects.
Get in touch: Alexander Suvorov (GitHub)
📜 Legal & Ethical Disclaimer:
Chrono-Library Messenger (CLM) is a proof-of-concept project created for academic, research, and educational purposes only. It is designed to explore alternative paradigms in communication technology. The author does not encourage or condone the use of this tool for any illegal activities or to violate the laws of any country. The mention of other messaging services is made for comparative analysis within a technological context and constitutes fair use. Users are solely responsible for ensuring their compliance with all applicable local, national, and international laws and regulations.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Alexander Suvorov
Follow
Independent researcher and developer in the field of cryptography and security. Python/Django architect. Full cycle: from architecture to production.
Work
In search of interesting projects...
Joined
Sep 14, 2025
More from Alexander Suvorov
The next step in privacy: A messenger that doesn't send data and doesn't keep your secrets. 🚀
#privacy
#cryptography
#security
#cybersecurity
The Password That Never Was: How to Access Secrets That Were Always There. Smart Password Library. 🔐
#privacy
#cryptography
#security
#cybersecurity
The magic of messages that have always been with us 🧙‍♂️
#privacy
#cryptography
#security
#cybersecurity
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Home
DEV++
Reading List
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account