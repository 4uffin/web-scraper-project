Zero to Checkout: How I Engineered a Custom Payment Gateway - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Abhishek Dwivedi
Posted on Sep 23
Zero to Checkout: How I Engineered a Custom Payment Gateway
#javascript
#tutorial
#react
#node
Most developers stick to integrating slick solutions like Stripe or Razorpay for payments. But what if you rolled up your sleeves and built your own payment gateway from scratch complete with banks, risk engines, settlements, refunds, and tokenization, just like the big fintech players?
That’s exactly what I did with PayProX. It’s a microservices-based, cloud-deployed payment gateway ecosystem built for scalability, modularity, and rock-solid security.
In this post, I’m stoked to share how I pulled it off, the lessons I learned along the way, and why this project is an awesome challenge for anyone curious about backend engineering or fintech systems.
Why I Chose to Build a Payment Gateway from Scratch
Every time you click “Pay Now,” a complex network of systems springs to life:
Your request flows to a Payment Gateway.
The Payment Processor connects with Card Networks (like Visa or MasterCard).
Your bank (the Issuer) approves or declines the transaction.
The merchant’s bank (the Acquirer) facilitates the fund settlement.
Fraud detection, tokenization, and refunds operate seamlessly behind the scenes.
I wasn’t content with just understanding this process. I wanted to create it. My mission was to dive deep into backend engineering and uncover what makes financial systems secure, scalable, and robust.
A Look at PayProX
Building a payment gateway from scratch was never about just writing code ,it was about understanding the invisible flow of money online. That’s how PayProX was born: a production-grade simulation of a real-world payment ecosystem, designed with scalability, security, and modularity in mind.
It’s a system that feels alive handling everything from a customer clicking “Pay Now,” to banks authorizing transactions, to merchants receiving their funds just like in the real world.
What Makes PayProX Special
Microservices Architecture → I split responsibilities across independent services for banks, merchants, customers, fraud checks, settlements, and tokenization. It keeps the system clean and realistic.
Cloud-Native Deployment → Frontend on Vercel, backend microservices on Render, and MongoDB Atlas powering all data, just like production setups.
Security by Design → Every sensitive action is protected: tokenization ensures card data is safe, internal authentication keeps services secure, and the risk engine catches suspicious activity.
Purpose & Scope
The goal of PayProX is to demonstrate how a secure and traceable payment system can be built from scratch. It enables developers and engineers to explore:
End-to-end transaction processing
Merchant and customer account management
Risk evaluation and fraud prevention
Tokenization and PCI-DSS aligned secure card handling
Settlement and refund workflows
While this is a simulation, the system follows industry-standard practices and provides a production-grade feel, with independently deployable microservices and secure service-to-service communication.
PCI-DSS Alignment
PayProX is designed with security at its core. Sensitive card data is never stored in raw form; instead, a tokenization system is used to safeguard credentials. The project simulates PCI-DSS compliant practices, including:
Credential isolation
Secure authentication
Fraud detection
Traceable transaction logging
This makes PayProX not only a learning tool but also a demonstration of how real-world payment gateways maintain compliance and security while processing millions of transactions.
Architecture
The PayProX ecosystem follows a modular, service-oriented architecture where each microservice handles a distinct phase of the payment lifecycle. This design ensures scalability, traceability, and separation of concerns, while enabling secure communication between services.
Service-to-Service Communication
All microservices communicate via RESTful APIs secured with internal authentication headers. This ensures:
Secure interactions: Only authorized services can access internal endpoints.
Traceability: Every request can be logged and audited.
Scalability: Each service can be deployed independently and horizontally scaled.
Data Flow
A customer initiates a payment on the merchant store.
The Merchant Service generates an order and requests a session from the Payment Gateway.
The Payment Gateway handles session creation, tokenization, and payment routing.
Transactions are screened by the Risk Engine for fraud detection.
Approved transactions are processed by the Acquirer Bank, which coordinates with the Issuer Bank for debit/credit.
Transaction metadata is persisted in MongoDB, and settlement is executed by the Settlement Engine.
Merchant & Customer Dashboards
To complement the backend microservices, PayProX includes dedicated dashboards for merchants and customers—built with React, deployed on Vercel, and secured via JWT authentication.
These dashboards simulate real-world fintech portals, enabling users to interact with the system in a secure and traceable way.
Merchant Dashboard
Purpose:
Gives merchants full control over their payment lifecycle—from order creation to settlement tracking.
Key Features:
Order Management: Deploy the store
Settlement Triggering: Manually initiate T+2 settlements
Refund Approvals: Review and approve customer refund requests
Transaction Logs: View ledger entries with timestamps and status
Authentication: JWT-secured access with role-based routing
Customer Dashboard
Purpose:
Empowers customers to manage their payment methods, view transaction history, and request refunds.
Key Features:
Stored Cards: View masked cards linked via Tokenization Service
Transaction History: See past payments with IDs and status
Refund Requests: Initiate refund flows with reason and timestamp
Authentication: JWT-secured login with session expiry enforcement.
Backend Tie-In:
Connects to Customer Service, Issuer Bank, and Payment Gateway. All sensitive operations are validated via token and internal service headers
Meet the Services of PayProX
PayProX isn’t a monolith. it’s a constellation of microservices, each with a focused responsibility and hardened security. Here's how they work together:
Merchant Service
Role
Handles merchant onboarding, authentication, order creation, settlement triggers, and refund approvals.
Security Highlights
JWT authentication for merchants
verifyToken middleware ensures only authorized merchants can manage orders
Settlement actions require secure internal API calls to Acquirer Bank
Customer Service
Role
Manages customer registration, authentication, stored payment methods, and refund requests.
Security Highlights
Token-based authentication protects customer data
Sensitive payment info is never stored directly, linked via the Tokenization Service
Service-to-service validation restricts sensitive operations to trusted services
Payment Gateway Service
Role
Acts as the orchestration layer , manages sessions, initiates payments/refunds, and routes requests between banks.
Security Highlights
JWT-secured customer flows (verifyCustomerToken)
Internal communication via internalAuth headers
Tokenization ensures no raw card data is stored or transmitted
Sessions expire after 10 minutes to reduce attack surface
Acquirer Bank Service
Role
Manages merchant accounts, balances, and transaction debits/credits.
Security Highlights
Only trusted internal services can initiate balance updates
Middleware validates internal tokens for account access
Ledger updates are fully traceable for audits
Issuer Bank Service
Role
Manages customer accounts, validates balances, and processes payments/refunds.
Security Highlights
Netbanking login requires valid session tokens
Debit/credit operations are idempotent and logged
Exposes only internal APIs that means no public access
Risk Engine Service
Role
Detects fraud using velocity checks, blacklist rules, and amount thresholds.
Security Highlights
Stateless analysis prevents session hijacking
Dynamic updates to blacklist and velocity thresholds
Suspicious requests blocked before reaching banks
Settlement Engine Service
Role
Handles T+2 settlement logic, merchant payouts, and reconciliation.
Security Highlights
Only merchants can trigger settlements (manual today, automated soon)
Internal authentication required for Acquirer credit operations
Duplicate settlements prevented via transaction state management
Tokenization Service
Role
Replaces sensitive card data with unique, irreversible tokens.
Security Highlights
PCI-DSS aligned—no raw card data stored
Only last 4 digits + expiry stored for reference
Token verification prevents replay attacks and ensures authenticity
Final Thoughts
PayProX isn’t just a side project, it’s a deep dive into the architecture, security, and complexity of real-world financial systems. From tokenization to fraud detection, every service is designed to reflect production-grade thinking.
Whether you're a backend engineer curious about fintech, a recruiter evaluating system design skills, or a developer looking to build secure, scalable microservices. PayProX is proof that you don’t need billion-dollar infrastructure to simulate billion-dollar flows.
I built this to learn, to challenge myself, and to show what’s possible when you combine curiosity with clean architecture.
Let’s Connect
If you’re hiring, collaborating, or just curious about how this works under the hood, I’d love to chat.
Check out the GitHub repo, explore the live demo, or reach out on LinkedIn.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Abhishek Dwivedi
Follow
Full-stack engineer diving deep into fintech. I love breaking down complex systems — from building a payment gateway from scratch to experimenting with microservices and secure architectures.
Joined
Sep 11, 2025
Trending on DEV Community
Hot
I built MineSafety: A Powerful Incident & Safety Tracker for Mines
#devchallenge
#kendoreactchallenge
#react
#webdev
Meme Monday
#discuss
#watercooler
#jokes
3 Reasons You're in Tech Post-Layoff Shock (Based on personal experience)
#career
#beginners
#learning
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Página Inicial
DEV++
Welcome Thread
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
Sobre
Contato
Free Postgres Database
Software comparisons
Forem Shop
Código de Conduta
Política de Privacidade
Termos de Uso
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account