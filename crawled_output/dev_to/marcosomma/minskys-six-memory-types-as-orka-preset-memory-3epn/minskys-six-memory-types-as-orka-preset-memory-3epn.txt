üß†Minsky‚Äôs six memory types as Orka preset memory. - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Mak S√≤
Posted on Sep 18
üß†Minsky‚Äôs six memory types as Orka preset memory.
#ai
#opensource
#rag
#llm
Orka (24 Part Series)
1
üß† Orka: A Manifesto for transparent Intelligence
2
üß† OrKa run locally
...
20 more parts...
3
üß† OrKa Diaries: The Origin of a Reasoning Engine (Episode 1)
4
üß† I Couldn't Take It Anymore. So I Built OrKa.
5
üß† My First Rosetta Stone: When OrKa Proved AI Can Think Structurally
6
üß† Real-Time Cognition: Building an Observable TUI for AI Memory in OrKa
7
üß† Emergent Thought Through Looped Conflict
8
üß† Beyond Structured Chaos
9
üß† OrKa Cognitive Iteration Benchmark. Full Technical Report
10
üß† LoopNode: How OrKa Orchestrates Iterated Thought Until Agreement Emerges
11
üß† How AI Agents Learned to Agree Through Structured Debate
12
üß† How DeepSeek-R1 Transformed AI Reasoning Economics
13
üß†OrKa-ui show what is the benefit of having TTL at memory level in orka-reasoning
14
üß† orka-reasoning TUI show TTL and memory storage.
15
üß† Why LangGraph Loops Stall Thought and OrKa Doesn't
16
üß† When a System Notices Itself
17
üß† Local, Trustable and Explainable AI. Not a dream!
18
üß† I Didn't Know Where It Was Going. I Just Kept Going.
19
üß†OrKa onboarding: example suite, guided tour, and trace replay
20
üß†Can AI Learn to Care?
21
üß†OrKA-Reasoning: How Workflow Execution Really Works
22
üß†From 77% to 92%: How Orka-Reasoning Turns GPT-oss:20B Into a Math Reasoning Powerhouse
23
üß†Loop of Truth: From Loose Tricks to Structured Reasoning
24
üß†Minsky‚Äôs six memory types as Orka preset memory.
I hate cargo-cult ‚Äúmemory.‚Äù Shovel everything into a vector DB and call it cognition. No. If you want modular cognition and predictable behavior, memory needs intent. OrKa‚Äôs v0.9.2 presets do exactly that by mapping Marvin Minsky‚Äôs six memory types to operation-aware configurations. Same preset, different defaults for read vs write. That single idea kills 30 line YAML blobs and the footguns that come with them.
What ‚Äúoperation aware‚Äù really means
Every memory agent declares an operation: read or write. The preset detects the operation and applies tuned defaults for that path. So a single episodic preset behaves one way when you retrieve context and another when you persist a conversation. It makes the config human readable and keeps your graphs clean.
# Read with episodic preset
- id: memory_search
type: memory
memory_preset: episodic
config:
operation: read
namespace: conversations
# Write with the same preset
- id: memory_store
type: memory
memory_preset: episodic
config:
operation: write
namespace: conversations
Enter fullscreen mode
Exit fullscreen mode
Under the hood this flips similarity thresholds, temporal weighting, vector settings, and indexing parameters without you hand tuning every agent.
Minsky‚Äôs six, translated to knobs that matter
You do not need a lecture. You need a mapping you can ship with. Here is the short version of each preset and what changes between read and write. The durations and defaults below come from the preset docs and agent guide.
1. sensory
Use for real time signals. Think IoT, telemetry, short lived buffers.
Read: tiny result set, very high precision.
Write: skip heavy indexing to keep ingestion hot. Duration about 15 minutes.
2. working
Use for active sessions and temporary calculations.
Read: context aware search with session bias.
Write: enable vector indexing but keep it volatile. Duration 2 to 8 hours.
3. episodic
Use for conversations and interaction history.
Read: conversational retrieval with temporal ranking.
Write: rich metadata and conversation oriented indexing. Duration 1 day to 1 week.
4. semantic
Use for facts and documentation.
Read: knowledge matching with no time bias.
Write: long term indexing tuned for recall. Duration 3 days to 90 days.
5. procedural
Use for workflows and skills.
Read: pattern recognition focus.
Write: process oriented storage. Duration 1 week to 6 months.
6. meta
Use for system introspection and performance.
Read: high precision analysis.
Write: quality tuned indexing. Duration 2 days to 1 year.
If you remember nothing else: preset names are cognitive, the applied defaults are operational. That is the point.
Why presets beat hand rolled configs
Before presets you wrote 30 to 50 lines per agent. Decay rules, importance multipliers, vector flags, field names, temporal weights, context weights. Easy to drift. Easy to break. Presets collapse this to one line while preserving the ability to override single values when you genuinely need to. The docs show the before vs after with a ridiculous manual block and the clean preset version. Use the clean one.
from orka.memory.presets import get_memory_preset, merge_preset_with_config
base = get_memory_preset("episodic")
final = merge_preset_with_config("episodic", {"default_long_term_hours": 240})
Enter fullscreen mode
Exit fullscreen mode
That is how you keep intent first and keep your YAML sane.
Backend choice and the honest performance path
Run RedisStack for production. You want HNSW vector search, sub millisecond lookups, and proper monitoring commands. You can limp on basic Redis for dev, but you lose vector indexing and speed. Pick the right tool. The backend guide is blunt about this with exact env vars, Docker snippets, and FT.INFO checks.
Patterns that actually work
Conversational memory
Orchestrator preset episodic. Writer with episodic. Reader with episodic and temporal ranking for last N turns. It feels obvious because it is. The agent guide gives a clean pattern with limit, similarity threshold, and context toggles.
Knowledge capture
Run a semantic writer behind your fact extractor. Keep your conversation writer separate. Different presets. Different lifecycles. Cleaner behavior. The preset doc even shows mixing episodic, semantic, and meta cleanly in one graph.
System self awareness
Meta preset for performance logs and health. Read with higher precision. Write with quality indexing. Useful for trace explainability and post mortems.
Decay, importance, and lifecycle
Memory that never forgets is a liability. Set short term and long term windows. Boost critical or frequently accessed items. Decay debug spam quickly. The system guide shows a sane starting point for decay and importance rules plus CLI commands for stats, cleanup, and watch. Ship those defaults, then tune.
Guardrails I expect you to add
Presets are only as good as validation. The docs expose listing and inspection functions. Use them in CI. Assert that preset names resolve and the effective config matches what your team expects. Run a smoke query against RedisStack with FT.INFO to catch missing indexes fast.
Minimal starter graph you can copy
orchestrator:
id: assistant
strategy: sequential
memory_preset: episodic
agents:
- id: conversation_reader
type: memory
memory_preset: episodic
config:
operation: read
namespace: conversations
params:
limit: 5
similarity_threshold: 0.6
enable_temporal_ranking: true
- id: respond
type: builder
prompt: |
Using context from {{ previous_outputs.conversation_reader }}, answer the user.
- id: conversation_writer
type: memory
memory_preset: episodic
config:
operation: write
namespace: conversations
Enter fullscreen mode
Exit fullscreen mode
Swap in semantic for a knowledge agent, meta for system metrics, procedural for workflow learning. That is all you need to get real lift without wrecking your config.
Final take
Minsky‚Äôs categories give you a mental model that matches how systems behave in the wild. OrKa‚Äôs presets map that model to real parameters so you stop fighting YAML and start shaping behavior. Operation aware defaults are the killer feature here. You will cut noise, reduce drift, and make your orchestration explainable. If you care about modular cognition and memory guided execution, this is the sane path.
If you ship this, measure retrieval lift, not vibes. Track hit rate, average similarity, latency, and answer quality before and after memory. The preset API gives you the stable surface to do that work.
Orka (24 Part Series)
1
üß† Orka: A Manifesto for transparent Intelligence
2
üß† OrKa run locally
...
20 more parts...
3
üß† OrKa Diaries: The Origin of a Reasoning Engine (Episode 1)
4
üß† I Couldn't Take It Anymore. So I Built OrKa.
5
üß† My First Rosetta Stone: When OrKa Proved AI Can Think Structurally
6
üß† Real-Time Cognition: Building an Observable TUI for AI Memory in OrKa
7
üß† Emergent Thought Through Looped Conflict
8
üß† Beyond Structured Chaos
9
üß† OrKa Cognitive Iteration Benchmark. Full Technical Report
10
üß† LoopNode: How OrKa Orchestrates Iterated Thought Until Agreement Emerges
11
üß† How AI Agents Learned to Agree Through Structured Debate
12
üß† How DeepSeek-R1 Transformed AI Reasoning Economics
13
üß†OrKa-ui show what is the benefit of having TTL at memory level in orka-reasoning
14
üß† orka-reasoning TUI show TTL and memory storage.
15
üß† Why LangGraph Loops Stall Thought and OrKa Doesn't
16
üß† When a System Notices Itself
17
üß† Local, Trustable and Explainable AI. Not a dream!
18
üß† I Didn't Know Where It Was Going. I Just Kept Going.
19
üß†OrKa onboarding: example suite, guided tour, and trace replay
20
üß†Can AI Learn to Care?
21
üß†OrKA-Reasoning: How Workflow Execution Really Works
22
üß†From 77% to 92%: How Orka-Reasoning Turns GPT-oss:20B Into a Math Reasoning Powerhouse
23
üß†Loop of Truth: From Loose Tricks to Structured Reasoning
24
üß†Minsky‚Äôs six memory types as Orka preset memory.
Top comments (2)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Collapse
Expand
Ermes_AI
Ermes_AI
Ermes_AI
Follow
aio bio cio dio eio fio gio hio iio lio mio nio oio pio qio rio sio tio uio vio zio
Joined
Jul 15, 2025
‚Ä¢
Sep 19
Dropdown menu
Copy link
Hide
Nice approach but what if I really need my agents to remeber something for ever? Or to add to my RAG my dataset and ensure it will not get "forgotten" ?
Like comment:
Like comment:
2¬†likes
Like
Comment button
Reply
Collapse
Expand
Mak S√≤
Mak S√≤
Mak S√≤
Follow
I'm Marco Somma, a cognitive systems architect, technologist, and builder of modular reasoning tools. I‚Äôm the creator of OrKa ‚Äì an open framework for orchestrating explainable AI agents.
Email
marcosomma.work@gmail.com
Location
Barcelona, Spain
Education
Not at all
Work
AI Engineer
Joined
Apr 18, 2025
‚Ä¢
Sep 19
Dropdown menu
Copy link
Hide
Thanks! Great question!
In the 1st case if somethin really matter maybe you should store it in a no RAG solution and embed it direct in the prompt.
Second ones is more complex. Is really all the contect of your RAG relevant. a long last memory with reinforce by usage may clean up automatically over the time your maybe messy RAG solution.
Like comment:
Like comment:
1¬†like
Like
Comment button
Reply
Code of Conduct
‚Ä¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Mak S√≤
Follow
I'm Marco Somma, a cognitive systems architect, technologist, and builder of modular reasoning tools. I‚Äôm the creator of OrKa ‚Äì an open framework for orchestrating explainable AI agents.
Location
Barcelona, Spain
Education
Not at all
Work
AI Engineer
Joined
Apr 18, 2025
More from Mak S√≤
üß†Loop of Truth: From Loose Tricks to Structured Reasoning
#ai
#redis
#opensource
#machinelearning
üß†From 77% to 92%: How Orka-Reasoning Turns GPT-oss:20B Into a Math Reasoning Powerhouse
#ai
#promptengineering
#opensource
#openai
üíªThe HTML of AI: Why Prompting Isn't Enough!
#ai
#machinelearning
#programming
#promptengineering
üíé DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community ‚Äî A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Reading List
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community ¬© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account