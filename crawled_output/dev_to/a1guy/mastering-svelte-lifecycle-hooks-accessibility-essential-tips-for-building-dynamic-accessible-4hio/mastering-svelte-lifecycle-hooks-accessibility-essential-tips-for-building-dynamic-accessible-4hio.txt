Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Crypto Forem
Follow
A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis.
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Ali Aslam
Posted on Sep 13
Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps
#svelte
#webdev
#javascript
#programming
Svelte & SvelteKit Deep Dive (19 Part Series)
1
Svelte & SvelteKit Deep Dive: From Beginner to Pro
2
Why Learn Svelte in 2025? The Value Proposition & Svelte vs React & Vue
...
15 more parts...
3
Getting Started with SvelteKit: Setup, Project Structure & First App
4
Svelte Crash Course on Reactivity: How Your UI Updates Automatically
5
Svelte Components Explained: Props & Composition Made Simple
6
Svelte Events & Bindings Tutorial: Master Parent-Child Communication
7
Svelte Event Forwarding & Advanced Component Patterns
8
Conditionals in Svelte ‚Äî {#if}, {:else}, and Nesting Explained
9
Loops in Svelte ‚Äî {#each}, Keys, and Building a Todo App
10
Styling in Svelte (Scoped CSS, :global, and Class Directives)
11
Svelte Motion & Theming Guide: Transitions, Animations, and Dark Mode Explained
12
Tailwind CSS + Svelte: Utility-First Styling at Scale
13
A Beginner‚Äôs Guide to Svelte Stores (Writable, Readable, and Derived)
14
Mastering Context and Async Data in Svelte (with Examples)
15
SvelteKit Routing Tutorial: Layouts, Nested Routes & Multi-Page Apps
16
Forms in SvelteKit ‚Äî Actions, Validation & Progressive Enhancement
17
Mastering Svelte Custom Stores
18
Mastering DOM Manipulation with Svelte Actions and Children
19
Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps
Alright, so we‚Äôve already built some pretty cool stuff‚Äîpowerful stores, actions, and flexible components that talk to each other. But we‚Äôre not done yet! Two things are still missing from our toolbox:
Lifecycle hooks ‚Äî controlling when your code runs, and cleaning up when components disappear.
Accessibility (a11y) ‚Äî ensuring your components aren‚Äôt just shiny, but also usable for all users.
This article covers both: minimal, powerful lifecycle hooks and practical accessibility patterns you can use immediately.
Part A ‚Äî Lifecycle Hooks ‚è±Ô∏è
If you‚Äôve used other frameworks:
In React you‚Äôd reach for useEffect.
In Vue there are hooks like mounted and beforeUnmount.
In Svelte, lifecycle hooks are minimal but powerful ‚Äî just what you need, no boilerplate.
onMount
Runs after the component first renders in the DOM.
Think of it like Svelte saying:
‚ÄúOkay, your component is finally on the page ‚Äî now‚Äôs your chance to measure things, fetch data, or wire up events.‚Äù
Great for:
Fetching data
Measuring DOM nodes
Adding event listeners
<!-- src/routes/+page.svelte -->
<script>
import { onMount } from 'svelte';
let width;
onMount(() => {
width = window.innerWidth;
const handleResize = () => (width = window.innerWidth);
window.addEventListener('resize', handleResize);
// cleanup when unmounting
return () => window.removeEventListener('resize', handleResize);
});
</script>
<p>Window width: {width}</p>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Without cleanup, you‚Äôd leave behind stray resize listeners every time this component mounted/unmounted ‚Äî a slow memory leak.
$effect.pre (before DOM update)
Runs just before Svelte updates the DOM when reactive state changes.
It‚Äôs like Svelte tapping you on the shoulder:
‚ÄúHeads up, I‚Äôm about to change the DOM ‚Äî want to look at the old value first?‚Äù
<!-- src/routes/+page.svelte -->
<script>
let count = 0;
$effect.pre(() => {
console.log("Before update: count =", count);
});
$effect(() => {
console.log("After update: count =", count);
});
</script>
<button onclick={() => count++}>+1</button>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Use $effect.pre when you wanna sneak a peek at the old value before Svelte changes everything. Think of it like getting a look at the ‚Äòbefore‚Äô picture in a makeover, right before the big transformation!.
‚ùå Don‚Äôt try to edit the DOM here ‚Äî Svelte will overwrite your changes immediately.
$effect (after DOM update)
Runs right after the DOM has been updated.
This is your place to interact with the final DOM: measuring, scrolling, or syncing with third-party libraries.
<!-- src/routes/+page.svelte -->
<script>
let messages = [];
function addMessage() {
messages = [...messages, `Message ${messages.length + 1}`];
}
$effect(() => {
const list = document.querySelector('#messages');
if (list) list.scrollTop = list.scrollHeight;
});
</script>
<ul id="messages" style="height:100px; overflow-y:auto;">
{#each messages as msg}
<li>{msg}</li>
{/each}
</ul>
<button onclick={addMessage}>Add message</button>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Perfect for chat apps: each new message scrolls into view automatically.
Think of $effect as your ‚Äúafter the dust settles‚Äù hook.
onDestroy
Runs when a component is removed from the DOM.
Think of it like cleaning up your campsite before you leave ‚Äî no timers, no listeners left behind.
<!-- src/routes/+page.svelte -->
<script>
import { onDestroy } from 'svelte';
let timer = setInterval(() => console.log('tick'), 1000);
onDestroy(() => {
clearInterval(timer);
});
</script>
<p>Watch the console. When I unmount, timer stops.</p>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Forgetting cleanup here is like leaving your laundry out and never picking it up‚Äîeventually, it piles up and starts to smell! You don‚Äôt want those stray listeners or timers causing your app to slow down or crash.
Mini Recap üìù
Lifecycle hooks give you a clean way to manage setup, updates, and teardown:
onMount ‚Üí run setup logic once the DOM is ready
$effect.pre ‚Üí peek at values before DOM changes
$effect ‚Üí react after DOM changes
onDestroy ‚Üí cleanup when leaving
They‚Äôre simple, predictable, and cover most real-world needs without extra libraries.
Part B ‚Äî Accessibility (a11y) ‚ôø
Accessibility isn‚Äôt a ‚Äúnice to have‚Äù, it‚Äôs a must-have! If your app looks sleek but can‚Äôt be used with a keyboard, a screen reader, or by someone with low vision, then for those users‚Ä¶it‚Äôs broken.
The good news: Svelte already helps by warning about some a11y issues in the compiler. The rest is up to us ‚Äî adding semantics, handling focus, and making sure our colors and interactions are usable by everyone.
ARIA Roles üé≠
ARIA roles are like name tags at a party. Without them, assistive tech sees a <div> and goes, ‚Äúuhh‚Ä¶ what are you?‚Äù
Example: modal dialog.
<!-- src/routes/+page.svelte -->
<div role="dialog" aria-labelledby="title" aria-modal="true">
<h2 id="title">Confirm Delete</h2>
<button>Cancel</button>
<button>Delete</button>
</div>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Now screen readers know: ‚ÄúThis is a dialog with a title.‚Äù Not just a random <div>.
Keyboard Navigation ‚å®Ô∏è
Everything should work without a mouse. Menus, tabs, dialogs ‚Äî they all need keyboard support.
<!-- src/routes/+page.svelte -->
<script>
let items = ['Home', 'About', 'Contact'];
let current = 0;
function handleKey(e) {
if (e.key === 'ArrowDown') current = (current + 1) % items.length;
if (e.key === 'ArrowUp') current = (current - 1 + items.length) % items.length;
}
</script>
<ul tabindex="0" onkeydown={handleKey}>
{#each items as item, i}
<li class:active={i === current}>{item}</li>
{/each}
</ul>
<style>
li.active {
background: #ddd;
}
</style>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Try the arrow keys ‚Äî focus moves up and down the list like you‚Äôd expect.
Focus Management üéØ
When a modal opens, focus should jump into it. Otherwise, keyboard users can get stuck ‚Äúbehind the curtain.‚Äù
<!-- src/routes/+page.svelte -->
<script>
import { onMount } from 'svelte';
let modal;
onMount(() => {
modal.querySelector('button').focus();
});
</script>
<div role="dialog" bind:this={modal}>
<h2>Welcome</h2>
<button>Close</button>
</div>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Now, the focus jumps straight to the button like a spotlight on stage! No more awkwardly tabbing through the background‚Äîyour keyboard users will love you for this.
Labels & Inputs üè∑Ô∏è
Inputs need proper labels ‚Äî otherwise screen readers just announce ‚Äúedit text‚Äù with no context.
<!-- Using "for" / "id" -->
<label for="email">Email</label>
<input id="email" type="email" />
Enter fullscreen mode
Exit fullscreen mode
Or the wrapping style:
<label>
Email
<input type="email" />
</label>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Both are fully screen-reader friendly.
Color Contrast üé®
Designers love light grays, but your eyes (and your users‚Äô) don‚Äôt.
Use the WebAIM contrast checker to make sure text is readable.
‚úÖ Aim for at least 4.5:1 contrast ratio for normal text.
Live Regions üîä
When something changes in your app (like a new message or notification), you want to make sure your users know about it, right? That‚Äôs where aria-live comes in. It‚Äôs like having an invisible helper announcing changes, so no one misses out!
<!-- src/routes/+page.svelte -->
<script>
let message = "Ready.";
</script>
<p aria-live="polite">{message}</p>
<button onclick={() => message = "Saved!"}>Save</button>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ When you click ‚ÄúSave,‚Äù screen readers will literally speak the word ‚ÄúSaved!‚Äù
Real-World Example: Accessible Tabs üóÇÔ∏è
Let‚Äôs build a set of tabs that play nicely with both keyboards and screen readers.
<!-- src/lib/components/Tabs.svelte -->
<script>
export let tabs = [];
export let children;
let active = 0;
</script>
<div role="tablist">
{#each tabs as tab, i}
<button
role="tab"
aria-selected={i === active}
aria-controls={"panel-" + i}
id={"tab-" + i}
onclick={() => (active = i)}
>
{tab.label}
</button>
{/each}
</div>
{#each tabs as tab, i}
<div
id={"panel-" + i}
role="tabpanel"
aria-labelledby={"tab-" + i}
hidden={i !== active}
>
{@render children?.({ name: tab.name })}
</div>
{/each}
Enter fullscreen mode
Exit fullscreen mode
Usage
<!-- src/routes/+page.svelte -->
<script>
import Tabs from '$lib/components/Tabs.svelte';
let tabs = [
{ label: 'One', name: 'one' },
{ label: 'Two', name: 'two' }
];
</script>
<Tabs {tabs}>
{({ name }) => {
if (name === 'one') return <div>Tab one content</div>;
if (name === 'two') return <div>Tab two content</div>;
}}
</Tabs>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Tabs announce which one is active, link each button to its panel, and properly hide inactive panels.
üëâ Accessibility is less about ‚Äúextra features‚Äù and more about ‚Äúbasic usability for everyone.‚Äù With a few small habits ‚Äî roles, labels, focus, contrast ‚Äî your app becomes usable by all your users, not just some.
Accessible Modal (Mini Project) ü™ü‚ôø
Let‚Äôs put everything together and build an accessible modal component.
It should:
Announce itself properly with role="dialog" + aria-modal="true".
Automatically move focus inside when opened.
Trap focus so tabbing doesn‚Äôt ‚Äúescape‚Äù to the background.
Close when you hit Escape.
Think of it like a pop-up window in real life:
The curtain drops (backdrop),
The spotlight shines inside (focus),
And you can‚Äôt wander off until you close it.
Modal Component
<!-- src/lib/components/Modal.svelte -->
<script>
import { onMount } from 'svelte';
export let open = false;
let modal;
function close() {
open = false;
}
function handleKey(e) {
if (e.key === 'Escape') close();
// Basic focus trap
if (e.key === 'Tab' && modal) {
const focusable = modal.querySelectorAll(
'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
);
const first = focusable[0];
const last = focusable[focusable.length - 1];
if (e.shiftKey && document.activeElement === first) {
e.preventDefault();
last.focus();
} else if (!e.shiftKey && document.activeElement === last) {
e.preventDefault();
first.focus();
}
}
}
onMount(() => {
if (open) {
modal.querySelector('button')?.focus();
document.addEventListener('keydown', handleKey);
}
return () => {
document.removeEventListener('keydown', handleKey);
};
});
</script>
{#if open}
<div class="backdrop">
<div
role="dialog"
aria-modal="true"
aria-labelledby="modal-title"
bind:this={modal}
>
<h2 id="modal-title">Confirm Action</h2>
<button onclick={close}>Cancel</button>
<button onclick={close}>Confirm</button>
</div>
</div>
{/if}
<style>
.backdrop {
position: fixed;
inset: 0;
background: rgba(0, 0, 0, 0.5);
display: flex;
justify-content: center;
align-items: center;
}
[role="dialog"] {
background: white;
padding: 2rem;
border-radius: 8px;
min-width: 300px;
}
button {
margin: 0.5rem;
}
</style>
Enter fullscreen mode
Exit fullscreen mode
Using the Modal
<!-- src/routes/+page.svelte -->
<script>
import Modal from '$lib/components/Modal.svelte';
let show = false;
</script>
<button onclick={() => (show = true)}>Open Modal</button>
<Modal bind:open={show} />
Enter fullscreen mode
Exit fullscreen mode
Why this is accessible
‚úÖ Semantic roles: role="dialog" + aria-modal="true" tell assistive tech this is a modal, not just another <div>.
‚úÖ Focus management: When the modal opens, focus jumps straight to the first button. Users don‚Äôt get lost in the background.
‚úÖ Focus trap: Pressing Tab cycles between buttons inside the modal ‚Äî you can‚Äôt tab into the page behind it.
‚úÖ Escape key: Hitting Escape closes the modal, no mouse required.
This little modal combines:
Lifecycle hooks (onMount) for setup and cleanup,
Keyboard handling for Escape/Tab,
Accessibility best practices for roles, focus, and labels.
It‚Äôs a real-world component that feels good to use whether you‚Äôre on a mouse, keyboard, or screen reader.
With these patterns, you‚Äôre officially building like a pro.
üëâ Next in the series: Performance & Scaling ‚Äî optimizing reactivity, code splitting, lazy loading, and testing.
Follow me on DEV for future posts in this deep-dive series.
https://dev.to/a1guy
If it helped, leave a reaction (heart / bookmark) ‚Äî it keeps me motivated to create more content
Checkout my offering on YouTube with (growing) crash courses and content on JavaScript, React, TypeScript, Rust, WebAssembly, AI Prompt Engineering and more: @LearnAwesome
Svelte & SvelteKit Deep Dive (19 Part Series)
1
Svelte & SvelteKit Deep Dive: From Beginner to Pro
2
Why Learn Svelte in 2025? The Value Proposition & Svelte vs React & Vue
...
15 more parts...
3
Getting Started with SvelteKit: Setup, Project Structure & First App
4
Svelte Crash Course on Reactivity: How Your UI Updates Automatically
5
Svelte Components Explained: Props & Composition Made Simple
6
Svelte Events & Bindings Tutorial: Master Parent-Child Communication
7
Svelte Event Forwarding & Advanced Component Patterns
8
Conditionals in Svelte ‚Äî {#if}, {:else}, and Nesting Explained
9
Loops in Svelte ‚Äî {#each}, Keys, and Building a Todo App
10
Styling in Svelte (Scoped CSS, :global, and Class Directives)
11
Svelte Motion & Theming Guide: Transitions, Animations, and Dark Mode Explained
12
Tailwind CSS + Svelte: Utility-First Styling at Scale
13
A Beginner‚Äôs Guide to Svelte Stores (Writable, Readable, and Derived)
14
Mastering Context and Async Data in Svelte (with Examples)
15
SvelteKit Routing Tutorial: Layouts, Nested Routes & Multi-Page Apps
16
Forms in SvelteKit ‚Äî Actions, Validation & Progressive Enhancement
17
Mastering Svelte Custom Stores
18
Mastering DOM Manipulation with Svelte Actions and Children
19
Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
‚Ä¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Ali Aslam
Follow
https://www.linkedin.com/in/maliaslam/
Joined
Aug 9, 2025
More from Ali Aslam
Mastering DOM Manipulation with Svelte Actions and Children
#sveltekit
#webdev
#svelte
#javascript
Mastering Svelte Custom Stores
#svelte
#webdev
#javascript
#programming
Forms in SvelteKit ‚Äî Actions, Validation & Progressive Enhancement
#svelte
#webdev
#javascript
#ui
üíé DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community ‚Äî A space to discuss and keep up software development and manage your software career
Home
DEV++
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community ¬© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account