Mastering DOM Manipulation with Svelte Actions and Children - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
DUMB DEV Community
Follow
Memes and software development shitposting
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE‚Äîthe hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project ‚Äî features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto‚Äîfrom Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Ali Aslam
Posted on Sep 13
Mastering DOM Manipulation with Svelte Actions and Children
#sveltekit
#webdev
#svelte
#javascript
Svelte & SvelteKit Deep Dive (19 Part Series)
1
Svelte & SvelteKit Deep Dive: From Beginner to Pro
2
Why Learn Svelte in 2025? The Value Proposition & Svelte vs React & Vue
...
15 more parts...
3
Getting Started with SvelteKit: Setup, Project Structure & First App
4
Svelte Crash Course on Reactivity: How Your UI Updates Automatically
5
Svelte Components Explained: Props & Composition Made Simple
6
Svelte Events & Bindings Tutorial: Master Parent-Child Communication
7
Svelte Event Forwarding & Advanced Component Patterns
8
Conditionals in Svelte ‚Äî {#if}, {:else}, and Nesting Explained
9
Loops in Svelte ‚Äî {#each}, Keys, and Building a Todo App
10
Styling in Svelte (Scoped CSS, :global, and Class Directives)
11
Svelte Motion & Theming Guide: Transitions, Animations, and Dark Mode Explained
12
Tailwind CSS + Svelte: Utility-First Styling at Scale
13
A Beginner‚Äôs Guide to Svelte Stores (Writable, Readable, and Derived)
14
Mastering Context and Async Data in Svelte (with Examples)
15
SvelteKit Routing Tutorial: Layouts, Nested Routes & Multi-Page Apps
16
Forms in SvelteKit ‚Äî Actions, Validation & Progressive Enhancement
17
Mastering Svelte Custom Stores
18
Mastering DOM Manipulation with Svelte Actions and Children
19
Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps
In Svelte, Actions and Children are powerful tools that make your components more dynamic and reusable. Whether you're adding behaviors like focus management, handling resizing, or giving parents the ability to inject custom content, these features are essential for building interactive and flexible UIs.
This guide will show you how to leverage Actions to add reusable DOM behaviors and Children to make your components more adaptable. By the end, you'll be able to create components that feel like LEGO blocks‚Äîsmall, composable, and easy to work with.
Why Actions? üé¨
We‚Äôve seen how stores help with state management.
But what about reusing behavior on DOM elements?
While state management (via stores) helps us manage data, actions focus on controlling the behavior of DOM elements. They let us add reusable behaviors, like autofocus, clicks, resizing, and much more, making our components more flexible and powerful.
Stores vs Actions
Stores ‚Üí centralize and share state
Actions ‚Üí centralize and reuse DOM behavior
The problem
Imagine you want multiple inputs to autofocus when they appear.
Without actions, you‚Äôd write the same onMount logic in every component:
<script>
import { onMount } from 'svelte';
let input;
onMount(() => input.focus());
</script>
<input bind:this={input}>
Enter fullscreen mode
Exit fullscreen mode
It works, but it‚Äôs copy-pasted boilerplate. üò©
The idea
With an action, you write the focus logic once and then attach it to any element using the use: directive.
Think of actions as hooks for DOM nodes ‚Äî little reusable plugins you can stick on elements.
Your First Action: Autofocus üëÄ
Let‚Äôs turn that autofocus behavior into an action.
Action file
// src/lib/actions/focus.js
export function autofocus(node) {
node.focus();
}
Enter fullscreen mode
Exit fullscreen mode
Usage in a page
<!-- src/routes/+page.svelte -->
<script>
import { autofocus } from '$lib/actions/focus.js';
</script>
<input placeholder="Type here..." use:autofocus />
Enter fullscreen mode
Exit fullscreen mode
How it works
When the <input> mounts, Svelte calls our autofocus function with the DOM node.
The action immediately runs node.focus().
Result: the input gets focus automatically, no onMount needed in your component.
‚úÖ You can now sprinkle use:autofocus anywhere without repeating logic. The use: directive is the key to applying actions to DOM elements. It tells Svelte to run the action on the DOM element when it mounts, providing a simple and reusable way to handle behaviors.
Actions with Cleanup üßπ
Some DOM behaviors need to attach event listeners (like click, keydown, or scroll).
But here‚Äôs the catch: if you don‚Äôt remove those listeners when the element goes away, you‚Äôll create memory leaks.
Actions solve this neatly because they can return an object with special lifecycle methods:
destroy() ‚Üí runs when the element is removed from the DOM
update(params) ‚Üí runs if the parameter to the action changes (we‚Äôll cover this in the next step)
Example: Click Outside Detector
Let‚Äôs make an action that closes a modal or dropdown when you click outside of it.
// src/lib/actions/clickOutside.js
export function clickOutside(node, callback) {
function handle(event) {
if (!node.contains(event.target)) {
callback();
}
}
document.addEventListener('click', handle, true);
return {
destroy() {
document.removeEventListener('click', handle, true);
}
};
}
Enter fullscreen mode
Exit fullscreen mode
Usage in a component
<!-- src/routes/+page.svelte -->
<script>
import { clickOutside } from '$lib/actions/clickOutside.js';
let open = true;
</script>
{#if open}
<div use:clickOutside={() => (open = false)}>
Click outside me to close.
</div>
{/if}
Enter fullscreen mode
Exit fullscreen mode
Why this works
When the <div> mounts, the action attaches a click listener on document.
If you click anywhere outside the <div>, the callback runs and sets open = false.
When the <div> is removed, the destroy() method is called, which cleans up the event listener. This cleanup is essential because, without it, event listeners would continue to exist even after the element is removed from the DOM, leading to unnecessary memory consumption and potential performance issues
‚úÖ This is perfect for modals, dropdowns, sidebars, or tooltips that should close when you click elsewhere.
‚ö†Ô∏è Without the destroy() cleanup, every new modal would add another document.addEventListener ‚Äî piling up over time, slowing down your app, and causing weird bugs.
Actions with Parameters üéõÔ∏è
Actions don‚Äôt just run once ‚Äî they can also react to changing arguments.
When you write use:myAction={value}, Svelte does three things under the hood:
Calls the action when the element mounts ‚Üí myAction(node, value)
Calls update(newValue) whenever the parameter changes
Calls destroy() when the element is removed
This makes actions really flexible ‚Äî they can adapt as your component‚Äôs state changes. By passing parameters to actions, we can make them highly dynamic and reusable. For example, resizing a box based on a slider or updating styles based on a value changes without needing to repeat logic in each component.
Example: Resize Box
Here‚Äôs an action that resizes a box based on a numeric parameter.
// src/lib/actions/resize.js
export function resize(node, size) {
function apply(size) {
node.style.width = size + 'px';
node.style.height = size + 'px';
}
// run once on mount
apply(size);
return {
update(newSize) {
apply(newSize); // run whenever `size` changes
},
destroy() {
// cleanup: reset styles
node.style.width = '';
node.style.height = '';
}
};
}
Enter fullscreen mode
Exit fullscreen mode
Usage in a page
<!-- src/routes/+page.svelte -->
<script>
import { resize } from '$lib/actions/resize.js';
let boxSize = 100;
</script>
<div use:resize={boxSize} style="background: coral;"></div>
<input type="range" min="50" max="300" bind:value={boxSize} />
Enter fullscreen mode
Exit fullscreen mode
How it works
On mount, the action sets the <div>‚Äôs width and height to boxSize (100px to start).
As you move the slider, boxSize changes ‚Üí Svelte calls the action‚Äôs update() ‚Üí the box resizes in real time.
When the <div> is removed, destroy() resets its styles.
‚úÖ The result: a resizable box that updates instantly as the slider moves.
Advanced Actions (Extra Examples) üöÄ
By now you‚Äôve seen how actions can add reusable behavior to DOM elements.
Let‚Äôs bring back some extra goodies from the old draft ‚Äî actions that are a bit more advanced but super useful in real apps.
1. Debounced Input ‚è≥
Throttle keystrokes before firing off expensive work (like API requests).
// src/lib/actions/debounce.js
export function debounce(node, delay = 300) {
let timeout;
function handler(e) {
clearTimeout(timeout);
timeout = setTimeout(() => {
node.dispatchEvent(
new CustomEvent('debounced', { detail: e.target.value })
);
}, delay);
}
node.addEventListener('input', handler);
return {
destroy() {
node.removeEventListener('input', handler);
}
};
}
Enter fullscreen mode
Exit fullscreen mode
Usage
<!-- src/routes/+page.svelte -->
<script>
import { debounce } from '$lib/actions/debounce.js';
let search = '';
</script>
<input
use:debounce={500}
on:debounced={(e) => (search = e.detail)}
placeholder="Search..."
/>
<p>Search query: {search}</p>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Super handy for search boxes ‚Äî you don‚Äôt want to hammer your backend on every single keystroke. Debouncing helps optimize user experience by reducing unnecessary API calls, especially when dealing with search inputs, live validation, or any component that reacts to user typing.
2. Drag and Drop (Basic) üñ±Ô∏è
Make elements draggable with almost no code.
// src/lib/actions/draggable.js
export function draggable(node) {
node.draggable = true;
function handleDragStart(e) {
e.dataTransfer.setData('text/plain', node.id);
node.classList.add('dragging');
}
function handleDragEnd() {
node.classList.remove('dragging');
}
node.addEventListener('dragstart', handleDragStart);
node.addEventListener('dragend', handleDragEnd);
return {
destroy() {
node.removeEventListener('dragstart', handleDragStart);
node.removeEventListener('dragend', handleDragEnd);
}
};
}
Enter fullscreen mode
Exit fullscreen mode
Usage
<!-- src/routes/+page.svelte -->
<script>
import { draggable } from '$lib/actions/draggable.js';
</script>
<div id="card1" use:draggable class="card">Drag me!</div>
<style>
.card {
padding: 1rem;
background: coral;
width: 120px;
border-radius: 8px;
cursor: grab;
}
.dragging {
opacity: 0.5;
}
</style>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Perfect for building kanban boards, sortable lists, or any drag-n-drop UI.
Mini Recap üìù
So far you‚Äôve learned:
Actions attach reusable DOM behavior with the use: directive.
They can:
clean up (destroy)
react to parameter changes (update)
even dispatch custom events back to your components.
Together we built:
autofocus (simple mount logic)
clickOutside (cleanup on destroy)
resize (parameters & updates)
debounce (custom events)
draggable (real DOM APIs)
Extra Notes for Beginners
üîπ Debounce:
When we call node.dispatchEvent(new CustomEvent(...)), we‚Äôre basically saying:
‚ÄúPretend this is a normal DOM event.‚Äù
That‚Äôs why in your component you can listen with onDebounced just like onClick.
üîπ Draggable:
node.draggable = true; is just enabling the browser‚Äôs built-in drag support.
We‚Äôre not moving elements around yet ‚Äî just marking them as draggable and styling them while they‚Äôre being dragged. That‚Äôs why this version is ‚Äúbasic.‚Äù You could extend it later with drop zones or reordering logic.
‚ú® And that‚Äôs actions! Small functions that give your elements reusable superpowers.
Next: let‚Äôs explore children, Svelte‚Äôs secret weapon for flexible component composition.
Why Children? üë∂
Props let parents send data to children.
Children let parents send content to children.
They‚Äôre the backbone of reusable UI libraries ‚Äî think buttons, cards, layouts, modals. While actions manipulate the behavior of DOM elements (like adding click event listeners or resizing an element), children allow parents to inject content into components. Together, actions and children make your components more dynamic and reusable
üëâ Children are like cutouts in your component where parents can inject their own content.
Default Children üì¶
Sometimes you don‚Äôt just want your component to look nice ‚Äî you want it to be a container for other stuff. That‚Äôs what the children prop is for.
It‚Äôs like saying:
‚ÄúHey parent, you tell me what goes inside, and I‚Äôll handle the wrapper.‚Äù
Example: Card Component
<!-- src/lib/components/Card.svelte -->
<script>
export let children;
</script>
<div class="card">
{@render children?.()}
</div>
<style>
.card {
border: 1px solid #ddd;
border-radius: 6px;
padding: 1rem;
}
</style>
Enter fullscreen mode
Exit fullscreen mode
Using the Card
<!-- src/routes/+page.svelte -->
<script>
import Card from '$lib/components/Card.svelte';
</script>
<Card>
<h2>Hello</h2>
<p>This is inside the card!</p>
</Card>
Enter fullscreen mode
Exit fullscreen mode
‚ú® Boom! Whatever you write between <Card> ... </Card> gets passed into the children prop and rendered inside.
Think of it like a bento box üç±: the Card provides the container, you provide the delicious filling.
Named Children üßÅ
What if your component has multiple areas ‚Äî like header, body, and footer ‚Äî instead of just one?
You can accept named children, which are just props that are functions returning content.
Example: Layout Component
<!-- src/lib/components/Layout.svelte -->
<script>
export let header;
export let footer;
export let children; // default area
</script>
<header>{@render header?.()}</header>
<main>{@render children?.()}</main>
<footer>{@render footer?.()}</footer>
Enter fullscreen mode
Exit fullscreen mode
Using the Layout
<!-- src/routes/+page.svelte -->
<script>
import Layout from '$lib/components/Layout.svelte';
</script>
<Layout
header={() => <h1>My Site</h1>}
footer={() => <small>¬© 2025</small>}
>
<p>Main content goes here.</p>
</Layout>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ Each piece gets dropped exactly where you want it.
Think of it like a muffin tray üßÅ: each ‚Äúcup‚Äù has its own filling.
Fallback Children üìù
Sometimes parents don‚Äôt pass anything in. Should your component be an empty shell? Nope! You can provide default content instead.
Example: Button Component
<!-- src/lib/components/Button.svelte -->
<script>
export let children = () => "Click me";
</script>
<button>{@render children()}</button>
Enter fullscreen mode
Exit fullscreen mode
Using the Button
<!-- src/routes/+page.svelte -->
<script>
import Button from '$lib/components/Button.svelte';
</script>
<Button />
<!-- shows "Click me" -->
<Button>Save</Button> <!-- shows "Save" -->
Enter fullscreen mode
Exit fullscreen mode
‚úÖ If the parent passes children, those take priority. Otherwise, the component politely falls back to its default.
It‚Äôs like leaving a friendly sticky note:
‚ÄúForgot to pass me something? No worries, I got you üëç‚Äù
Children as Render Functions (Child ‚Üí Parent) üîÑ
Here‚Äôs the really cool part: children don‚Äôt have to just be static content ‚Äî they can be functions that receive data from the child component.
That means:
The child decides when to render something (like looping through a list).
The parent decides how it should look.
Example: List Component
<!-- src/lib/components/List.svelte -->
<script>
export let items = [];
export let children;
</script>
<ul>
{#each items as item}
<li>{@render children({ item })}</li>
{/each}
</ul>
Enter fullscreen mode
Exit fullscreen mode
Using the List
<!-- src/routes/+page.svelte -->
<script>
import List from '$lib/components/List.svelte';
</script>
<List items={['Ada', 'Grace', 'Linus']}>
{({ item }) => <span>{item.toUpperCase()}</span>}
</List>
Enter fullscreen mode
Exit fullscreen mode
‚úÖ The List component controls when to render each <li>.
‚úÖ The parent controls what each item looks like ‚Äî in this case, uppercased names.
It‚Äôs like the child saying: ‚ÄúHere‚Äôs the data,‚Äù and the parent replying: ‚ÄúCool, I‚Äôll dress it up.‚Äù üé®
Gotchas & Best Practices ‚ö†Ô∏è
Always provide fallback children so your component doesn‚Äôt break if nothing is passed in.
When looping with {#each}, always use keys (e.g. {#each items as item (item.id)}) to avoid weird DOM recycling bugs.
Children-as-functions are powerful, but keep it simple ‚Äî only pass the data the parent actually needs.
We covered a lot of ground here:
Actions: from a one-liner autofocus to advanced behaviors with cleanup, parameters, and custom events.
Children: from default content, to named sections, to render functions that let parents customize rendering logic.
These patterns make your components smarter and more reusable.
üëâ Next, we‚Äôll tie things together with Svelte Lifecycle Hooks and Accessibility ‚Äî ensuring your components behave correctly over time and are usable by everyone.
Follow me on DEV for future posts in this deep-dive series.
https://dev.to/a1guy
If it helped, leave a reaction (heart / bookmark) ‚Äî it keeps me motivated to create more content
Checkout my offering on YouTube with (growing) crash courses and content on JavaScript, React, TypeScript, Rust, WebAssembly, AI Prompt Engineering and more: @LearnAwesome
Svelte & SvelteKit Deep Dive (19 Part Series)
1
Svelte & SvelteKit Deep Dive: From Beginner to Pro
2
Why Learn Svelte in 2025? The Value Proposition & Svelte vs React & Vue
...
15 more parts...
3
Getting Started with SvelteKit: Setup, Project Structure & First App
4
Svelte Crash Course on Reactivity: How Your UI Updates Automatically
5
Svelte Components Explained: Props & Composition Made Simple
6
Svelte Events & Bindings Tutorial: Master Parent-Child Communication
7
Svelte Event Forwarding & Advanced Component Patterns
8
Conditionals in Svelte ‚Äî {#if}, {:else}, and Nesting Explained
9
Loops in Svelte ‚Äî {#each}, Keys, and Building a Todo App
10
Styling in Svelte (Scoped CSS, :global, and Class Directives)
11
Svelte Motion & Theming Guide: Transitions, Animations, and Dark Mode Explained
12
Tailwind CSS + Svelte: Utility-First Styling at Scale
13
A Beginner‚Äôs Guide to Svelte Stores (Writable, Readable, and Derived)
14
Mastering Context and Async Data in Svelte (with Examples)
15
SvelteKit Routing Tutorial: Layouts, Nested Routes & Multi-Page Apps
16
Forms in SvelteKit ‚Äî Actions, Validation & Progressive Enhancement
17
Mastering Svelte Custom Stores
18
Mastering DOM Manipulation with Svelte Actions and Children
19
Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
‚Ä¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Ali Aslam
Follow
https://www.linkedin.com/in/maliaslam/
Joined
Aug 9, 2025
More from Ali Aslam
Mastering Svelte Lifecycle Hooks & Accessibility: Essential Tips for Building Dynamic, Accessible Apps
#svelte
#webdev
#javascript
#programming
Mastering Svelte Custom Stores
#svelte
#webdev
#javascript
#programming
Forms in SvelteKit ‚Äî Actions, Validation & Progressive Enhancement
#svelte
#webdev
#javascript
#ui
üíé DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community ‚Äî A space to discuss and keep up software development and manage your software career
Home
Welcome Thread
Reading List
Tags
About
Contact
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem ‚Äî the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community ¬© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account