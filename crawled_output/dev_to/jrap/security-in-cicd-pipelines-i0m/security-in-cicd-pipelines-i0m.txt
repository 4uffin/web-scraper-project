Security in CI/CD Pipelines - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Cyberoptic Security Ltd
Posted on Sep 15
Security in CI/CD Pipelines
#cicd
#security
#cybersecurity
#devops
This guide covers the essential security checks every small team should use. Most of these tools are free or cheap, and they run automatically in the background without disrupting your workflow.
Building security into your CI/CD pipeline means catching obvious problems before they reach production, reducing the risk of costly incidents and emergency patches. There are a variety of security checks that should be done before deploying code, and implementing these checks in an automated pipeline is an ideal way to streamline your security testing process.
beep boop
Static Code Scanning (SAST)
Static code scanning analyses source code for security vulnerabilities without executing it. SAST tools identify common security flaws like SQL injection, cross-site scripting (XSS), buffer overflows, and hardcoded secrets.
Finding security bugs during development is much less of a headache than finding them in production. SAST provides immediate feedback during code review, helping developers learn secure coding patterns while preventing vulnerabilities from entering the codebase.
Tool options:
SonarQube Community Edition: Java, C#, JavaScript, TypeScript, Python, PHP, Go, Kotlin, Ruby, Scala, XML
Semgrep: Python, Java, JavaScript, TypeScript, Go, Ruby, C, C++, PHP, C#, Kotlin, Scala
CodeQL: JavaScript, TypeScript, Python, Java, C#, C, C++, Go, Ruby
Bandit: Python (specialised for Python security issues)
ESLint with security plugins: JavaScript, TypeScript
SpotBugs with Find Security Bugs: Java, Scala, Groovy
Clang Static Analyzer: C, C++, Objective-C
Cppcheck: C, C++
Brakeman: Ruby on Rails
gosec: Go
Implementation approach: Run SAST scans on every pull request. Start with high-severity rules only to avoid alert fatigue. Most tools integrate directly with major CI platforms through plugins or simple command-line execution.
Modern SAST tools can scan typical codebases in under 5 minutes. Configure incremental scanning to analyse only changed code for faster feedback loops.
Dynamic Application Security Testing (DAST)
DAST tools test running applications by simulating attacks against live deployments. Unlike static analysis, DAST discovers runtime vulnerabilities, configuration issues, and logic flaws that only manifest when the application is actually running.
Benefits for development teams: DAST catches authentication bypasses, server misconfigurations, missing security headers, and business logic vulnerabilities that static analysis misses. It validates that security controls work correctly in your actual deployment environment, not just in theory.
Tool landscape:
Open source: OWASP ZAP (comprehensive but slower), Nuclei (fast template-based scanning)
Commercial: Burp Suite Professional, Rapid7 AppSpider
Cloud-based: Detectify, HackerOne's pentest platform
Platform-integrated: AWS Inspector, Azure Security Center
Implementation approach: Run DAST against staging environments after deployment. Since scans take 15-60 minutes depending on application size, consider running them nightly rather than on every commit. Focus initial efforts on authentication endpoints, user input forms, and API endpoints.
Modern applications often have extensive APIs that need dedicated testing. Tools like Postman's security scanning or REST-specific DAST tools can provide better coverage than traditional web application scanners.
Software Composition Analysis (SCA) and Dependency Scanning
SCA tools analyse third-party dependencies and open-source components for known vulnerabilities, license compliance issues, and outdated packages. Modern applications typically use hundreds of dependencies, making manual tracking impossible.
Dependency vulnerabilities represent 85% of security holes in modern applications. SCA prevents the integration of components with known CVEs and helps maintain compliance with open-source licensing requirements.
Tool ecosystem:
Language-specific: npm audit (Node.js), pip-audit (Python), bundler-audit (Ruby)
Universal: Snyk (freemium), OWASP Dependency-Check (free), Trivy (free)
Platform-integrated: GitHub Dependabot, GitLab dependency scanning, Azure DevOps
Enterprise: Sonatype Nexus, JFrog Xray, WhiteSource (now Mend)
Implementation approach: Run SCA scans after dependency resolution but before deployment. Configure tools to fail builds on critical vulnerabilities while allowing lower-severity issues with appropriate business justification. Combine with automated dependency update tools like Dependabot or Renovate for streamlined patching workflows.
Modern SCA tools provide vulnerability prioritisation based on actual usage (reachability analysis), automated remediation suggestions, and integration with development workflows through pull request comments.
Secrets Detection and Management
Secrets scanning tools detect accidentally committed credentials, API keys, certificates, and other sensitive data in source code, configuration files, and build artifacts. These tools use pattern matching, entropy analysis, and machine learning to identify potential secrets.
Hardcoded secrets in repositories create permanent security liabilities. Even private repositories can be compromised, and secrets in git history are difficult to fully remove. Automated detection prevents these credentials from entering version control.
Detection tools and platforms:
Open source: GitLeaks, TruffleHog, detect-secrets
Platform-integrated: GitHub secret scanning, GitLab secret detection, Azure DevOps credential scanner
Enterprise: GitGuardian, Cycode, SpectralOps
Pre-commit hooks: git-secrets, pre-commit framework with secrets plugins
Implementation approach: Deploy secrets detection at multiple points: pre-commit hooks for immediate developer feedback, CI pipeline scans for every code change, and periodic repository history scans for comprehensive coverage. Configure different sensitivity levels for different secret types.
Modern secrets management platforms can automatically rotate compromised credentials when detected. Tools like HashiCorp Vault, AWS Secrets Manager, and Azure Key Vault provide APIs for programmatic secret rotation and can integrate with CI/CD pipelines.
Container Image Security Scanning
Container scanning analyses Docker images and other container formats for OS-level vulnerabilities, malicious packages, configuration issues, and compliance violations. This includes both base image components and application-specific additions.
Container images often contain hundreds of system packages, any of which may have known CVEs. Scanning identifies vulnerable packages, misconfigurations like running as root, exposed sensitive files, and compliance violations against security benchmarks like CIS Docker Benchmark.
Scanning tools and integration:
Open source: Trivy (comprehensive and fast), Grype, Clair
Cloud provider: AWS ECR image scanning, Azure Container Registry scanning, Google Container Analysis
Commercial: Snyk Container, Aqua Security, Twistlock (now Prisma Cloud)
Registry-integrated: Docker Hub vulnerability scanning, Red Hat Quay
Implementation approach: Implement multi-stage scanning: scan base images during selection, scan intermediate build images, and scan final runtime images before registry push. Consider both OS-level and application-level vulnerability detection.
Modern container scanners provide specific remediation guidance, including base image upgrade recommendations, package updates, and configuration fixes. Integration with image build pipelines enables automatic rebuilds when new vulnerabilities are discovered in base images.
Infrastructure as Code (IaC) Security Scanning
IaC security tools analyse infrastructure configuration files (Terraform, CloudFormation, Kubernetes manifests) for security misconfigurations, compliance violations, and policy breaches before deployment.
Configuration risk management: Infrastructure misconfigurations cause 65% of cloud security incidents. IaC scanning prevents deployment of overly permissive security groups, unencrypted storage, public cloud resources, and non-compliant configurations.
Tool landscape by platform:
Terraform: tfsec, Checkov, Terrascan, Snyk Infrastructure as Code
CloudFormation: cfn-nag, Stelligent cfn_nag, Checkov
Kubernetes: kube-score, Polaris, Falco, OPA Gatekeeper
Multi-platform: Checkov, Prisma Cloud, Bridgecrew (now Prisma)
Integration approach: Run IaC scans on infrastructure pull requests before merge, during CI/CD pipeline execution before deployment, and periodically against live infrastructure for drift detection. Configure different rule sets for development, staging, and production environments based on risk tolerance.
Many IaC scanners support industry frameworks like CIS Benchmarks, NIST, SOC 2, and GDPR compliance requirements. Custom policy creation enables organisation-specific security requirements and governance rules.
CI/CD Pipeline Security Platforms
Different CI/CD platforms offer varying levels of built-in security capabilities and third-party integrations. Understanding platform-specific features helps optimise your security implementation approach.
GitHub Actions and GitHub Advanced Security
Built-in Security Features:
CodeQL for semantic code analysis (free for public repos, paid for private)
Secret scanning with automatic token revocation for popular services
Dependency vulnerability alerts with Dependabot integration
Security advisories and vulnerability database
Third-party Integrations:
Extensive action marketplace includes security tools like Snyk, Semgrep, OWASP ZAP, and container scanners
Actions can be configured with specific security policies and failure conditions
Enterprise and Compliance Features:
GitHub Advanced Security provides code scanning, secret scanning, and dependency review for private repositories
Detailed security dashboards and compliance reporting
Platform-specific Considerations:
Free security features for public repositories make it attractive for open source projects
Tight integration with GitHub's development workflow and pull request process
GitLab CI/CD
Built-in Security Features:
Integrated SAST, DAST, dependency scanning, container scanning, and license compliance
Results integrate directly into merge request workflows
Built-in container registry with automated vulnerability scanning
Third-party Integrations:
Comprehensive security scanner integrations available through GitLab's CI/CD configuration
API-based integrations with external security tools and platforms
Enterprise and Compliance Features:
Centralised security dashboard with vulnerability management across projects
Security metrics and compliance tracking with policy management
Organisation-wide security requirements enforcement
Platform-specific Considerations:
All-in-one DevOps platform reduces tool sprawl
Policy enforcement for image promotion between environments
Strong focus on DevSecOps workflow integration
Azure DevOps
Built-in Security Features:
Native integration with Microsoft Defender for DevOps
Security findings across the development lifecycle with threat intelligence prioritisation
Built-in compliance tracking and audit logging
Third-party Integrations:
Azure DevOps marketplace includes security extensions for various scanning tools
Pipeline templates for common security workflows
Integration with Azure ecosystem security services
Enterprise and Compliance Features:
Policy enforcement with integration to Azure Policy for infrastructure governance
Comprehensive audit logging and compliance tracking capabilities
Enterprise-grade access control and security management
Platform-specific Considerations:
Strong integration with Microsoft ecosystem and Azure cloud services
Enterprise-focused with robust governance and compliance features
Seamless integration with existing Microsoft toolchains
Jenkins
Built-in Security Features:
Basic pipeline security through Jenkinsfile configuration
Built-in user authentication and authorisation mechanisms
Pipeline approval workflows for sensitive operations
Third-party Integrations:
Extensive plugin library includes OWASP Dependency-Check, SonarQube Scanner, and container scanning tools
Wide variety of security scanner integrations available through plugins
Integration platforms and reporting tools through plugin ecosystem
Enterprise and Compliance Features:
Pipeline-as-code security enforcement through pipeline libraries
Shared security scripts and templates for consistency
Audit logging capabilities through plugins
Platform-specific Considerations:
Self-hosted platform requires additional attention to server hardening
Plugin security updates and management responsibility
Greater flexibility but increased security management overhead compared to cloud-hosted platforms
Cloud-Native CI/CD (AWS CodePipeline, Google Cloud Build)
Built-in Security Features:
Serverless security scanning options that scale automatically
Integration with cloud-native secrets management services
Automated security scanning without infrastructure management overhead
Third-party Integrations:
Seamless integration with cloud security services like AWS Inspector and Google Binary Authorization
API-based integrations with cloud marketplace security tools
Native integration with cloud provider security ecosystems
Enterprise and Compliance Features:
Integration with cloud compliance frameworks and governance tools
Comprehensive audit logging for regulatory requirements
Cloud-native policy enforcement and security governance
Platform-specific Considerations:
Serverless architecture reduces infrastructure security management overhead
Deep integration with cloud provider security and compliance services
Scaling and cost considerations tied to cloud provider pricing models
Platform lock-in considerations for multi-cloud strategies
Pipeline Access Control and Supply Chain Security
CI/CD pipelines require privileged access to source code, build environments, and production systems, making them high-value targets for attackers. Pipeline security focuses on protecting the build and deployment process itself.
Access control implementation:
Service accounts with least-privilege permissions for automated processes
Multi-factor authentication requirements for all human pipeline access
Role-based access control for pipeline configuration changes
Short-lived, rotatable tokens instead of static credentials
Network segmentation between build and production environments
Supply chain attack prevention: Modern software supply chain attacks target the build process to inject malicious code. Protection strategies include:
Dependency pinning with hash verification
Private registries for internal dependencies and build tools
Build environment isolation and reproducible builds
Software Bill of Materials (SBOM) generation for transparency
Signature verification for downloaded tools and dependencies
Pipeline monitoring requirements:
Audit logging for all pipeline configuration changes
Alerting on failed security scans or unusual build patterns
Monitoring for unauthorised access to build environments
Tracking deployment success rates and rollback frequency
Integration with security incident response procedures
Implementation Strategy
Implement security scanning incrementally to avoid overwhelming development workflows. Start with the highest-impact, lowest-effort security checks and expand coverage based on your team's capacity and risk profile.
Foundation security measures: Secrets scanning and dependency vulnerability detection provide immediate security value with minimal configuration overhead. Most CI/CD platforms include these capabilities natively or through simple marketplace integrations.
Static analysis integration: SAST tools for your primary programming languages offer significant vulnerability reduction with moderate setup effort. Configure rule sets conservatively initially to minimise false positives and developer friction.
Container and infrastructure scanning: If your team uses containerisation or infrastructure-as-code, these scans prevent configuration-based security issues. Implementation complexity varies by platform but typically requires only pipeline configuration changes.
Dynamic testing and advanced monitoring: DAST scanning and comprehensive security monitoring require more setup effort but provide coverage for runtime vulnerabilities and production security events that other tools miss.
Gradual expansion approach: Add one security check type at a time, allowing your team to adapt to new tools and processes. Focus on tool tuning and workflow integration before introducing additional scanning capabilities. This approach ensures security measures enhance rather than impede development productivity.
Balancing Automation with Manual Security Review
Automated scanning handles consistent, repeatable security checks, while manual review addresses complex business logic, architectural decisions, and contextual security considerations that tools cannot evaluate.
Code review security integration: Incorporate security considerations into existing code review processes. Review authentication mechanisms, input validation, error handling, and privilege escalation paths during normal peer review workflows.
Periodic security assessments: Schedule quarterly security reviews or external penetration testing to identify blind spots in automated coverage. These assessments validate that security controls work effectively in practice, not just in theory.
Security incident response: Establish clear procedures for handling security findings from both automated tools and manual review. Define severity levels, response timelines, and escalation paths for different types of security issues.
Continuous security improvement: Use security findings as learning opportunities. Conduct post-incident reviews to identify process improvements, tool configuration changes, or additional security measures needed to prevent similar issues.
Staying Current with Security Threats
Security threats evolve constantly. Maintain awareness without getting overwhelmed by focusing on actionable intelligence relevant to your technology stack and threat model.
Information sources:
Platform-specific security advisories (GitHub Security Lab, GitLab Security)
Language and framework security announcements
Cloud provider security bulletins
OWASP project updates and vulnerability databases
Tool maintenance: Keep security scanning tools updated with latest vulnerability signatures and detection rules. Many tools provide automatic updates or notifications when new security rules become available.
Learning from incidents: When security issues are discovered, conduct brief post-mortems to identify process improvements, tool configuration changes, or additional security measures needed to prevent recurrence.
Industry best practices: Follow security researchers and practitioners in your technology areas. Security conferences, blogs, and communities provide insights into emerging threats and defensive techniques.
Conclusion
Integrating security into CI/CD pipelines provides teams with security capabilities without requiring dedicated security staff. Automated security scanning catches common vulnerabilities early in the development cycle, reducing remediation costs and deployment risks.
Implementation principles:
Start with platform-native security features before adding external tools
Prioritise high-impact security checks with low false positive rates
Implement scanning incrementally to avoid disrupting development workflows
Configure tools for fast feedback and minimal developer friction
Balance automation with manual security review for comprehensive coverage
Measurable security improvements: Teams implementing comprehensive pipeline security typically see large reduction in security vulnerabilities reaching production, faster incident response times, and improved compliance with security frameworks. The initial investment in tool setup and configuration pays dividends through reduced security incidents and emergency patches.
Long-term benefits: Beyond immediate vulnerability detection, pipeline security creates a culture of security awareness within development teams. Developers learn secure coding practices through tool feedback, understand common vulnerability patterns, and build security considerations into architectural decisions.
Modern CI/CD platforms make security integration straightforward with built-in scanning capabilities, extensive tool marketplaces, and detailed documentation. Small teams can achieve robust security posture by leveraging these platforms effectively and implementing security checks systematically.
https://www.cyberoptic.co.nz/
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Cyberoptic Security Ltd
Follow
I am a cyber security professional with a focus on pentesting. I like to share knowledge and support the infosec and development community as best I can.
Location
New Zealand
Joined
Aug 28, 2025
More from Cyberoptic Security Ltd
Pen Testing Your Mobile Application (and Its API)
#cybersecurity
#security
#mobile
#api
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Página Inicial
DEV++
Welcome Thread
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
Sobre
Contato
Free Postgres Database
Software comparisons
Forem Shop
Código de Conduta
Política de Privacidade
Termos de Uso
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account