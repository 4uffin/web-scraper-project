Building an Interactive Counter with Kotlin & Jetpack Compose: Animations, State Management & UX Excellence - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SREâ€”the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project â€” features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Cryptoâ€”from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
A0mineTV
Posted on Sep 13
Building an Interactive Counter with Kotlin & Jetpack Compose: Animations, State Management & UX Excellence
#android
#programming
#kotlin
#tutorial
When building interactive UI components with Kotlin and Jetpack Compose, the simple counter is often overlooked. But how do you create a counter that's not just functional, but delightful? One that demonstrates advanced Kotlin features like higher-order functions, smart state management, smooth animations, and elegant error handling ?
In this comprehensive guide, I'll walk you through a production-ready Counter component that showcases Kotlin's expressiveness combined with Compose's animation capabilities. We'll explore patterns like undo functionality with Snackbars, progress tracking, smooth animations, and component composition that makes your UI both beautiful and maintainable.
By the end of this article, you'll understand how to build engaging, interactive components that leverage Kotlin's language features for superior user experiences.
ğŸ—ï¸ Architecture: Kotlin's Function Composition Excellence
Our Counter demonstrates component composition and separation of concerns using Kotlin's powerful function capabilities:
@Composable
fun CounterSection(target: Int = 10, step: Int = 1) {
var count by rememberSaveable { mutableIntStateOf(0) }
val scope = rememberCoroutineScope()
val snackbarHost = remember { SnackbarHostState() }
Scaffold(snackbarHost = { SnackbarHost(snackbarHost) }) { padding ->
CounterContent(
count = count,
target = target,
onIncrement = { count += step },
onDecrement = { if (count > 0) count -= step },
onReset = { /* undo logic */ },
modifier = Modifier.padding(padding)
)
}
}
Enter fullscreen mode
Exit fullscreen mode
Why This Kotlin-First Architecture Excels:
ğŸ¯ Higher-Order Functions as Props:
onIncrement = { count += step },
onDecrement = { if (count > 0) count -= step }
Enter fullscreen mode
Exit fullscreen mode
Lambda Expressions: Clean, readable event handling
Closure Capture: Access to local state without complex passing
Type Safety: Compiler ensures correct function signatures
ğŸ”’ Immutable Parameters with Defaults:
fun CounterSection(target: Int = 10, step: Int = 1)
Enter fullscreen mode
Exit fullscreen mode
Default Values: Kotlin's parameter defaults reduce boilerplate
Named Parameters: CounterSection(target = 5, step = 2) for clarity
Type Safety: Int parameters prevent runtime type errors
âš¡ Smart State Management:
var count by rememberSaveable { mutableIntStateOf(0) }
Enter fullscreen mode
Exit fullscreen mode
Property Delegation: by keyword creates clean syntax
Configuration Survival: State survives screen rotations automatically
Type-Specific State: mutableIntStateOf is optimized for integers
ğŸ“Š Advanced State Management: Kotlin's Reactive Patterns
Let's dive into the sophisticated state management that powers our counter:
@Composable
fun CounterSection(target: Int = 10, step: Int = 1) {
// Core state with automatic persistence
var count by rememberSaveable { mutableIntStateOf(0) }
// Coroutine scope for async operations
val scope = rememberCoroutineScope()
// Snackbar state for undo functionality
val snackbarHost = remember { SnackbarHostState() }
// Derived state and smart calculations
val progress = if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
val reached = target in 1..count
}
Enter fullscreen mode
Exit fullscreen mode
Kotlin State Management Highlights:
ğŸ¯ Derived State with Smart Calculations:
val progress = if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
val reached = target in 1..count
// Range operator for elegant logic
Enter fullscreen mode
Exit fullscreen mode
ğŸ’ Kotlin Features in Action:
Range Operators: target in 1..count is more readable than target >= 1 && target <= count
Extension Functions: coerceIn(0f, 1f) ensures safe bounds
Type Conversion: Explicit toFloat() for precise calculations
Elvis Operator Alternative: Using if expressions for clarity
ğŸ”’ Safe State Operations:
onDecrement = { if (count > 0) count -= step }
// Prevents negative values
onReset = { /* Complex undo logic with snackbar */ }
Enter fullscreen mode
Exit fullscreen mode
ğŸ­ Animation Excellence: Kotlin DSL + Compose Magic
Our counter showcases smooth animations using Kotlin's expressive DSL syntax:
AnimatedContent(
targetState = count,
transitionSpec = {
fadeIn(tween(180)) togetherWith fadeOut(tween(180))
},
label = "count-anim"
) { value ->
Text(
"Tu as cliquÃ© $value fois",
style = MaterialTheme.typography.headlineSmall,
color = if (reached) MaterialTheme.colorScheme.primary else LocalContentColor.current
)
}
Enter fullscreen mode
Exit fullscreen mode
Kotlin Animation DSL Breakdown:
ğŸ¨ Declarative Animation Syntax:
fadeIn(tween(180)) togetherWith fadeOut(tween(180))
Enter fullscreen mode
Exit fullscreen mode
Infix Functions: togetherWith creates readable animation combinations
DSL Builder: tween(180) uses Kotlin's builder pattern for animation specs
Method Chaining: Compose animations leverage Kotlin's fluent interfaces
âš¡ Smart Content Transitions:
AnimatedContent(targetState = count) { value ->
Text("Tu as cliquÃ© $value fois")
}
Enter fullscreen mode
Exit fullscreen mode
Lambda with Receiver: The value parameter gets the current animated state
Automatic Triggering: Animation runs whenever count changes
Type Safety: value is strongly typed as Int
ğŸ¯ Conditional Styling with Kotlin:
color = if (reached) MaterialTheme.colorScheme.primary else LocalContentColor.current
Enter fullscreen mode
Exit fullscreen mode
Ternary-like Logic: Kotlin's if expressions for conditional values
Material Design Integration: Smart color selection based on state
ğŸš€ Advanced UX: Undo Functionality with Kotlin Coroutines
Our counter implements sophisticated undo functionality using Kotlin's coroutine capabilities:
onReset = {
val before = count
// Capture current state
count = 0
// Immediate reset for responsive UI
scope.launch {
// Async snackbar handling
val result = snackbarHost.showSnackbar(
message = "Compteur remis Ã  zÃ©ro",
actionLabel = "Annuler",
withDismissAction = true
)
// Handle user response
if (result == SnackbarResult.ActionPerformed) {
count = before
// Restore previous value
}
}
}
Enter fullscreen mode
Exit fullscreen mode
Advanced Kotlin UX Patterns:
ğŸ¯ State Snapshot Pattern:
val before = count
// Immutable snapshot
count = 0
// Immediate UI update
Enter fullscreen mode
Exit fullscreen mode
Optimistic Updates: UI responds immediately
State Capture: Previous value stored for potential restoration
Immutable References: val before prevents accidental modification
âš¡ Coroutine-Based Async UX:
scope.launch {
val result = snackbarHost.showSnackbar(/* params */)
if (result == SnackbarResult.ActionPerformed) count = before
}
Enter fullscreen mode
Exit fullscreen mode
Non-Blocking UI: Snackbar doesn't freeze the interface
Structured Concurrency: scope.launch ties coroutine to component lifecycle
Result Handling: Elegant enum-based result processing
ğŸ”§ Kotlin Enum Advantages:
if (result == SnackbarResult.ActionPerformed)
Enter fullscreen mode
Exit fullscreen mode
Type Safety: Compile-time verification of result types
Exhaustive Checking: Compiler ensures all cases are handled
No Magic Strings: Enum values prevent typos
ğŸ¨ Component Composition: Kotlin's Function Excellence
Our architecture demonstrates clean separation using Kotlin's function composition:
@Composable
private fun CounterContent(
count: Int,
target: Int,
onIncrement: () -> Unit,
onDecrement: () -> Unit,
onReset: () -> Unit,
modifier: Modifier = Modifier
) {
val progress = if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
val reached = target in 1..count
Column(
modifier = modifier,
verticalArrangement = Arrangement.spacedBy(16.dp),
horizontalAlignment = Alignment.CenterHorizontally
) {
// Pure UI rendering logic
}
}
Enter fullscreen mode
Exit fullscreen mode
Kotlin Composition Benefits:
ğŸ¯ Function Type Parameters:
onIncrement: () -> Unit,
onDecrement: () -> Unit,
onReset: () -> Unit
Enter fullscreen mode
Exit fullscreen mode
Higher-Order Functions: Clean event handling without interfaces
Type Safety: () -> Unit ensures no return value expected
Lambda Support: Callers can pass inline lambdas or function references
ğŸ”’ Immutable Props Pattern:
count: Int,
// Read-only state
target: Int,
// Configuration parameter
modifier: Modifier = Modifier
// Styling with default
Enter fullscreen mode
Exit fullscreen mode
Pure Functions: No side effects in presentation layer
Predictable Rendering: Same inputs always produce same output
Easy Testing: Pure functions are simple to test
âš¡ Derived State Calculations:
val progress = if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
val reached = target in 1..count
Enter fullscreen mode
Exit fullscreen mode
Local Calculations: Derived state computed in presentation layer
Performance: Simple calculations don't need memoization
Readability: Logic is clear and self-documenting
ğŸ¯ Smart Button Logic: Kotlin's Conditional Excellence
Our button states demonstrate Kotlin's expressive conditional logic:
Row(
horizontalArrangement = Arrangement.spacedBy(12.dp),
verticalAlignment = Alignment.CenterVertically
) {
IconButton(
onClick = onDecrement,
enabled = count > 0
// Smart enabling
) {
Icon(Icons.Filled.Remove, contentDescription = "DÃ©crÃ©menter")
}
Button(onClick = onIncrement) {
Icon(Icons.Filled.Add, contentDescription = null)
Spacer(Modifier.width(8.dp))
Text("IncrÃ©menter")
}
OutlinedButton(
onClick = onReset,
enabled = count != 0
// Only enable when there's something to reset
) {
Text("RÃ©initialiser")
}
}
Enter fullscreen mode
Exit fullscreen mode
Kotlin Button Logic Patterns:
ğŸ¯ Smart State-Based Enabling:
enabled = count > 0
// Decrement only when positive
enabled = count != 0
// Reset only when non-zero
Enter fullscreen mode
Exit fullscreen mode
Boolean Expressions: Direct state-to-UI mapping
No Complex Logic: Simple, readable conditions
Automatic Updates: UI enables/disables as state changes
âš¡ Material Design Integration:
Icon(Icons.Filled.Add, contentDescription = null)
Enter fullscreen mode
Exit fullscreen mode
Vector Icons: Material Design icons with type safety
Accessibility: contentDescription for screen readers
Null Safety: Kotlin's null handling for optional descriptions
ğŸƒâ€â™‚ï¸ Progress Tracking: Kotlin's Mathematical Elegance
Our progress calculation showcases Kotlin's mathematical expressiveness:
// In CounterContent composable
val progress = if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
val reached = target in 1..count
// Progress indicator
if (target > 0) {
LinearProgressIndicator(
progress = { progress },
modifier = Modifier
.fillMaxWidth()
.height(4.dp)
)
Text(
if (reached) "Objectif atteint ğŸ‰" else "Objectif : $target",
style = MaterialTheme.typography.labelMedium
)
}
Enter fullscreen mode
Exit fullscreen mode
Kotlin Mathematical Features:
ğŸ”¢ Safe Division with Guards:
if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
Enter fullscreen mode
Exit fullscreen mode
Division by Zero Protection: Guard clause prevents runtime errors
Explicit Type Conversion: toFloat() for precise calculations
Bounds Checking: coerceIn(0f, 1f) ensures valid progress values
ğŸ“ Range Operator for State Checking:
val reached = target in 1..count
Enter fullscreen mode
Exit fullscreen mode
Inclusive Ranges: 1..count includes both endpoints
Readable Logic: More expressive than target >= 1 && target <= count
Type Safety: Compiler ensures range compatibility
ğŸ¯ Conditional Rendering Pattern:
if (target > 0) {
// Show progress UI only when target is set
}
Enter fullscreen mode
Exit fullscreen mode
ğŸ§ª Testing Excellence: Kotlin's Testing Elegance
Our counter includes comprehensive UI testing that demonstrates Kotlin's testing capabilities:
class CounterSectionTest {
@get:Rule
val composeRule = createAndroidComposeRule<ComponentActivity>()
@Test
fun incrementButton_increasesCountText() {
composeRule.setContent {
CounterSection(target = 3)
}
composeRule.onNodeWithText("Tu as cliquÃ© 0 fois").assertExists()
composeRule.onNodeWithText("IncrÃ©menter").performClick()
composeRule.onNodeWithText("Tu as cliquÃ© 1 fois").assertExists()
}
}
Enter fullscreen mode
Exit fullscreen mode
Kotlin Testing Advantages:
ğŸ¯ Type-Safe Test Configuration:
CounterSection(target = 3)
// Named parameters for clarity
Enter fullscreen mode
Exit fullscreen mode
Named Parameters: Crystal clear test setup
Default Values: Only specify what matters for each test
Compile-Time Safety: Invalid parameters caught at compile time
âš¡ Fluent Testing DSL:
composeRule.onNodeWithText("Tu as cliquÃ© 0 fois").assertExists()
Enter fullscreen mode
Exit fullscreen mode
Method Chaining: Readable test assertions
Type Safety: Compile-time verification of test operations
Extension Functions: Compose testing leverages Kotlin's extensions
ğŸ”§ Advanced Testing Possibilities:
// Could test undo functionality
@Test
fun resetButton_showsUndoSnackbar() = runTest {
// Test the coroutine-based undo logic
}
// Could test progress calculations
@Test
fun progress_calculatesCorrectly() {
val progress = calculateProgress(count = 5, target = 10)
assertEquals(0.5f, progress, 0.01f)
}
Enter fullscreen mode
Exit fullscreen mode
ğŸš€ Performance Optimizations: Kotlin's Efficiency
Memory & Rendering Efficiency
âš¡ Smart State Updates:
var count by rememberSaveable { mutableIntStateOf(0) }
// Primitive state
Enter fullscreen mode
Exit fullscreen mode
Primitive State: mutableIntStateOf avoids boxing overhead
Structural Equality: Integer comparison is efficient
Minimal Recomposition: Only affected UI elements update
ğŸ¯ Derived State Performance:
val progress = if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
Enter fullscreen mode
Exit fullscreen mode
Calculated on Demand: No unnecessary caching for simple calculations
Inline Functions: coerceIn compiles to efficient bytecode
No Object Allocation: Primitive calculations avoid garbage collection
Advanced Kotlin Optimizations
ğŸ”§ Potential Enhancements:
// For complex counters, could use derivedStateOf
val progress by remember(count, target) {
derivedStateOf {
if (target > 0) (count.toFloat() / target).coerceIn(0f, 1f) else 0f
}
}
// Extension function for reusability
fun Int.progressToward(target: Int): Float =
if (target > 0) (this.toFloat() / target).coerceIn(0f, 1f) else 0f
Enter fullscreen mode
Exit fullscreen mode
ğŸ¯ Production Considerations & Best Practices
Error Handling & Edge Cases
ğŸ›¡ï¸ Defensive Programming:
onDecrement = { if (count > 0) count -= step }
// Prevent negative values
val progress = if (target > 0) /* calculate */ else 0f
// Handle zero target
Enter fullscreen mode
Exit fullscreen mode
âš¡ Kotlin Safety Features:
Null Safety: No null pointer exceptions
Range Checks: coerceIn prevents invalid values
Type Safety: Int state prevents string/float confusion
Accessibility & Internationalization
â™¿ Accessibility Support:
Icon(Icons.Filled.Remove, contentDescription = "DÃ©crÃ©menter")
Enter fullscreen mode
Exit fullscreen mode
Content Descriptions: Screen reader support
Material Design: Built-in accessibility features
Semantic Elements: Proper button/text role
ğŸŒ I18n Considerations:
// Could be enhanced with string resources
Text(stringResource(R.string.clicked_times, count))
Enter fullscreen mode
Exit fullscreen mode
ğŸ“ Key Takeaways & Kotlin Insights
ğŸ—ï¸ Architecture Lessons
Component Composition: Breaking UI into small, testable functions
Higher-Order Functions: Clean event handling without complex interfaces
Pure Presentation: Separate state management from UI rendering
Appropriate Complexity: Simple features don't need over-engineering
âš¡ Kotlin Language Features
Property Delegates: by rememberSaveable for clean state syntax
Default Parameters: Reduce boilerplate and improve API usability
Range Operators: in 1..count for expressive logic
Extension Functions: coerceIn for safe value manipulation
Lambda Expressions: Clean event handling patterns
ğŸ¨ Compose Integration
Declarative UI: State changes automatically update UI
Animation DSL: Kotlin's expressive syntax for smooth transitions
Testing Support: Type-safe UI testing with minimal boilerplate
Performance: Primitive state types for optimal rendering
ğŸ”§ UX Excellence
Optimistic Updates: Immediate UI feedback with async operations
Undo Functionality: Professional-grade error recovery
Progress Visualization: Clear feedback on goal achievement
Accessibility: Screen reader support and semantic markup
ğŸ’­ Final Thoughts
This Counter component demonstrates that even simple UI elements can showcase sophisticated Kotlin features and UX patterns. By leveraging Kotlin's expressivenessâ€”from property delegates to coroutines to higher-order functionsâ€”we've built a component that's both delightful to use and maintainable to develop.
The combination of Kotlin's language features, Compose's reactive paradigm, and thoughtful UX design creates components that feel native to both the platform and the development experience. Whether you're building simple counters or complex interfaces, these patterns scale to meet your application's needs.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
â€¢
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
A0mineTV
Follow
ğŸ’» Freelance Web Developer specializing in PHP, Laravel, and Vue.js.
ğŸ¯ Passionate about building elegant and efficient solutions.
ğŸš€ "Code with passion, share with purpose."
Location
France
Work
Freelance Web Dev - Fullstack
Joined
Nov 19, 2024
More from A0mineTV
Build a Secure CRUD API with Node.js, Express & MongoDB (Mongoose)
#mongodb
#express
#backend
#tutorial
Shipping a Lean DDD-Friendly Inventory API in Laravel 12
#ddd
#webdev
#programming
#laravel
Claude Code vs GPTâ€‘5 Codex: which one should you use â€” and when ?
#ai
#openai
#coding
#programming
ğŸ’ DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community â€” A space to discuss and keep up software development and manage your software career
Home
Welcome Thread
Reading List
Tags
About
Contact
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem â€” the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community Â© 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account