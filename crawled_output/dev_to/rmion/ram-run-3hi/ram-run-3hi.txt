RAM Run - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Robert Mion
Posted on Sep 18
RAM Run
#adventofcode
#algorithms
#javascript
#programming
Solving Advent of Code Backwards (243 Part Series)
1
Sea Cucumber
2
Arithmetic Logic Unit
...
239 more parts...
3
Amphipod
4
Reactor Reboot
5
Dirac Dice
6
Trench Map
7
Beacon Scanner
8
Snailfish
9
Trick Shot
10
Packet Decoder
11
Chiton
12
Extended Polymerization
13
Transparent Origami
14
Passage Pathing
15
Dumbo Octopus
16
Syntax Scoring
17
Smoke Basin
18
Seven Segment Search
19
The Treachery of Whales
20
Lanternfish
21
Hydrothermal Venture
22
Giant Squid
23
Binary Diagnostic
24
Dive!
25
Sonar Sweep
26
Combo Breaker
27
Lobby Layout
28
Crab Cups
29
Crab Combat
30
Allergen Assessment
31
Jurassic Jigsaw
32
Monster Messages
33
Operation Order
34
Conway Cubes
35
Ticket Translation
36
Rambunctious Recitation
37
Docking Data
38
Shuttle Search
39
Rain Risk
40
Seating System
41
Adapter Array
42
Encoding Error
43
Handheld Halting
44
Handy Haversack
45
Custom Customs
46
Binary Boarding
47
Passport Processing
48
Toboggan Trajectory
49
Password Philosophy
50
Report Repair
51
Cryostasis
52
The Tyranny of the Rocket Equation
53
1202 Program Alarm
54
Crossed Wires
55
Secure Container
56
Sunny with a Chance of Asteroids
57
Universal Orbit Map
58
Amplification Circuit
59
Space Image Format
60
Sensor Boost
61
Monitoring Station
62
Space Police
63
The N-Body Problem
64
Care Package
65
Space Stoichiometry
66
Oxygen System
67
Flawed Frequency Transmission
68
Set and Forget
69
Many-Worlds Interpretation
70
Tractor Beam
71
Donut Maze
72
Springdroid Adventure
73
Slam Shuffle
74
Category Six
75
Planet of Discord
76
Four-Dimensional Adventure
77
Immune System Simulator 20XX
78
Experimental Emergency Teleportation
79
Mode Maze
80
Chronal Classification
81
Go With The Flow
82
Chronal Conversion
83
A Regular Map
84
Settlers of The North Pole
85
Reservoir Research
86
Beverage Bandits
87
Chocolate Charts
88
Mine Cart Madness
89
Subterranean Sustainability
90
Chronal Charge
91
The Stars Align
92
Marble Mania
93
Memory Maneuver
94
The Sum of Its Parts
95
Chronal Coordinates
96
Alchemical Reduction
97
Repose Record
98
No Matter How You Slice It
99
Inventory Management System
100
Chronal Calibration
101
The Halting Problem
102
Electromagnetic Moat
103
Duet
104
Coprocessor Conflagration
105
Sporifica Virus
106
Fractal Art
107
Particle Swarm
108
A Series of Tubes
109
Spinlock
110
Permutation Promenade
111
Dueling Generators
112
Knot Hash
113
Disk Defragmentation
114
Packet Scanners
115
Digital Plumber
116
Hex Ed
117
Stream Processing
118
I Heard You Like Registers
119
Recursive Circus
120
Memory Reallocation
121
A Maze of Twisty Trampolines, All Alike
122
High-Entropy Passphrases
123
Spiral Memory
124
Corruption Checksum
125
Inverse Captcha
126
Radioisotope Thermoelectric Generators
127
Leonardo's Monorail
128
Safe Cracking
129
Clock Signal
130
Air Duct Spelunking
131
Grid Computing
132
Scrambled Letters and Hash
133
Firewall Rules
134
An Elephant Named Joseph
135
Like a Rogue
136
Two Steps Forward
137
Dragon Checksum
138
Timing is Everything
139
One-Time Pad
140
A Maze of Twisty Little Cubicles
141
Balance Bots
142
Explosives in Cyberspace
143
Two-Factor Authentication
144
Internet Protocol Version 7
145
Signals and Noise
146
How About a Nice Game of Chess?
147
Security Through Obscurity
148
Squares With Three Sides
149
Bathroom Security
150
No Time for a Taxicab
151
Let It Snow
152
It Hangs in the Balance
153
Opening the Turing Lock
154
RPG Simulator 20XX
155
Wizard Simulator 20XX
156
Infinite Elves and Infinite Houses
157
Medicine for Rudolph
158
Probably a Fire Hazard
159
Like a GIF For Your Yard
160
No Such Thing as Too Much
161
Aunt Sue
162
Science for Hungry People
163
Reindeer Olympics
164
Knights of the Dinner Table
165
JSAbacusFramework.io
166
Corporate Policy
167
Elves Look, Elves Say
168
All in a Single Night
169
Matchsticks
170
Some Assembly Required
171
Doesn't He Have Intern-Elves For This?
172
The Ideal Stocking Stuffer
173
Perfectly Spherical Houses in a Vacuum
174
I Was Told There Would Be No Math
175
Not Quite Lisp
176
Calorie Counting
177
Rock Paper Scissors
178
Rucksack Reorganization
179
Camp Cleanup
180
Supply Stacks
181
Tuning Trouble
182
No Space Left On Device
183
Treetop Tree House
184
Rope Bridge
185
Cathode-Ray Tube
186
Monkey in the Middle
187
Hill Climbing Algorithm
188
Distress Signal
189
Regolith Reservoir
190
Beacon Exclusion Zone
191
Proboscidea Volcanium
192
Pyroclastic Flow
193
Boiling Boulders
194
Not Enough Minerals
195
Grove Positioning System
196
Monkey Math
197
Monkey Map
198
Unstable Diffusion
199
Blizzard Basin
200
Full of Hot Air
201
Trebuchet?!
202
Cube Conundrum
203
Gear Ratios
204
Scratchcards
205
If You Give A Seed A Fertilizer
206
Wait For It
207
Camel Cards
208
Haunted Wasteland
209
Mirage Maintenance
210
Pipe Maze
211
Cosmic Expansion
212
Hot Springs
213
Point of Incidence
214
Parabolic Reflector Dish
215
Lens Library
216
The Floor Will Be Lava
217
Clumsy Crucible
218
Lavaduct Lagoon
219
Aplenty
220
Pulse Propagation
221
Step Counter
222
Sand Slabs
223
A Long Walk
224
Never Tell Me The Odds
225
Snowverload
226
Historian Hysteria
227
Red-Nosed Reports
228
Mull It Over
229
Ceres Search
230
Print Queue
231
Guard Gallivant
232
Bridge Repair
233
Resonant Collinearity
234
Disk Fragmenter
235
Hoof It
236
Plutonian Pebbles
237
Garden Groups
238
Claw Contraption
239
Restroom Redoubt
240
Warehouse Woes
241
Reindeer Maze
242
Chronospatial Computer
243
RAM Run
Advent of Code 2024 Day 18
Part 1
Another variation of smallest possible answer
A few of the last several puzzles required finding the smallest valid answer.
One recent puzzle felt nearly identical to this one in that I had to explore every path within a maze from start to finish in order to identify the shortest path.
I don't love these puzzle types because I haven't learned how to re-create a proper shortest-path algorithm, commonly referred to as Djikstra's algorithm or an A* algorithm, I believe.
Instead, when I attempt them, I leverage the skills I have: recursion, novice memoization, and brute force
Sadly, most of these puzzle variations show up after Day 12, where Part 2 is usually a test of identifying some pattern in the data to jump straight to the answer, or of building an algorithm that can quickly eliminate billions or trillions of incorrect paths.
I say all of that only to admit once again:
I'll be proud to come away with one gold star today
And I won't be mad if I come away with zero
Process part of the input and create the grid
The input is a list of X,Y coordinates in a 70x70 grid.
Except the example grid is 6x6.
Making the grid is simple:
function makeGrid(width, height) {
return new Array(height + 1)
.fill(0)
.map(
el => new Array(width + 1).fill('.')
)
}
Enter fullscreen mode
Exit fullscreen mode
Calling my function looks like:
let grid = makeGrid(6,6)
Enter fullscreen mode
Exit fullscreen mode
And seeing it as a grid looks like:
console.log(grid.map(line => line.join('')).join('\n'))
Enter fullscreen mode
Exit fullscreen mode
Viola!
.......
.......
.......
.......
.......
.......
.......
Enter fullscreen mode
Exit fullscreen mode
Now to generate the list of coordinates from the input:
let coords = input.split('\n').map(coord => coord.split(',').map(Number))
Enter fullscreen mode
Exit fullscreen mode
An explanation:
Split the text at each new line
Split each coordinate string at the comma
Convert each string to a number
Lastly, changing only up to a certain amount of cells to corrupted:
function updateGrid(amt) {
coords.slice(0, amt).forEach(coord => {
grid[coord[1]][coord[0]] = '#'
})
}
Enter fullscreen mode
Exit fullscreen mode
When I call it with 12:
updateGrid(12)
Enter fullscreen mode
Exit fullscreen mode
I correctly see this:
...#...
..#..#.
....#..
...#..#
..#..#.
.#..#..
#.#....
Enter fullscreen mode
Exit fullscreen mode
Well, that was fun and easy!
Next, I'll employ my usual strategy of adding a border around the grid to prevent the need for overly-complex conditions in my main loop.
Pad the grid with a 1-cell-wide border
I need to add a cell around each bordering cell in the grid.
The way I've done this in past challenges is with the following function:
function addGridBorder() {
grid = grid.map(row => ['#', ...row, '#'])
grid = [
new Array(size + 2).fill('#'),
...grid,
new Array(size + 2).fill('#'),
]
}
Enter fullscreen mode
Exit fullscreen mode
What it does:
Adds a cell to each existing row, at the beginning and end
Adds two rows to the grid, at the beginning and end, containing the new amount of cells
And with that, my example grid now looks like this:
#########
#...#...#
#..#..#.#
#....#..#
#...#..##
#..#..#.#
#.#..#..#
##.#....#
#########
Enter fullscreen mode
Exit fullscreen mode
The only change I have to pay attention to is my new start and end coordinates, since they will now be one off for both X and Y coordinates:
let start = [1, 1]
let end = [size, size]
Enter fullscreen mode
Exit fullscreen mode
...where size is the width/height of the grid when counting from 0 (e.g. size 7 equates to a grid from 0-6 like in the example)
Now for the super hard part...
A program that explores all possible paths and hopefully terminates eventually
The beginnings of a recursive function
If I'm charting a path through a grid, I'm gonna use recursion.
function walkGrid(n) {
if () {
} else {
walkGrid(n - 1)
}
}
Enter fullscreen mode
Exit fullscreen mode
The conditions will be more robust than n, of course.
What will I need to keep track of?
The current cell in the grid
The cells previously visited (doubling as the number of steps taken)
And what should the base cases be?
Adjacent cells are dead ends or already visited
Number of steps taken is greater than the current winner for least number of steps
I'll build each of these parts of the algorithm in the next few sections.
Which cells came before?
Throughout the recursive function, I need to keep track of which cells have been visited.
Only by doing this can I arrive at a base case where all four of the next cells are one of either:
A dead end
A backstep
So, I need a list that can store a unique set of points:
let visited = new Set()
Enter fullscreen mode
Exit fullscreen mode
And I won't add the list of X,Y coordinates to it. First, I'll convert to a string so it is seen as unique in JavaScript's brain:
visited.add([X,Y].join(','))
Enter fullscreen mode
Exit fullscreen mode
Which cells could come next?
First, the usual list of four nearby cell relative coordinates:
let nearby = [
[0,1],
[1,0],
[0,-1],
[-1,0]
]
Enter fullscreen mode
Exit fullscreen mode
Those represent each possible next move ($) for any given originating cell (*):
.$.
$*$
.$.
Enter fullscreen mode
Exit fullscreen mode
What will the function invocation look like?
The first time I call walkGrid(), what might the call look like?
let start = [1,1]
let visited = new Set()
walkGrid(start, visited)
Enter fullscreen mode
Exit fullscreen mode
Is that enough arguments? Only one way to find out!
Time for some pseudocode!
function walkGrid(start, visited) {
if ( /* arrived at bottom-right corner of grid */ ) {
// how many cells were visited?
// compare to current winner and update if appropriate
} else {
// check all adjacent cells
if ( /* no adjacent cells can come next */ ) {
// exit this iteration
} else {
// call function again for each possible next move
nearby.forEach(walkGrid(next, visited))
}
}
}
Enter fullscreen mode
Exit fullscreen mode
That only took a few minutes to think through.
It feels like it accounts for the main things, but I may very well have missed something.
I'm ready to flesh it out into actual code.
A first attempt at putting the pieces together
After filling in the first base case, my function now looks like this:
function walkGrid(current, visited) {
visited.add(current.join(','))
if ( current.join(',') == end.join(',') ) {
fewestSteps = Math.min(visited.size, fewestSteps);
return false;
} else {}
}
Enter fullscreen mode
Exit fullscreen mode
I added a variable to track the winning number of steps:
let fewestSteps = Infinity
Enter fullscreen mode
Exit fullscreen mode
After another few minutes, I added code to the else clause:
function walkGrid(current, visited) {
visited.add(current.join(','))
if ( current.join(',') == end.join(',') ) {
fewestSteps = Math.min(visited.size, fewestSteps);
return false;
} else {
let next = nearby.map(
coord => grid[coord[0] + current[0]][coord[1] + current[1]] == '#' ? false : true
)
if ( next.every(el => el == false) ) {
return false;
} else {
next.forEach((el, index) => {
el ? walkGrid([current[0] + nearby[index][0], current[1] + nearby[index][1]], visited) : null
})
}
}
}
Enter fullscreen mode
Exit fullscreen mode
It may not be eloquent, but it should make sense after you can decipher the array accessing syntax and math.
The big question is: does it even work?
Before I run it, I'll add some logging statements.
Well, just one for now:
if ( current.join(',') == end.join(',') ) {
console.log(current, visited.size)
fewestSteps = Math.min(visited.size, fewestSteps);
return false;
}
Enter fullscreen mode
Exit fullscreen mode
I'll know it works if it can reach this base case and at some point print out the correct answer, 22.
Time to press run and see what kind of errors I see!
So. Many. Bugs.
Max call stack exceeded
Can't access some variable before it's defined
Visited coordinate list isn't growing beyond three items
Turns out, I had syntax errors and logic gaps.
Thankfully, it's kind of fun to debug.
After fixing those issues, I saw longer lists of visited coordinates print.
But the coordinates included dead ends.
Why is that?
Oh, right, because every time I enter the function, I add the current coordinate to the visited list.
So, even if the shortest path doesn't include that point, since it was visited as part of an earlier iteration, it gets added.
How might I prevent this from happening?
Thankfully, I can delete an item from a Set():
visited.delete(current.join(',))
Enter fullscreen mode
Exit fullscreen mode
I do that in the condition checking for all adjacent cells being dead ends or already visited:
if ( next.every(el => el == false) ) {
visited.delete(current.join(','))
return false;
}
Enter fullscreen mode
Exit fullscreen mode
Running again with fewer logging statements:
I see whenever it hits a dead end
I see a number printed when it hits the target end point
But I'm seeing a number one greater than the expected answer.
Why? Because I include the starting location in my visited list.
The answer asks for the number of steps taken.
That's one less than an amount that includes the starting location.
Accounting for that, my algorithm spits out the correct answer!
But something seems odd still:
Why doesn't it print any of the possible higher numbers associated with paths that initially lead down?
To test this, I adjust the order of my adjacent cells...to go down first.
Running again, I get a different answer - a larger one.
Why is my function seemingly only exploring one path?
Hmmmm.
My hunch is I'm doing two things wrong:
I need to use a unique set of visited points each time I further recurse into the function
I need to clean up my condition for recursing
After both are complete, my larger last condition looks like this:
if ( next.every(el => el == false) ) {
visited.delete(current.join(','))
return false;
} else {
next.forEach((el, index) => {
if (el) {
walkGrid(
[
current[0] + nearby[index][0],
current[1] + nearby[index][1]
], new Set(visited))
} else {
return false
}
})
}
Enter fullscreen mode
Exit fullscreen mode
Oh, and I forgot to add my performance-boosting condition that breaks early if a path is longer than the current shortest:
if (visited.size - 1 > fewestSteps) {
return false
}
Enter fullscreen mode
Exit fullscreen mode
And with that, I press run again...
and see the correct answer!
In fact, regardless of the order of adjacent cell coordinates, I see the correct answer!
Woohoo!
Now for the real test: my puzzle input.
Will my algorithm ever finish?
Will it generate the correct answer?
I wonder...
Processing my puzzle input
I see numbers.
They are decreasing gradually.
No errors yet.
Still waiting.
This may take a while.
As long as the program doesn't abruptly stop, I can wait.
...
I let my program run for several hours.
The number it printed last was only a dozen less than the number it printed several hours prior.
I'm 100% positive it is not the correct answer.
And I was 99% positive I wouldn't get even one gold star today because of this shortest-path challenge.
It's a bummer, but expected by Day 18.
It's also time to move on.
Solving Advent of Code Backwards (243 Part Series)
1
Sea Cucumber
2
Arithmetic Logic Unit
...
239 more parts...
3
Amphipod
4
Reactor Reboot
5
Dirac Dice
6
Trench Map
7
Beacon Scanner
8
Snailfish
9
Trick Shot
10
Packet Decoder
11
Chiton
12
Extended Polymerization
13
Transparent Origami
14
Passage Pathing
15
Dumbo Octopus
16
Syntax Scoring
17
Smoke Basin
18
Seven Segment Search
19
The Treachery of Whales
20
Lanternfish
21
Hydrothermal Venture
22
Giant Squid
23
Binary Diagnostic
24
Dive!
25
Sonar Sweep
26
Combo Breaker
27
Lobby Layout
28
Crab Cups
29
Crab Combat
30
Allergen Assessment
31
Jurassic Jigsaw
32
Monster Messages
33
Operation Order
34
Conway Cubes
35
Ticket Translation
36
Rambunctious Recitation
37
Docking Data
38
Shuttle Search
39
Rain Risk
40
Seating System
41
Adapter Array
42
Encoding Error
43
Handheld Halting
44
Handy Haversack
45
Custom Customs
46
Binary Boarding
47
Passport Processing
48
Toboggan Trajectory
49
Password Philosophy
50
Report Repair
51
Cryostasis
52
The Tyranny of the Rocket Equation
53
1202 Program Alarm
54
Crossed Wires
55
Secure Container
56
Sunny with a Chance of Asteroids
57
Universal Orbit Map
58
Amplification Circuit
59
Space Image Format
60
Sensor Boost
61
Monitoring Station
62
Space Police
63
The N-Body Problem
64
Care Package
65
Space Stoichiometry
66
Oxygen System
67
Flawed Frequency Transmission
68
Set and Forget
69
Many-Worlds Interpretation
70
Tractor Beam
71
Donut Maze
72
Springdroid Adventure
73
Slam Shuffle
74
Category Six
75
Planet of Discord
76
Four-Dimensional Adventure
77
Immune System Simulator 20XX
78
Experimental Emergency Teleportation
79
Mode Maze
80
Chronal Classification
81
Go With The Flow
82
Chronal Conversion
83
A Regular Map
84
Settlers of The North Pole
85
Reservoir Research
86
Beverage Bandits
87
Chocolate Charts
88
Mine Cart Madness
89
Subterranean Sustainability
90
Chronal Charge
91
The Stars Align
92
Marble Mania
93
Memory Maneuver
94
The Sum of Its Parts
95
Chronal Coordinates
96
Alchemical Reduction
97
Repose Record
98
No Matter How You Slice It
99
Inventory Management System
100
Chronal Calibration
101
The Halting Problem
102
Electromagnetic Moat
103
Duet
104
Coprocessor Conflagration
105
Sporifica Virus
106
Fractal Art
107
Particle Swarm
108
A Series of Tubes
109
Spinlock
110
Permutation Promenade
111
Dueling Generators
112
Knot Hash
113
Disk Defragmentation
114
Packet Scanners
115
Digital Plumber
116
Hex Ed
117
Stream Processing
118
I Heard You Like Registers
119
Recursive Circus
120
Memory Reallocation
121
A Maze of Twisty Trampolines, All Alike
122
High-Entropy Passphrases
123
Spiral Memory
124
Corruption Checksum
125
Inverse Captcha
126
Radioisotope Thermoelectric Generators
127
Leonardo's Monorail
128
Safe Cracking
129
Clock Signal
130
Air Duct Spelunking
131
Grid Computing
132
Scrambled Letters and Hash
133
Firewall Rules
134
An Elephant Named Joseph
135
Like a Rogue
136
Two Steps Forward
137
Dragon Checksum
138
Timing is Everything
139
One-Time Pad
140
A Maze of Twisty Little Cubicles
141
Balance Bots
142
Explosives in Cyberspace
143
Two-Factor Authentication
144
Internet Protocol Version 7
145
Signals and Noise
146
How About a Nice Game of Chess?
147
Security Through Obscurity
148
Squares With Three Sides
149
Bathroom Security
150
No Time for a Taxicab
151
Let It Snow
152
It Hangs in the Balance
153
Opening the Turing Lock
154
RPG Simulator 20XX
155
Wizard Simulator 20XX
156
Infinite Elves and Infinite Houses
157
Medicine for Rudolph
158
Probably a Fire Hazard
159
Like a GIF For Your Yard
160
No Such Thing as Too Much
161
Aunt Sue
162
Science for Hungry People
163
Reindeer Olympics
164
Knights of the Dinner Table
165
JSAbacusFramework.io
166
Corporate Policy
167
Elves Look, Elves Say
168
All in a Single Night
169
Matchsticks
170
Some Assembly Required
171
Doesn't He Have Intern-Elves For This?
172
The Ideal Stocking Stuffer
173
Perfectly Spherical Houses in a Vacuum
174
I Was Told There Would Be No Math
175
Not Quite Lisp
176
Calorie Counting
177
Rock Paper Scissors
178
Rucksack Reorganization
179
Camp Cleanup
180
Supply Stacks
181
Tuning Trouble
182
No Space Left On Device
183
Treetop Tree House
184
Rope Bridge
185
Cathode-Ray Tube
186
Monkey in the Middle
187
Hill Climbing Algorithm
188
Distress Signal
189
Regolith Reservoir
190
Beacon Exclusion Zone
191
Proboscidea Volcanium
192
Pyroclastic Flow
193
Boiling Boulders
194
Not Enough Minerals
195
Grove Positioning System
196
Monkey Math
197
Monkey Map
198
Unstable Diffusion
199
Blizzard Basin
200
Full of Hot Air
201
Trebuchet?!
202
Cube Conundrum
203
Gear Ratios
204
Scratchcards
205
If You Give A Seed A Fertilizer
206
Wait For It
207
Camel Cards
208
Haunted Wasteland
209
Mirage Maintenance
210
Pipe Maze
211
Cosmic Expansion
212
Hot Springs
213
Point of Incidence
214
Parabolic Reflector Dish
215
Lens Library
216
The Floor Will Be Lava
217
Clumsy Crucible
218
Lavaduct Lagoon
219
Aplenty
220
Pulse Propagation
221
Step Counter
222
Sand Slabs
223
A Long Walk
224
Never Tell Me The Odds
225
Snowverload
226
Historian Hysteria
227
Red-Nosed Reports
228
Mull It Over
229
Ceres Search
230
Print Queue
231
Guard Gallivant
232
Bridge Repair
233
Resonant Collinearity
234
Disk Fragmenter
235
Hoof It
236
Plutonian Pebbles
237
Garden Groups
238
Claw Contraption
239
Restroom Redoubt
240
Warehouse Woes
241
Reindeer Maze
242
Chronospatial Computer
243
RAM Run
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Some comments may only be visible to logged-in visitors. Sign in to view all comments.
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
Robert Mion
Follow
I design. I write. And I code.
....and I mentor, tutor and coach developers!
Location
Rock Hill, SC
Work
Designer, strategist and technologist at a start-up, a small business, and an energy holding company
Joined
May 15, 2020
More from Robert Mion
Chronospatial Computer
#adventofcode
#algorithms
#javascript
#programming
Reindeer Maze
#adventofcode
#algorithms
#javascript
#programming
Warehouse Woes
#adventofcode
#algorithms
#javascript
#programming
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Reading List
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account