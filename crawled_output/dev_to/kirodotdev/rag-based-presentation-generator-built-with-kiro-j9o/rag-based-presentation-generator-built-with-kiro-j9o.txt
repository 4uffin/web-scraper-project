RAG-based Presentation Generator built with Kiro - DEV Community
Forem Feed
Follow new Subforems to improve your feed
DEV Community
Follow
A space to discuss and keep up software development and manage your software career
Gamers Forem
Follow
An inclusive community for gaming enthusiasts
Future
Follow
News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.
Music Forem
Follow
From composing and gigging to gear, hot music takes, and everything in between.
DUMB DEV Community
Follow
Memes and software development shitposting
Vibe Coding Forem
Follow
Discussing AI software development, and showing off what we're building.
Popcorn Movies and TV
Follow
Movie and TV enthusiasm, criticism and everything in-between.
Design Community
Follow
Web design, graphic design and everything in-between
Maker Forem
Follow
A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.
Scale Forem
Follow
For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google
Forem Core
Follow
Discussing the core forem open source software project — features, bugs, performance, self-hosting.
Security Forem
Follow
Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike
Open Forem
Follow
A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here
Crypto Forem
Follow
A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.
Dropdown menu
Dropdown menu
Skip to content
Navigation menu
Search
Powered by Algolia
Search
Log in
Create account
DEV Community
Close
Add reaction
Like
Unicorn
Exploding Head
Raised Hands
Fire
Jump to Comments
Save
Boost
More...
Moderate
Copy link
Copy link
Copied to Clipboard
Share to X
Share to LinkedIn
Share to Facebook
Share to Mastodon
Report Abuse
Vivek V.
for kirodotdev
Posted on Sep 15
• Originally published at vivek-aws.Medium
RAG-based Presentation Generator built with Kiro
#kiro
#s3vectors
#rag
#bedrock
How a presentation emergency inspired a new approach to AI-powered development
The Crisis That Started Everything
Picture this: 15 minutes before a major presentation, your file is corrupted. Hundreds of developers are waiting. Most would panic.
However, Donnie Prakoso, Principal Developer Advocate at AWS, turned to Amazon Q CLI. His methodical approach - requirements, task-based workflows, MCP tools - saved the day. But his key insight changed everything: "It's not about the AI tool itself, but how you integrate it into your workflow."
This real life scenario inspired me with the idea to build a full self-service serverless AI app, a Retrieval-Augmented Generation (RAG) - based Presentation Generator by using Kiro and leveraging these key capabilities:
Serverless AWS architecture with Bedrock Models
Real-time document processing with Bedrock Knowledge Base
Per-user data isolation for enterprise security
S3 Vectors integration (no Amazon OpenSearch Serverless) for cost-optimized storage
React frontend with modern Amplify v6 authentication
CDK infrastructure scaling from prototype to production
The Kiro Transformation
Remembering the workflow-first approach, I opened Kiro: "Help me build an AI-based Presentation Generator system with above key capabilities that can help with edit slides, geneate content, export the presentation to Marp, Reveal.js or HTML formats"
What happened next was unlike any coding experience I'd had.
Kiro didn't give generic answers. It broke down complexity into manageable tasks, analyzed my specific architecture needs with an accurate design, and hooked me to spec-driven development.
The Spec-Driven Revolution
Instead of one massive requirements document, over the development cycle, I created 5 different modular specs:
AWS-Native RAG spec: Core system with Bedrock and S3 Vectors
System Fixes spec: Surgical improvements without breaking production
UI Enhancement spec: Professional interface without backend risk
Blog Platform spec: Content creation system (generating this post)
Security Vulnerability Assessment specs: Full assessment of the system for any vulnerabilities to make sure the app is secure and production ready
Each spec operated independently. I could iterate fearlessly on complex use-cases separately and one-after-other.
Building Production AI: The Technical Journey
The S3 Vectors Breakthrough
When I mentioned vector storage costs, Kiro's MCP integration with my configured awslabs aws-knowledge-mcp-server immediately suggested S3 Vectors - a preview service yet fully searchable with the MCP server containing access to all examples and ready to use code from AWS blog posts and official AWS documentation:
"S3 Vectors can reduce costs by 90% compared to OpenSearch Serverless."
The implementation was game-changing. For instance, this single line saved hours of debugging.
s3vectors.create_index(
vectorBucketName=bucket_name,
indexName=index_name,
dimension=1024,
distanceMetric="cosine",
dataType="float32",
metadataConfiguration={
"nonFilterableMetadataKeys": ["AMAZON_BEDROCK_TEXT"]
# CRITICAL
}
)
Enter fullscreen mode
Exit fullscreen mode
The result: 90% cost reduction while maintaining full functionality.
I asked Kiro about CDK's current lack of native support for S3 Vectors (which would require implementing a Custom Lambda Resource), and we ended up with the optimal architectural decision
to handle vector index creation programmatically at runtime using the boto3 SDK during document ingestion, ensuring future compatibility and per-user isolation.
Kiro's test-driven development approach was revolutionary - it iterates on generated tests until they pass and the code achieves full functionality. By structuring specifications in repeatable, "declarative format", Kiro essentially functions as a specifications "compiler", transforming human-readable requirements directly into working code. This paradigm shift turns Kiro into an intelligent coding agent that bridges the gap between architectural intent and executable implementation, making spec-to-code transformation as reliable as traditional compilation processes.
System Architecture
Per-User Architecture Innovation
Kiro proposed something I hadn't considered - per-user Knowledge Bases:
Traditional: Shared KB → Complex filtering → Performance issues
Innovation: User A → KB A, User B → KB B → Perfect isolation
Enter fullscreen mode
Exit fullscreen mode
This architecture eliminated:
Complex metadata filtering
S3 Vectors 2KB metadata limits
Cross-user data contamination
Query performance bottlenecks
Complete CDK Infrastructure Generation
Instead of generic boilerplate, Kiro generated production-ready infrastructure:
// Generated by Kiro - Complete serverless stack
const knowledgeBaseRole = new iam.Role(this, 'KnowledgeBaseRole', {
assumedBy: new iam.ServicePrincipal('bedrock.amazonaws.com'),
inlinePolicies: {
S3VectorsPolicy: new iam.PolicyDocument({
statements: [
new iam.PolicyStatement({
actions: [
's3vectors:CreateVectorBucket',
's3vectors:GetIndex',
// Often missed, critical for debugging
's3vectors:QueryVectors'
],
resources: ['*'],
}),
],
}),
},
});
Enter fullscreen mode
Exit fullscreen mode
The code (thanks to the awslabs mcp server) included the often-missed s3vectors:GetIndex permission that would have taken hours to debug.
Sophisticated Lambda Functions
Kiro generated complete backend Lambda Function code with proper error handling:
class BedrockRAGService:
def search_similar_content(self, query: str, user_id: str, top_k: int = 5):
try:
user_kb_info = self._get_user_kb_info(user_id)
if not user_kb_info:
raise ValueError(f"No Knowledge Base found for user {user_id}")
response = self.bedrock_agent_runtime.retrieve(
knowledgeBaseId=user_kb_info['knowledge_base_id'],
retrievalQuery={'text': query},
retrievalConfiguration={
'vectorSearchConfiguration': {'numberOfResults': top_k}
}
)
return self._format_search_results(response)
except Exception as e:
logger.error(f"RAG search failed: {str(e)}")
return {'error': 'Search temporarily unavailable'}
Enter fullscreen mode
Exit fullscreen mode
The code included timeout handling, user-specific routing, and graceful error recovery - patterns that would have taken days to implement properly.
The Production Architecture
The application runs on:
Frontend: Next.js 15.4.5 + React 19.1.0, AWS Amplify v6, Webpack 5 (~170 KiB bundle)
Backend: Python 3.11 Lambda functions with Bedrock Knowledge Base integration
AI Services: Amazon Nova Pro + Titan embeddings, S3 Vectors storage
Data Layer: DynamoDB + S3 with per-user isolation
Cost Optimization: 90% reduction in vector storage costs vs traditional approaches
The Velocity Impact
Traditional Approach (Estimated):
Feature planning: 2-3 weeks
Cross-system coordination: 1-2 weeks
Implementation with risk mitigation: 4-6 weeks
Testing and validation: 2-3 weeks
Total: 9-14 weeks per feature
Spec-Driven Approach (Actual):
Focused spec creation: 2-3 days
Independent implementation: 1-2 days
Isolated testing: 3-5 days
Total: 1-2 weeks
Beyond Code Generation
Kiro understood broader context:
User Experience: Suggested async processing to avoid wait times
Cost Optimization: Recommended S3 Vectors for 90% savings
Security: Implemented per-user isolation without being asked
Scalability: Designed for 100 users per AWS account with clear scaling paths
The Automation Revolution
Kiro helped create agent hooks that eliminated entire bug categories:
CDK Synth Hook: Automatically validates infrastructure changes
README Spell Check: Maintains documentation quality
Test Automation: Runs comprehensive validation on every change
These hooks transformed development from reactive debugging to proactive quality assurance.
I heavily used my Kiro steering files that helped to maintain best practices all throughout the development cycle. Occasionally, I asked Kiro to automatically refine my steering files with the codebase, so it does not go off-track whenever implementing a new spec (I had total 5 specs for this project)
The Compound Effect
Spec-driven development changed how I approach complex systems:
Before: "How can I add this feature without breaking anything?"
After: "What focused spec addresses this specific concern?"
Before: "This change might affect multiple systems."
After: "This spec targets exactly one area."
The spec-driven development eliminated the fear of changing complex production systems.
Real-World Results
Milestone 1: AWS-Native RAG spec → Production deployment with S3 Vectors
Milestone 2: System Fixes spec → Critical issues resolved without disruption
Milestone 3: UI Enhancement spec → Professional interface without backend changes
Milestone 4: Blog Platform spec → Content creation system for sharing this story
Milestone 5: Security Assessment spec → Full vulnerability assessment of the system
Each spec operated independently, allowing rapid iteration without fear of breaking existing functionality.
The Future of AI Development
This approach scales beyond the RAG-based Presentation Generator:
Enterprise Applications: Core business logic, UI enhancement, performance optimization as separate specs
Microservices: Service foundation, API enhancement, monitoring as isolated concerns
AI Systems: Model integration, data processing, user interface as modular specifications
Key Takeaways
Workflow-first thinking beats tool-first approaches
Spec-driven development enables fearless iteration on complex systems
AI assistants excel at architectural guidance within structured processes
Modular specs prevent technical debt accumulation
Per-user architectures solve isolation and scaling challenges elegantly
Try It Yourself
The complete code is available at github.com/awsdataarchitect/ai-ppt-generator with detailed instructions for reproducing this spec-driven development approach.
The live AI PPT Generator showcases these techniques in production: https://main.d2ashs0ytllqag.amplifyapp.com
Experience how workflow-first AI development transforms complex AWS projects from chaotic research cycles into predictable, scalable methodologies.
The future of software development isn't about AI replacing developers - it's about integrating AI into workflows that amplify human creativity and eliminate the fear of building complex systems.
Top comments (0)
Subscribe
Personal
Trusted User
Create template
Templates let you quickly answer FAQs or store snippets for re-use.
Submit
Preview
Dismiss
Code of Conduct
•
Report abuse
Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink.
Hide child comments as well
Confirm
For further actions, you may consider blocking this person and/or reporting abuse
kirodotdev
Follow
More from kirodotdev
How Kiro Got Peekberry To Production and Our First Client
#kiro
#kirodotdev
#buildinpublic
#saas
How i Built Bloxely Using Kiro
#kiro
#webdev
Building an AI-Powered Chrome Extension with Kiro: From Tab Chaos to Organized Productivity
#kiro
#chromeextension
#ai
#productivity
💎 DEV Diamond Sponsors
Thank you to our Diamond Sponsors for supporting the DEV Community
Google AI is the official AI Model and Platform Partner of DEV
Neon is the official database partner of DEV
Algolia is the official search partner of DEV
DEV Community — A space to discuss and keep up software development and manage your software career
Home
DEV++
Welcome Thread
Reading List
Podcasts
Videos
Tags
DEV Education Tracks
DEV Challenges
DEV Help
Advertise on DEV
DEV Showcase
About
Contact
Free Postgres Database
Software comparisons
Forem Shop
Code of Conduct
Privacy Policy
Terms of Use
Built on Forem — the open source software that powers DEV and other inclusive communities.
Made with love and Ruby on Rails. DEV Community © 2016 - 2025.
We're a place where coders share, stay up-to-date and grow their careers.
Log in
Create account